/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function(global, factory) { /* global define, require, module */

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobufjs/minimal"], factory);

    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/minimal"));

})(this, function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots.protobuf || ($protobuf.roots.protobuf = {});
    
    $root.pb = (function() {
    
        /**
         * Namespace pb.
         * @exports pb
         * @namespace
         */
        var pb = {};
    
        pb.streamReq = (function() {
    
            /**
             * Properties of a streamReq.
             * @memberof pb
             * @interface IstreamReq
             * @property {number|null} [connectId] streamReq connectId
             * @property {number|null} [seq] streamReq seq
             * @property {string|null} [msgName] streamReq msgName
             * @property {Uint8Array|null} [msgData] streamReq msgData
             */
    
            /**
             * Constructs a new streamReq.
             * @memberof pb
             * @classdesc Represents a streamReq.
             * @implements IstreamReq
             * @constructor
             * @param {pb.IstreamReq=} [properties] Properties to set
             */
            function streamReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * streamReq connectId.
             * @member {number} connectId
             * @memberof pb.streamReq
             * @instance
             */
            streamReq.prototype.connectId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * streamReq seq.
             * @member {number} seq
             * @memberof pb.streamReq
             * @instance
             */
            streamReq.prototype.seq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * streamReq msgName.
             * @member {string} msgName
             * @memberof pb.streamReq
             * @instance
             */
            streamReq.prototype.msgName = "";
    
            /**
             * streamReq msgData.
             * @member {Uint8Array} msgData
             * @memberof pb.streamReq
             * @instance
             */
            streamReq.prototype.msgData = $util.newBuffer([]);
    
            /**
             * Creates a new streamReq instance using the specified properties.
             * @function create
             * @memberof pb.streamReq
             * @static
             * @param {pb.IstreamReq=} [properties] Properties to set
             * @returns {pb.streamReq} streamReq instance
             */
            streamReq.create = function create(properties) {
                return new streamReq(properties);
            };
    
            /**
             * Encodes the specified streamReq message. Does not implicitly {@link pb.streamReq.verify|verify} messages.
             * @function encode
             * @memberof pb.streamReq
             * @static
             * @param {pb.IstreamReq} message streamReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            streamReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectId != null && Object.hasOwnProperty.call(message, "connectId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.connectId);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seq);
                if (message.msgName != null && Object.hasOwnProperty.call(message, "msgName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgName);
                if (message.msgData != null && Object.hasOwnProperty.call(message, "msgData"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.msgData);
                return writer;
            };
    
            /**
             * Decodes a streamReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.streamReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.streamReq} streamReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            streamReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.streamReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectId = reader.int64();
                        break;
                    case 2:
                        message.seq = reader.int64();
                        break;
                    case 3:
                        message.msgName = reader.string();
                        break;
                    case 4:
                        message.msgData = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return streamReq;
        })();
    
        pb.streamRes = (function() {
    
            /**
             * Properties of a streamRes.
             * @memberof pb
             * @interface IstreamRes
             * @property {number|null} [connectId] streamRes connectId
             * @property {number|null} [seq] streamRes seq
             * @property {string|null} [msgName] streamRes msgName
             * @property {Uint8Array|null} [msgData] streamRes msgData
             */
    
            /**
             * Constructs a new streamRes.
             * @memberof pb
             * @classdesc Represents a streamRes.
             * @implements IstreamRes
             * @constructor
             * @param {pb.IstreamRes=} [properties] Properties to set
             */
            function streamRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * streamRes connectId.
             * @member {number} connectId
             * @memberof pb.streamRes
             * @instance
             */
            streamRes.prototype.connectId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * streamRes seq.
             * @member {number} seq
             * @memberof pb.streamRes
             * @instance
             */
            streamRes.prototype.seq = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * streamRes msgName.
             * @member {string} msgName
             * @memberof pb.streamRes
             * @instance
             */
            streamRes.prototype.msgName = "";
    
            /**
             * streamRes msgData.
             * @member {Uint8Array} msgData
             * @memberof pb.streamRes
             * @instance
             */
            streamRes.prototype.msgData = $util.newBuffer([]);
    
            /**
             * Creates a new streamRes instance using the specified properties.
             * @function create
             * @memberof pb.streamRes
             * @static
             * @param {pb.IstreamRes=} [properties] Properties to set
             * @returns {pb.streamRes} streamRes instance
             */
            streamRes.create = function create(properties) {
                return new streamRes(properties);
            };
    
            /**
             * Encodes the specified streamRes message. Does not implicitly {@link pb.streamRes.verify|verify} messages.
             * @function encode
             * @memberof pb.streamRes
             * @static
             * @param {pb.IstreamRes} message streamRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            streamRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.connectId != null && Object.hasOwnProperty.call(message, "connectId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.connectId);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.seq);
                if (message.msgName != null && Object.hasOwnProperty.call(message, "msgName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.msgName);
                if (message.msgData != null && Object.hasOwnProperty.call(message, "msgData"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.msgData);
                return writer;
            };
    
            /**
             * Decodes a streamRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.streamRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.streamRes} streamRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            streamRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.streamRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.connectId = reader.int64();
                        break;
                    case 2:
                        message.seq = reader.int64();
                        break;
                    case 3:
                        message.msgName = reader.string();
                        break;
                    case 4:
                        message.msgData = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return streamRes;
        })();
    
        pb.LoginRes = (function() {
    
            /**
             * Properties of a LoginRes.
             * @memberof pb
             * @interface ILoginRes
             * @property {number|null} [code] LoginRes code
             * @property {string|null} [msg] LoginRes msg
             * @property {pb.IPostData|null} [postData] LoginRes postData
             * @property {number|null} [coin] LoginRes coin
             * @property {number|null} [gameMode] LoginRes gameMode
             * @property {number|null} [serverTime] LoginRes serverTime
             * @property {number|null} [skinId] LoginRes skinId
             * @property {pb.IModuleTask|null} [task] LoginRes task
             * @property {pb.ILevelMessage|null} [levelMessage] LoginRes levelMessage
             * @property {number|null} [resultCount] LoginRes resultCount
             * @property {number|null} [successCount] LoginRes successCount
             * @property {number|null} [failCount] LoginRes failCount
             * @property {number|null} [sceneId] LoginRes sceneId
             * @property {number|null} [playedSceneAnimation] LoginRes playedSceneAnimation
             * @property {number|null} [minGhostLevel] LoginRes minGhostLevel
             */
    
            /**
             * Constructs a new LoginRes.
             * @memberof pb
             * @classdesc Represents a LoginRes.
             * @implements ILoginRes
             * @constructor
             * @param {pb.ILoginRes=} [properties] Properties to set
             */
            function LoginRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LoginRes code.
             * @member {number} code
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.code = 0;
    
            /**
             * LoginRes msg.
             * @member {string} msg
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.msg = "";
    
            /**
             * LoginRes postData.
             * @member {pb.IPostData|null|undefined} postData
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.postData = null;
    
            /**
             * LoginRes coin.
             * @member {number} coin
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * LoginRes gameMode.
             * @member {number} gameMode
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.gameMode = 0;
    
            /**
             * LoginRes serverTime.
             * @member {number} serverTime
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * LoginRes skinId.
             * @member {number} skinId
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.skinId = 0;
    
            /**
             * LoginRes task.
             * @member {pb.IModuleTask|null|undefined} task
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.task = null;
    
            /**
             * LoginRes levelMessage.
             * @member {pb.ILevelMessage|null|undefined} levelMessage
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.levelMessage = null;
    
            /**
             * LoginRes resultCount.
             * @member {number} resultCount
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.resultCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * LoginRes successCount.
             * @member {number} successCount
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.successCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * LoginRes failCount.
             * @member {number} failCount
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.failCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * LoginRes sceneId.
             * @member {number} sceneId
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.sceneId = 0;
    
            /**
             * LoginRes playedSceneAnimation.
             * @member {number} playedSceneAnimation
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.playedSceneAnimation = 0;
    
            /**
             * LoginRes minGhostLevel.
             * @member {number} minGhostLevel
             * @memberof pb.LoginRes
             * @instance
             */
            LoginRes.prototype.minGhostLevel = 0;
    
            /**
             * Creates a new LoginRes instance using the specified properties.
             * @function create
             * @memberof pb.LoginRes
             * @static
             * @param {pb.ILoginRes=} [properties] Properties to set
             * @returns {pb.LoginRes} LoginRes instance
             */
            LoginRes.create = function create(properties) {
                return new LoginRes(properties);
            };
    
            /**
             * Encodes the specified LoginRes message. Does not implicitly {@link pb.LoginRes.verify|verify} messages.
             * @function encode
             * @memberof pb.LoginRes
             * @static
             * @param {pb.ILoginRes} message LoginRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoginRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.postData != null && Object.hasOwnProperty.call(message, "postData"))
                    $root.pb.PostData.encode(message.postData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.coin);
                if (message.task != null && Object.hasOwnProperty.call(message, "task"))
                    $root.pb.ModuleTask.encode(message.task, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.gameMode);
                if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.serverTime);
                if (message.skinId != null && Object.hasOwnProperty.call(message, "skinId"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.skinId);
                if (message.levelMessage != null && Object.hasOwnProperty.call(message, "levelMessage"))
                    $root.pb.LevelMessage.encode(message.levelMessage, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.resultCount != null && Object.hasOwnProperty.call(message, "resultCount"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int64(message.resultCount);
                if (message.successCount != null && Object.hasOwnProperty.call(message, "successCount"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int64(message.successCount);
                if (message.failCount != null && Object.hasOwnProperty.call(message, "failCount"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.failCount);
                if (message.sceneId != null && Object.hasOwnProperty.call(message, "sceneId"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.sceneId);
                if (message.playedSceneAnimation != null && Object.hasOwnProperty.call(message, "playedSceneAnimation"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int32(message.playedSceneAnimation);
                if (message.minGhostLevel != null && Object.hasOwnProperty.call(message, "minGhostLevel"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int32(message.minGhostLevel);
                return writer;
            };
    
            /**
             * Decodes a LoginRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.LoginRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.LoginRes} LoginRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoginRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoginRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.postData = $root.pb.PostData.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.coin = reader.int64();
                        break;
                    case 8:
                        message.gameMode = reader.int32();
                        break;
                    case 9:
                        message.serverTime = reader.int64();
                        break;
                    case 10:
                        message.skinId = reader.int32();
                        break;
                    case 7:
                        message.task = $root.pb.ModuleTask.decode(reader, reader.uint32());
                        break;
                    case 11:
                        message.levelMessage = $root.pb.LevelMessage.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.resultCount = reader.int64();
                        break;
                    case 13:
                        message.successCount = reader.int64();
                        break;
                    case 14:
                        message.failCount = reader.int64();
                        break;
                    case 15:
                        message.sceneId = reader.int32();
                        break;
                    case 16:
                        message.playedSceneAnimation = reader.int32();
                        break;
                    case 17:
                        message.minGhostLevel = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return LoginRes;
        })();
    
        pb.LevelMessage = (function() {
    
            /**
             * Properties of a LevelMessage.
             * @memberof pb
             * @interface ILevelMessage
             * @property {number|null} [level] LevelMessage level
             * @property {number|null} [exp] LevelMessage exp
             * @property {number|null} [maxExp] LevelMessage maxExp
             */
    
            /**
             * Constructs a new LevelMessage.
             * @memberof pb
             * @classdesc Represents a LevelMessage.
             * @implements ILevelMessage
             * @constructor
             * @param {pb.ILevelMessage=} [properties] Properties to set
             */
            function LevelMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LevelMessage level.
             * @member {number} level
             * @memberof pb.LevelMessage
             * @instance
             */
            LevelMessage.prototype.level = 0;
    
            /**
             * LevelMessage exp.
             * @member {number} exp
             * @memberof pb.LevelMessage
             * @instance
             */
            LevelMessage.prototype.exp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * LevelMessage maxExp.
             * @member {number} maxExp
             * @memberof pb.LevelMessage
             * @instance
             */
            LevelMessage.prototype.maxExp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new LevelMessage instance using the specified properties.
             * @function create
             * @memberof pb.LevelMessage
             * @static
             * @param {pb.ILevelMessage=} [properties] Properties to set
             * @returns {pb.LevelMessage} LevelMessage instance
             */
            LevelMessage.create = function create(properties) {
                return new LevelMessage(properties);
            };
    
            /**
             * Encodes the specified LevelMessage message. Does not implicitly {@link pb.LevelMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.LevelMessage
             * @static
             * @param {pb.ILevelMessage} message LevelMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LevelMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.level);
                if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.exp);
                if (message.maxExp != null && Object.hasOwnProperty.call(message, "maxExp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.maxExp);
                return writer;
            };
    
            /**
             * Decodes a LevelMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.LevelMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.LevelMessage} LevelMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LevelMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.level = reader.int32();
                        break;
                    case 2:
                        message.exp = reader.int64();
                        break;
                    case 3:
                        message.maxExp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return LevelMessage;
        })();
    
        pb.PostData = (function() {
    
            /**
             * Properties of a PostData.
             * @memberof pb
             * @interface IPostData
             * @property {string|null} [channel] PostData channel
             * @property {string|null} [gameid] PostData gameid
             * @property {string|null} [roomid] PostData roomid
             * @property {pb.IPlayer|null} [player] PostData player
             */
    
            /**
             * Constructs a new PostData.
             * @memberof pb
             * @classdesc Represents a PostData.
             * @implements IPostData
             * @constructor
             * @param {pb.IPostData=} [properties] Properties to set
             */
            function PostData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PostData channel.
             * @member {string} channel
             * @memberof pb.PostData
             * @instance
             */
            PostData.prototype.channel = "";
    
            /**
             * PostData gameid.
             * @member {string} gameid
             * @memberof pb.PostData
             * @instance
             */
            PostData.prototype.gameid = "";
    
            /**
             * PostData roomid.
             * @member {string} roomid
             * @memberof pb.PostData
             * @instance
             */
            PostData.prototype.roomid = "";
    
            /**
             * PostData player.
             * @member {pb.IPlayer|null|undefined} player
             * @memberof pb.PostData
             * @instance
             */
            PostData.prototype.player = null;
    
            /**
             * Creates a new PostData instance using the specified properties.
             * @function create
             * @memberof pb.PostData
             * @static
             * @param {pb.IPostData=} [properties] Properties to set
             * @returns {pb.PostData} PostData instance
             */
            PostData.create = function create(properties) {
                return new PostData(properties);
            };
    
            /**
             * Encodes the specified PostData message. Does not implicitly {@link pb.PostData.verify|verify} messages.
             * @function encode
             * @memberof pb.PostData
             * @static
             * @param {pb.IPostData} message PostData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PostData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channel != null && Object.hasOwnProperty.call(message, "channel"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.channel);
                if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameid);
                if (message.roomid != null && Object.hasOwnProperty.call(message, "roomid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.roomid);
                if (message.player != null && Object.hasOwnProperty.call(message, "player"))
                    $root.pb.Player.encode(message.player, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a PostData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PostData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PostData} PostData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PostData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PostData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.channel = reader.string();
                        break;
                    case 2:
                        message.gameid = reader.string();
                        break;
                    case 3:
                        message.roomid = reader.string();
                        break;
                    case 4:
                        message.player = $root.pb.Player.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PostData;
        })();
    
        pb.Player = (function() {
    
            /**
             * Properties of a Player.
             * @memberof pb
             * @interface IPlayer
             * @property {string|null} [uid] Player uid
             * @property {string|null} [name] Player name
             * @property {string|null} [avatarurl] Player avatarurl
             * @property {string|null} [teamid] Player teamid
             * @property {string|null} [opt] Player opt
             * @property {number|null} [sex] Player sex
             * @property {boolean|null} [ready] Player ready
             */
    
            /**
             * Constructs a new Player.
             * @memberof pb
             * @classdesc Represents a Player.
             * @implements IPlayer
             * @constructor
             * @param {pb.IPlayer=} [properties] Properties to set
             */
            function Player(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Player uid.
             * @member {string} uid
             * @memberof pb.Player
             * @instance
             */
            Player.prototype.uid = "";
    
            /**
             * Player name.
             * @member {string} name
             * @memberof pb.Player
             * @instance
             */
            Player.prototype.name = "";
    
            /**
             * Player avatarurl.
             * @member {string} avatarurl
             * @memberof pb.Player
             * @instance
             */
            Player.prototype.avatarurl = "";
    
            /**
             * Player teamid.
             * @member {string} teamid
             * @memberof pb.Player
             * @instance
             */
            Player.prototype.teamid = "";
    
            /**
             * Player opt.
             * @member {string} opt
             * @memberof pb.Player
             * @instance
             */
            Player.prototype.opt = "";
    
            /**
             * Player sex.
             * @member {number} sex
             * @memberof pb.Player
             * @instance
             */
            Player.prototype.sex = 0;
    
            /**
             * Player ready.
             * @member {boolean} ready
             * @memberof pb.Player
             * @instance
             */
            Player.prototype.ready = false;
    
            /**
             * Creates a new Player instance using the specified properties.
             * @function create
             * @memberof pb.Player
             * @static
             * @param {pb.IPlayer=} [properties] Properties to set
             * @returns {pb.Player} Player instance
             */
            Player.create = function create(properties) {
                return new Player(properties);
            };
    
            /**
             * Encodes the specified Player message. Does not implicitly {@link pb.Player.verify|verify} messages.
             * @function encode
             * @memberof pb.Player
             * @static
             * @param {pb.IPlayer} message Player message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Player.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.avatarurl != null && Object.hasOwnProperty.call(message, "avatarurl"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarurl);
                if (message.teamid != null && Object.hasOwnProperty.call(message, "teamid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.teamid);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.opt);
                if (message.sex != null && Object.hasOwnProperty.call(message, "sex"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.sex);
                if (message.ready != null && Object.hasOwnProperty.call(message, "ready"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.ready);
                return writer;
            };
    
            /**
             * Decodes a Player message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Player
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Player} Player
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Player.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Player();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.avatarurl = reader.string();
                        break;
                    case 4:
                        message.teamid = reader.string();
                        break;
                    case 5:
                        message.opt = reader.string();
                        break;
                    case 6:
                        message.sex = reader.int32();
                        break;
                    case 7:
                        message.ready = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Player;
        })();
    
        pb.UserLoginRes = (function() {
    
            /**
             * Properties of a UserLoginRes.
             * @memberof pb
             * @interface IUserLoginRes
             * @property {number|null} [code] UserLoginRes code
             * @property {string|null} [msg] UserLoginRes msg
             * @property {Array.<pb.IPlayer>|null} [data] UserLoginRes data
             */
    
            /**
             * Constructs a new UserLoginRes.
             * @memberof pb
             * @classdesc Represents a UserLoginRes.
             * @implements IUserLoginRes
             * @constructor
             * @param {pb.IUserLoginRes=} [properties] Properties to set
             */
            function UserLoginRes(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UserLoginRes code.
             * @member {number} code
             * @memberof pb.UserLoginRes
             * @instance
             */
            UserLoginRes.prototype.code = 0;
    
            /**
             * UserLoginRes msg.
             * @member {string} msg
             * @memberof pb.UserLoginRes
             * @instance
             */
            UserLoginRes.prototype.msg = "";
    
            /**
             * UserLoginRes data.
             * @member {Array.<pb.IPlayer>} data
             * @memberof pb.UserLoginRes
             * @instance
             */
            UserLoginRes.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new UserLoginRes instance using the specified properties.
             * @function create
             * @memberof pb.UserLoginRes
             * @static
             * @param {pb.IUserLoginRes=} [properties] Properties to set
             * @returns {pb.UserLoginRes} UserLoginRes instance
             */
            UserLoginRes.create = function create(properties) {
                return new UserLoginRes(properties);
            };
    
            /**
             * Encodes the specified UserLoginRes message. Does not implicitly {@link pb.UserLoginRes.verify|verify} messages.
             * @function encode
             * @memberof pb.UserLoginRes
             * @static
             * @param {pb.IUserLoginRes} message UserLoginRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserLoginRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        $root.pb.Player.encode(message.data[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a UserLoginRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.UserLoginRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.UserLoginRes} UserLoginRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserLoginRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UserLoginRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        message.data.push($root.pb.Player.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return UserLoginRes;
        })();
    
        pb.LoadProgressReq = (function() {
    
            /**
             * Properties of a LoadProgressReq.
             * @memberof pb
             * @interface ILoadProgressReq
             * @property {number|null} [progress] LoadProgressReq progress
             */
    
            /**
             * Constructs a new LoadProgressReq.
             * @memberof pb
             * @classdesc Represents a LoadProgressReq.
             * @implements ILoadProgressReq
             * @constructor
             * @param {pb.ILoadProgressReq=} [properties] Properties to set
             */
            function LoadProgressReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LoadProgressReq progress.
             * @member {number} progress
             * @memberof pb.LoadProgressReq
             * @instance
             */
            LoadProgressReq.prototype.progress = 0;
    
            /**
             * Creates a new LoadProgressReq instance using the specified properties.
             * @function create
             * @memberof pb.LoadProgressReq
             * @static
             * @param {pb.ILoadProgressReq=} [properties] Properties to set
             * @returns {pb.LoadProgressReq} LoadProgressReq instance
             */
            LoadProgressReq.create = function create(properties) {
                return new LoadProgressReq(properties);
            };
    
            /**
             * Encodes the specified LoadProgressReq message. Does not implicitly {@link pb.LoadProgressReq.verify|verify} messages.
             * @function encode
             * @memberof pb.LoadProgressReq
             * @static
             * @param {pb.ILoadProgressReq} message LoadProgressReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadProgressReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.progress);
                return writer;
            };
    
            /**
             * Decodes a LoadProgressReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.LoadProgressReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.LoadProgressReq} LoadProgressReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadProgressReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoadProgressReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.progress = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return LoadProgressReq;
        })();
    
        pb.LoadProgressRes = (function() {
    
            /**
             * Properties of a LoadProgressRes.
             * @memberof pb
             * @interface ILoadProgressRes
             * @property {number|null} [code] LoadProgressRes code
             * @property {string|null} [msg] LoadProgressRes msg
             * @property {Array.<pb.ILoadProgressResData>|null} [data] LoadProgressRes data
             */
    
            /**
             * Constructs a new LoadProgressRes.
             * @memberof pb
             * @classdesc Represents a LoadProgressRes.
             * @implements ILoadProgressRes
             * @constructor
             * @param {pb.ILoadProgressRes=} [properties] Properties to set
             */
            function LoadProgressRes(properties) {
                this.data = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LoadProgressRes code.
             * @member {number} code
             * @memberof pb.LoadProgressRes
             * @instance
             */
            LoadProgressRes.prototype.code = 0;
    
            /**
             * LoadProgressRes msg.
             * @member {string} msg
             * @memberof pb.LoadProgressRes
             * @instance
             */
            LoadProgressRes.prototype.msg = "";
    
            /**
             * LoadProgressRes data.
             * @member {Array.<pb.ILoadProgressResData>} data
             * @memberof pb.LoadProgressRes
             * @instance
             */
            LoadProgressRes.prototype.data = $util.emptyArray;
    
            /**
             * Creates a new LoadProgressRes instance using the specified properties.
             * @function create
             * @memberof pb.LoadProgressRes
             * @static
             * @param {pb.ILoadProgressRes=} [properties] Properties to set
             * @returns {pb.LoadProgressRes} LoadProgressRes instance
             */
            LoadProgressRes.create = function create(properties) {
                return new LoadProgressRes(properties);
            };
    
            /**
             * Encodes the specified LoadProgressRes message. Does not implicitly {@link pb.LoadProgressRes.verify|verify} messages.
             * @function encode
             * @memberof pb.LoadProgressRes
             * @static
             * @param {pb.ILoadProgressRes} message LoadProgressRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadProgressRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && message.data.length)
                    for (var i = 0; i < message.data.length; ++i)
                        $root.pb.LoadProgressResData.encode(message.data[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a LoadProgressRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.LoadProgressRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.LoadProgressRes} LoadProgressRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadProgressRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoadProgressRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        if (!(message.data && message.data.length))
                            message.data = [];
                        message.data.push($root.pb.LoadProgressResData.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return LoadProgressRes;
        })();
    
        pb.LoadProgressResData = (function() {
    
            /**
             * Properties of a LoadProgressResData.
             * @memberof pb
             * @interface ILoadProgressResData
             * @property {string|null} [uid] LoadProgressResData uid
             * @property {number|null} [progress] LoadProgressResData progress
             */
    
            /**
             * Constructs a new LoadProgressResData.
             * @memberof pb
             * @classdesc Represents a LoadProgressResData.
             * @implements ILoadProgressResData
             * @constructor
             * @param {pb.ILoadProgressResData=} [properties] Properties to set
             */
            function LoadProgressResData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * LoadProgressResData uid.
             * @member {string} uid
             * @memberof pb.LoadProgressResData
             * @instance
             */
            LoadProgressResData.prototype.uid = "";
    
            /**
             * LoadProgressResData progress.
             * @member {number} progress
             * @memberof pb.LoadProgressResData
             * @instance
             */
            LoadProgressResData.prototype.progress = 0;
    
            /**
             * Creates a new LoadProgressResData instance using the specified properties.
             * @function create
             * @memberof pb.LoadProgressResData
             * @static
             * @param {pb.ILoadProgressResData=} [properties] Properties to set
             * @returns {pb.LoadProgressResData} LoadProgressResData instance
             */
            LoadProgressResData.create = function create(properties) {
                return new LoadProgressResData(properties);
            };
    
            /**
             * Encodes the specified LoadProgressResData message. Does not implicitly {@link pb.LoadProgressResData.verify|verify} messages.
             * @function encode
             * @memberof pb.LoadProgressResData
             * @static
             * @param {pb.ILoadProgressResData} message LoadProgressResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LoadProgressResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.progress != null && Object.hasOwnProperty.call(message, "progress"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.progress);
                return writer;
            };
    
            /**
             * Decodes a LoadProgressResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.LoadProgressResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.LoadProgressResData} LoadProgressResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LoadProgressResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoadProgressResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.progress = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return LoadProgressResData;
        })();
    
        pb.ReadyReq = (function() {
    
            /**
             * Properties of a ReadyReq.
             * @memberof pb
             * @interface IReadyReq
             * @property {boolean|null} [ready] ReadyReq ready
             */
    
            /**
             * Constructs a new ReadyReq.
             * @memberof pb
             * @classdesc Represents a ReadyReq.
             * @implements IReadyReq
             * @constructor
             * @param {pb.IReadyReq=} [properties] Properties to set
             */
            function ReadyReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReadyReq ready.
             * @member {boolean} ready
             * @memberof pb.ReadyReq
             * @instance
             */
            ReadyReq.prototype.ready = false;
    
            /**
             * Creates a new ReadyReq instance using the specified properties.
             * @function create
             * @memberof pb.ReadyReq
             * @static
             * @param {pb.IReadyReq=} [properties] Properties to set
             * @returns {pb.ReadyReq} ReadyReq instance
             */
            ReadyReq.create = function create(properties) {
                return new ReadyReq(properties);
            };
    
            /**
             * Encodes the specified ReadyReq message. Does not implicitly {@link pb.ReadyReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ReadyReq
             * @static
             * @param {pb.IReadyReq} message ReadyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadyReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ready != null && Object.hasOwnProperty.call(message, "ready"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.ready);
                return writer;
            };
    
            /**
             * Decodes a ReadyReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReadyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReadyReq} ReadyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadyReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReadyReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ready = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReadyReq;
        })();
    
        pb.ReadyRes = (function() {
    
            /**
             * Properties of a ReadyRes.
             * @memberof pb
             * @interface IReadyRes
             * @property {number|null} [code] ReadyRes code
             * @property {string|null} [msg] ReadyRes msg
             * @property {pb.IReadyResData|null} [data] ReadyRes data
             */
    
            /**
             * Constructs a new ReadyRes.
             * @memberof pb
             * @classdesc Represents a ReadyRes.
             * @implements IReadyRes
             * @constructor
             * @param {pb.IReadyRes=} [properties] Properties to set
             */
            function ReadyRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReadyRes code.
             * @member {number} code
             * @memberof pb.ReadyRes
             * @instance
             */
            ReadyRes.prototype.code = 0;
    
            /**
             * ReadyRes msg.
             * @member {string} msg
             * @memberof pb.ReadyRes
             * @instance
             */
            ReadyRes.prototype.msg = "";
    
            /**
             * ReadyRes data.
             * @member {pb.IReadyResData|null|undefined} data
             * @memberof pb.ReadyRes
             * @instance
             */
            ReadyRes.prototype.data = null;
    
            /**
             * Creates a new ReadyRes instance using the specified properties.
             * @function create
             * @memberof pb.ReadyRes
             * @static
             * @param {pb.IReadyRes=} [properties] Properties to set
             * @returns {pb.ReadyRes} ReadyRes instance
             */
            ReadyRes.create = function create(properties) {
                return new ReadyRes(properties);
            };
    
            /**
             * Encodes the specified ReadyRes message. Does not implicitly {@link pb.ReadyRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ReadyRes
             * @static
             * @param {pb.IReadyRes} message ReadyRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadyRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.ReadyResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a ReadyRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReadyRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReadyRes} ReadyRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadyRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReadyRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.ReadyResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReadyRes;
        })();
    
        pb.ReadyResData = (function() {
    
            /**
             * Properties of a ReadyResData.
             * @memberof pb
             * @interface IReadyResData
             * @property {Array.<string>|null} [uids] ReadyResData uids
             */
    
            /**
             * Constructs a new ReadyResData.
             * @memberof pb
             * @classdesc Represents a ReadyResData.
             * @implements IReadyResData
             * @constructor
             * @param {pb.IReadyResData=} [properties] Properties to set
             */
            function ReadyResData(properties) {
                this.uids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReadyResData uids.
             * @member {Array.<string>} uids
             * @memberof pb.ReadyResData
             * @instance
             */
            ReadyResData.prototype.uids = $util.emptyArray;
    
            /**
             * Creates a new ReadyResData instance using the specified properties.
             * @function create
             * @memberof pb.ReadyResData
             * @static
             * @param {pb.IReadyResData=} [properties] Properties to set
             * @returns {pb.ReadyResData} ReadyResData instance
             */
            ReadyResData.create = function create(properties) {
                return new ReadyResData(properties);
            };
    
            /**
             * Encodes the specified ReadyResData message. Does not implicitly {@link pb.ReadyResData.verify|verify} messages.
             * @function encode
             * @memberof pb.ReadyResData
             * @static
             * @param {pb.IReadyResData} message ReadyResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadyResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uids != null && message.uids.length)
                    for (var i = 0; i < message.uids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.uids[i]);
                return writer;
            };
    
            /**
             * Decodes a ReadyResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReadyResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReadyResData} ReadyResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadyResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReadyResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.uids && message.uids.length))
                            message.uids = [];
                        message.uids.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReadyResData;
        })();
    
        pb.UnvarnishedReq = (function() {
    
            /**
             * Properties of an UnvarnishedReq.
             * @memberof pb
             * @interface IUnvarnishedReq
             * @property {Uint8Array|null} [data] UnvarnishedReq data
             */
    
            /**
             * Constructs a new UnvarnishedReq.
             * @memberof pb
             * @classdesc Represents an UnvarnishedReq.
             * @implements IUnvarnishedReq
             * @constructor
             * @param {pb.IUnvarnishedReq=} [properties] Properties to set
             */
            function UnvarnishedReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UnvarnishedReq data.
             * @member {Uint8Array} data
             * @memberof pb.UnvarnishedReq
             * @instance
             */
            UnvarnishedReq.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new UnvarnishedReq instance using the specified properties.
             * @function create
             * @memberof pb.UnvarnishedReq
             * @static
             * @param {pb.IUnvarnishedReq=} [properties] Properties to set
             * @returns {pb.UnvarnishedReq} UnvarnishedReq instance
             */
            UnvarnishedReq.create = function create(properties) {
                return new UnvarnishedReq(properties);
            };
    
            /**
             * Encodes the specified UnvarnishedReq message. Does not implicitly {@link pb.UnvarnishedReq.verify|verify} messages.
             * @function encode
             * @memberof pb.UnvarnishedReq
             * @static
             * @param {pb.IUnvarnishedReq} message UnvarnishedReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnvarnishedReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                return writer;
            };
    
            /**
             * Decodes an UnvarnishedReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.UnvarnishedReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.UnvarnishedReq} UnvarnishedReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnvarnishedReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UnvarnishedReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return UnvarnishedReq;
        })();
    
        pb.UnvarnishedRes = (function() {
    
            /**
             * Properties of an UnvarnishedRes.
             * @memberof pb
             * @interface IUnvarnishedRes
             * @property {number|null} [code] UnvarnishedRes code
             * @property {string|null} [msg] UnvarnishedRes msg
             * @property {Uint8Array|null} [data] UnvarnishedRes data
             */
    
            /**
             * Constructs a new UnvarnishedRes.
             * @memberof pb
             * @classdesc Represents an UnvarnishedRes.
             * @implements IUnvarnishedRes
             * @constructor
             * @param {pb.IUnvarnishedRes=} [properties] Properties to set
             */
            function UnvarnishedRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UnvarnishedRes code.
             * @member {number} code
             * @memberof pb.UnvarnishedRes
             * @instance
             */
            UnvarnishedRes.prototype.code = 0;
    
            /**
             * UnvarnishedRes msg.
             * @member {string} msg
             * @memberof pb.UnvarnishedRes
             * @instance
             */
            UnvarnishedRes.prototype.msg = "";
    
            /**
             * UnvarnishedRes data.
             * @member {Uint8Array} data
             * @memberof pb.UnvarnishedRes
             * @instance
             */
            UnvarnishedRes.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new UnvarnishedRes instance using the specified properties.
             * @function create
             * @memberof pb.UnvarnishedRes
             * @static
             * @param {pb.IUnvarnishedRes=} [properties] Properties to set
             * @returns {pb.UnvarnishedRes} UnvarnishedRes instance
             */
            UnvarnishedRes.create = function create(properties) {
                return new UnvarnishedRes(properties);
            };
    
            /**
             * Encodes the specified UnvarnishedRes message. Does not implicitly {@link pb.UnvarnishedRes.verify|verify} messages.
             * @function encode
             * @memberof pb.UnvarnishedRes
             * @static
             * @param {pb.IUnvarnishedRes} message UnvarnishedRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UnvarnishedRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                return writer;
            };
    
            /**
             * Decodes an UnvarnishedRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.UnvarnishedRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.UnvarnishedRes} UnvarnishedRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UnvarnishedRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UnvarnishedRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return UnvarnishedRes;
        })();
    
        pb.HeartReq = (function() {
    
            /**
             * Properties of a HeartReq.
             * @memberof pb
             * @interface IHeartReq
             * @property {number|null} [reqTimestamp] HeartReq reqTimestamp
             */
    
            /**
             * Constructs a new HeartReq.
             * @memberof pb
             * @classdesc Represents a HeartReq.
             * @implements IHeartReq
             * @constructor
             * @param {pb.IHeartReq=} [properties] Properties to set
             */
            function HeartReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * HeartReq reqTimestamp.
             * @member {number} reqTimestamp
             * @memberof pb.HeartReq
             * @instance
             */
            HeartReq.prototype.reqTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new HeartReq instance using the specified properties.
             * @function create
             * @memberof pb.HeartReq
             * @static
             * @param {pb.IHeartReq=} [properties] Properties to set
             * @returns {pb.HeartReq} HeartReq instance
             */
            HeartReq.create = function create(properties) {
                return new HeartReq(properties);
            };
    
            /**
             * Encodes the specified HeartReq message. Does not implicitly {@link pb.HeartReq.verify|verify} messages.
             * @function encode
             * @memberof pb.HeartReq
             * @static
             * @param {pb.IHeartReq} message HeartReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reqTimestamp != null && Object.hasOwnProperty.call(message, "reqTimestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.reqTimestamp);
                return writer;
            };
    
            /**
             * Decodes a HeartReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.HeartReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.HeartReq} HeartReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HeartReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.reqTimestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return HeartReq;
        })();
    
        pb.HeartRes = (function() {
    
            /**
             * Properties of a HeartRes.
             * @memberof pb
             * @interface IHeartRes
             * @property {number|null} [timestamp] HeartRes timestamp
             * @property {number|null} [reqTimestamp] HeartRes reqTimestamp
             */
    
            /**
             * Constructs a new HeartRes.
             * @memberof pb
             * @classdesc Represents a HeartRes.
             * @implements IHeartRes
             * @constructor
             * @param {pb.IHeartRes=} [properties] Properties to set
             */
            function HeartRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * HeartRes timestamp.
             * @member {number} timestamp
             * @memberof pb.HeartRes
             * @instance
             */
            HeartRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * HeartRes reqTimestamp.
             * @member {number} reqTimestamp
             * @memberof pb.HeartRes
             * @instance
             */
            HeartRes.prototype.reqTimestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new HeartRes instance using the specified properties.
             * @function create
             * @memberof pb.HeartRes
             * @static
             * @param {pb.IHeartRes=} [properties] Properties to set
             * @returns {pb.HeartRes} HeartRes instance
             */
            HeartRes.create = function create(properties) {
                return new HeartRes(properties);
            };
    
            /**
             * Encodes the specified HeartRes message. Does not implicitly {@link pb.HeartRes.verify|verify} messages.
             * @function encode
             * @memberof pb.HeartRes
             * @static
             * @param {pb.IHeartRes} message HeartRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.timestamp);
                if (message.reqTimestamp != null && Object.hasOwnProperty.call(message, "reqTimestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.reqTimestamp);
                return writer;
            };
    
            /**
             * Decodes a HeartRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.HeartRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.HeartRes} HeartRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HeartRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.int64();
                        break;
                    case 2:
                        message.reqTimestamp = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return HeartRes;
        })();
    
        pb.GiveUpReq = (function() {
    
            /**
             * Properties of a GiveUpReq.
             * @memberof pb
             * @interface IGiveUpReq
             */
    
            /**
             * Constructs a new GiveUpReq.
             * @memberof pb
             * @classdesc Represents a GiveUpReq.
             * @implements IGiveUpReq
             * @constructor
             * @param {pb.IGiveUpReq=} [properties] Properties to set
             */
            function GiveUpReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GiveUpReq instance using the specified properties.
             * @function create
             * @memberof pb.GiveUpReq
             * @static
             * @param {pb.IGiveUpReq=} [properties] Properties to set
             * @returns {pb.GiveUpReq} GiveUpReq instance
             */
            GiveUpReq.create = function create(properties) {
                return new GiveUpReq(properties);
            };
    
            /**
             * Encodes the specified GiveUpReq message. Does not implicitly {@link pb.GiveUpReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GiveUpReq
             * @static
             * @param {pb.IGiveUpReq} message GiveUpReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiveUpReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GiveUpReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GiveUpReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GiveUpReq} GiveUpReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiveUpReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GiveUpReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GiveUpReq;
        })();
    
        pb.GiveUpRes = (function() {
    
            /**
             * Properties of a GiveUpRes.
             * @memberof pb
             * @interface IGiveUpRes
             * @property {number|null} [code] GiveUpRes code
             * @property {string|null} [msg] GiveUpRes msg
             * @property {pb.IGiveUpResData|null} [data] GiveUpRes data
             */
    
            /**
             * Constructs a new GiveUpRes.
             * @memberof pb
             * @classdesc Represents a GiveUpRes.
             * @implements IGiveUpRes
             * @constructor
             * @param {pb.IGiveUpRes=} [properties] Properties to set
             */
            function GiveUpRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GiveUpRes code.
             * @member {number} code
             * @memberof pb.GiveUpRes
             * @instance
             */
            GiveUpRes.prototype.code = 0;
    
            /**
             * GiveUpRes msg.
             * @member {string} msg
             * @memberof pb.GiveUpRes
             * @instance
             */
            GiveUpRes.prototype.msg = "";
    
            /**
             * GiveUpRes data.
             * @member {pb.IGiveUpResData|null|undefined} data
             * @memberof pb.GiveUpRes
             * @instance
             */
            GiveUpRes.prototype.data = null;
    
            /**
             * Creates a new GiveUpRes instance using the specified properties.
             * @function create
             * @memberof pb.GiveUpRes
             * @static
             * @param {pb.IGiveUpRes=} [properties] Properties to set
             * @returns {pb.GiveUpRes} GiveUpRes instance
             */
            GiveUpRes.create = function create(properties) {
                return new GiveUpRes(properties);
            };
    
            /**
             * Encodes the specified GiveUpRes message. Does not implicitly {@link pb.GiveUpRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GiveUpRes
             * @static
             * @param {pb.IGiveUpRes} message GiveUpRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiveUpRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.GiveUpResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GiveUpRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GiveUpRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GiveUpRes} GiveUpRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiveUpRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GiveUpRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.GiveUpResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GiveUpRes;
        })();
    
        pb.ForceExitReq = (function() {
    
            /**
             * Properties of a ForceExitReq.
             * @memberof pb
             * @interface IForceExitReq
             */
    
            /**
             * Constructs a new ForceExitReq.
             * @memberof pb
             * @classdesc Represents a ForceExitReq.
             * @implements IForceExitReq
             * @constructor
             * @param {pb.IForceExitReq=} [properties] Properties to set
             */
            function ForceExitReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ForceExitReq instance using the specified properties.
             * @function create
             * @memberof pb.ForceExitReq
             * @static
             * @param {pb.IForceExitReq=} [properties] Properties to set
             * @returns {pb.ForceExitReq} ForceExitReq instance
             */
            ForceExitReq.create = function create(properties) {
                return new ForceExitReq(properties);
            };
    
            /**
             * Encodes the specified ForceExitReq message. Does not implicitly {@link pb.ForceExitReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ForceExitReq
             * @static
             * @param {pb.IForceExitReq} message ForceExitReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceExitReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a ForceExitReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ForceExitReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ForceExitReq} ForceExitReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceExitReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ForceExitReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ForceExitReq;
        })();
    
        pb.ForceExitRes = (function() {
    
            /**
             * Properties of a ForceExitRes.
             * @memberof pb
             * @interface IForceExitRes
             * @property {number|null} [code] ForceExitRes code
             * @property {string|null} [msg] ForceExitRes msg
             * @property {pb.IGiveUpResData|null} [data] ForceExitRes data
             */
    
            /**
             * Constructs a new ForceExitRes.
             * @memberof pb
             * @classdesc Represents a ForceExitRes.
             * @implements IForceExitRes
             * @constructor
             * @param {pb.IForceExitRes=} [properties] Properties to set
             */
            function ForceExitRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ForceExitRes code.
             * @member {number} code
             * @memberof pb.ForceExitRes
             * @instance
             */
            ForceExitRes.prototype.code = 0;
    
            /**
             * ForceExitRes msg.
             * @member {string} msg
             * @memberof pb.ForceExitRes
             * @instance
             */
            ForceExitRes.prototype.msg = "";
    
            /**
             * ForceExitRes data.
             * @member {pb.IGiveUpResData|null|undefined} data
             * @memberof pb.ForceExitRes
             * @instance
             */
            ForceExitRes.prototype.data = null;
    
            /**
             * Creates a new ForceExitRes instance using the specified properties.
             * @function create
             * @memberof pb.ForceExitRes
             * @static
             * @param {pb.IForceExitRes=} [properties] Properties to set
             * @returns {pb.ForceExitRes} ForceExitRes instance
             */
            ForceExitRes.create = function create(properties) {
                return new ForceExitRes(properties);
            };
    
            /**
             * Encodes the specified ForceExitRes message. Does not implicitly {@link pb.ForceExitRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ForceExitRes
             * @static
             * @param {pb.IForceExitRes} message ForceExitRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForceExitRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.GiveUpResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a ForceExitRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ForceExitRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ForceExitRes} ForceExitRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForceExitRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ForceExitRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.GiveUpResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ForceExitRes;
        })();
    
        pb.GiveUpResData = (function() {
    
            /**
             * Properties of a GiveUpResData.
             * @memberof pb
             * @interface IGiveUpResData
             * @property {string|null} [uid] GiveUpResData uid
             * @property {Array.<pb.IGiveUpUserMessage>|null} [uids] GiveUpResData uids
             * @property {number|null} [grade] GiveUpResData grade
             * @property {number|null} [gameType] GiveUpResData gameType
             * @property {number|null} [leftCoin] GiveUpResData leftCoin
             * @property {pb.IUserData|null} [userData] GiveUpResData userData
             */
    
            /**
             * Constructs a new GiveUpResData.
             * @memberof pb
             * @classdesc Represents a GiveUpResData.
             * @implements IGiveUpResData
             * @constructor
             * @param {pb.IGiveUpResData=} [properties] Properties to set
             */
            function GiveUpResData(properties) {
                this.uids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GiveUpResData uid.
             * @member {string} uid
             * @memberof pb.GiveUpResData
             * @instance
             */
            GiveUpResData.prototype.uid = "";
    
            /**
             * GiveUpResData uids.
             * @member {Array.<pb.IGiveUpUserMessage>} uids
             * @memberof pb.GiveUpResData
             * @instance
             */
            GiveUpResData.prototype.uids = $util.emptyArray;
    
            /**
             * GiveUpResData grade.
             * @member {number} grade
             * @memberof pb.GiveUpResData
             * @instance
             */
            GiveUpResData.prototype.grade = 0;
    
            /**
             * GiveUpResData gameType.
             * @member {number} gameType
             * @memberof pb.GiveUpResData
             * @instance
             */
            GiveUpResData.prototype.gameType = 0;
    
            /**
             * GiveUpResData leftCoin.
             * @member {number} leftCoin
             * @memberof pb.GiveUpResData
             * @instance
             */
            GiveUpResData.prototype.leftCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GiveUpResData userData.
             * @member {pb.IUserData|null|undefined} userData
             * @memberof pb.GiveUpResData
             * @instance
             */
            GiveUpResData.prototype.userData = null;
    
            /**
             * Creates a new GiveUpResData instance using the specified properties.
             * @function create
             * @memberof pb.GiveUpResData
             * @static
             * @param {pb.IGiveUpResData=} [properties] Properties to set
             * @returns {pb.GiveUpResData} GiveUpResData instance
             */
            GiveUpResData.create = function create(properties) {
                return new GiveUpResData(properties);
            };
    
            /**
             * Encodes the specified GiveUpResData message. Does not implicitly {@link pb.GiveUpResData.verify|verify} messages.
             * @function encode
             * @memberof pb.GiveUpResData
             * @static
             * @param {pb.IGiveUpResData} message GiveUpResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiveUpResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uids != null && message.uids.length)
                    for (var i = 0; i < message.uids.length; ++i)
                        $root.pb.GiveUpUserMessage.encode(message.uids[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.grade);
                if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.gameType);
                if (message.leftCoin != null && Object.hasOwnProperty.call(message, "leftCoin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.leftCoin);
                if (message.userData != null && Object.hasOwnProperty.call(message, "userData"))
                    $root.pb.UserData.encode(message.userData, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GiveUpResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GiveUpResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GiveUpResData} GiveUpResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiveUpResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GiveUpResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        if (!(message.uids && message.uids.length))
                            message.uids = [];
                        message.uids.push($root.pb.GiveUpUserMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.grade = reader.int32();
                        break;
                    case 4:
                        message.gameType = reader.int32();
                        break;
                    case 5:
                        message.leftCoin = reader.int64();
                        break;
                    case 6:
                        message.userData = $root.pb.UserData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GiveUpResData;
        })();
    
        pb.GiveUpUserMessage = (function() {
    
            /**
             * Properties of a GiveUpUserMessage.
             * @memberof pb
             * @interface IGiveUpUserMessage
             * @property {string|null} [uid] GiveUpUserMessage uid
             * @property {number|null} [color] GiveUpUserMessage color
             * @property {number|null} [skinId] GiveUpUserMessage skinId
             * @property {boolean|null} [escape] GiveUpUserMessage escape
             */
    
            /**
             * Constructs a new GiveUpUserMessage.
             * @memberof pb
             * @classdesc Represents a GiveUpUserMessage.
             * @implements IGiveUpUserMessage
             * @constructor
             * @param {pb.IGiveUpUserMessage=} [properties] Properties to set
             */
            function GiveUpUserMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GiveUpUserMessage uid.
             * @member {string} uid
             * @memberof pb.GiveUpUserMessage
             * @instance
             */
            GiveUpUserMessage.prototype.uid = "";
    
            /**
             * GiveUpUserMessage color.
             * @member {number} color
             * @memberof pb.GiveUpUserMessage
             * @instance
             */
            GiveUpUserMessage.prototype.color = 0;
    
            /**
             * GiveUpUserMessage skinId.
             * @member {number} skinId
             * @memberof pb.GiveUpUserMessage
             * @instance
             */
            GiveUpUserMessage.prototype.skinId = 0;
    
            /**
             * GiveUpUserMessage escape.
             * @member {boolean} escape
             * @memberof pb.GiveUpUserMessage
             * @instance
             */
            GiveUpUserMessage.prototype.escape = false;
    
            /**
             * Creates a new GiveUpUserMessage instance using the specified properties.
             * @function create
             * @memberof pb.GiveUpUserMessage
             * @static
             * @param {pb.IGiveUpUserMessage=} [properties] Properties to set
             * @returns {pb.GiveUpUserMessage} GiveUpUserMessage instance
             */
            GiveUpUserMessage.create = function create(properties) {
                return new GiveUpUserMessage(properties);
            };
    
            /**
             * Encodes the specified GiveUpUserMessage message. Does not implicitly {@link pb.GiveUpUserMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.GiveUpUserMessage
             * @static
             * @param {pb.IGiveUpUserMessage} message GiveUpUserMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiveUpUserMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
                if (message.skinId != null && Object.hasOwnProperty.call(message, "skinId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.skinId);
                if (message.escape != null && Object.hasOwnProperty.call(message, "escape"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.escape);
                return writer;
            };
    
            /**
             * Decodes a GiveUpUserMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GiveUpUserMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GiveUpUserMessage} GiveUpUserMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiveUpUserMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GiveUpUserMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.color = reader.int32();
                        break;
                    case 3:
                        message.skinId = reader.int32();
                        break;
                    case 4:
                        message.escape = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GiveUpUserMessage;
        })();
    
        pb.ModuleTask = (function() {
    
            /**
             * Properties of a ModuleTask.
             * @memberof pb
             * @interface IModuleTask
             * @property {Array.<pb.ITaskData>|null} [taskList] ModuleTask taskList
             */
    
            /**
             * Constructs a new ModuleTask.
             * @memberof pb
             * @classdesc Represents a ModuleTask.
             * @implements IModuleTask
             * @constructor
             * @param {pb.IModuleTask=} [properties] Properties to set
             */
            function ModuleTask(properties) {
                this.taskList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ModuleTask taskList.
             * @member {Array.<pb.ITaskData>} taskList
             * @memberof pb.ModuleTask
             * @instance
             */
            ModuleTask.prototype.taskList = $util.emptyArray;
    
            /**
             * Creates a new ModuleTask instance using the specified properties.
             * @function create
             * @memberof pb.ModuleTask
             * @static
             * @param {pb.IModuleTask=} [properties] Properties to set
             * @returns {pb.ModuleTask} ModuleTask instance
             */
            ModuleTask.create = function create(properties) {
                return new ModuleTask(properties);
            };
    
            /**
             * Encodes the specified ModuleTask message. Does not implicitly {@link pb.ModuleTask.verify|verify} messages.
             * @function encode
             * @memberof pb.ModuleTask
             * @static
             * @param {pb.IModuleTask} message ModuleTask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModuleTask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskList != null && message.taskList.length)
                    for (var i = 0; i < message.taskList.length; ++i)
                        $root.pb.TaskData.encode(message.taskList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a ModuleTask message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ModuleTask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ModuleTask} ModuleTask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModuleTask.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ModuleTask();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.taskList && message.taskList.length))
                            message.taskList = [];
                        message.taskList.push($root.pb.TaskData.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ModuleTask;
        })();
    
        pb.TaskData = (function() {
    
            /**
             * Properties of a TaskData.
             * @memberof pb
             * @interface ITaskData
             * @property {number|null} [id] TaskData id
             * @property {number|null} [type] TaskData type
             * @property {number|null} [goalValue] TaskData goalValue
             * @property {number|null} [curValue] TaskData curValue
             * @property {boolean|null} [getRewarded] TaskData getRewarded
             * @property {number|null} [refreshType] TaskData refreshType
             * @property {Array.<pb.IRewardItem>|null} [itemList] TaskData itemList
             * @property {number|null} [iconId] TaskData iconId
             * @property {number|null} [describeId] TaskData describeId
             * @property {number|null} [refreshTime] TaskData refreshTime
             * @property {number|null} [order] TaskData order
             * @property {number|null} [boxPoint] TaskData boxPoint
             */
    
            /**
             * Constructs a new TaskData.
             * @memberof pb
             * @classdesc Represents a TaskData.
             * @implements ITaskData
             * @constructor
             * @param {pb.ITaskData=} [properties] Properties to set
             */
            function TaskData(properties) {
                this.itemList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskData id.
             * @member {number} id
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.id = 0;
    
            /**
             * TaskData type.
             * @member {number} type
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.type = 0;
    
            /**
             * TaskData goalValue.
             * @member {number} goalValue
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.goalValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * TaskData curValue.
             * @member {number} curValue
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.curValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * TaskData getRewarded.
             * @member {boolean} getRewarded
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.getRewarded = false;
    
            /**
             * TaskData refreshType.
             * @member {number} refreshType
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.refreshType = 0;
    
            /**
             * TaskData itemList.
             * @member {Array.<pb.IRewardItem>} itemList
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.itemList = $util.emptyArray;
    
            /**
             * TaskData iconId.
             * @member {number} iconId
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.iconId = 0;
    
            /**
             * TaskData describeId.
             * @member {number} describeId
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.describeId = 0;
    
            /**
             * TaskData refreshTime.
             * @member {number} refreshTime
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.refreshTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * TaskData order.
             * @member {number} order
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.order = 0;
    
            /**
             * TaskData boxPoint.
             * @member {number} boxPoint
             * @memberof pb.TaskData
             * @instance
             */
            TaskData.prototype.boxPoint = 0;
    
            /**
             * Creates a new TaskData instance using the specified properties.
             * @function create
             * @memberof pb.TaskData
             * @static
             * @param {pb.ITaskData=} [properties] Properties to set
             * @returns {pb.TaskData} TaskData instance
             */
            TaskData.create = function create(properties) {
                return new TaskData(properties);
            };
    
            /**
             * Encodes the specified TaskData message. Does not implicitly {@link pb.TaskData.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskData
             * @static
             * @param {pb.ITaskData} message TaskData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.goalValue != null && Object.hasOwnProperty.call(message, "goalValue"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.goalValue);
                if (message.curValue != null && Object.hasOwnProperty.call(message, "curValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.curValue);
                if (message.getRewarded != null && Object.hasOwnProperty.call(message, "getRewarded"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.getRewarded);
                if (message.refreshType != null && Object.hasOwnProperty.call(message, "refreshType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.refreshType);
                if (message.itemList != null && message.itemList.length)
                    for (var i = 0; i < message.itemList.length; ++i)
                        $root.pb.RewardItem.encode(message.itemList[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.iconId != null && Object.hasOwnProperty.call(message, "iconId"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.iconId);
                if (message.describeId != null && Object.hasOwnProperty.call(message, "describeId"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.describeId);
                if (message.refreshTime != null && Object.hasOwnProperty.call(message, "refreshTime"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.refreshTime);
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.order);
                if (message.boxPoint != null && Object.hasOwnProperty.call(message, "boxPoint"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.boxPoint);
                return writer;
            };
    
            /**
             * Decodes a TaskData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskData} TaskData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.goalValue = reader.int64();
                        break;
                    case 4:
                        message.curValue = reader.int64();
                        break;
                    case 5:
                        message.getRewarded = reader.bool();
                        break;
                    case 6:
                        message.refreshType = reader.int32();
                        break;
                    case 7:
                        if (!(message.itemList && message.itemList.length))
                            message.itemList = [];
                        message.itemList.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.iconId = reader.int32();
                        break;
                    case 9:
                        message.describeId = reader.int32();
                        break;
                    case 10:
                        message.refreshTime = reader.int64();
                        break;
                    case 11:
                        message.order = reader.int32();
                        break;
                    case 12:
                        message.boxPoint = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskData;
        })();
    
        pb.RewardItem = (function() {
    
            /**
             * Properties of a RewardItem.
             * @memberof pb
             * @interface IRewardItem
             * @property {number|null} [itemId] RewardItem itemId
             * @property {number|null} [itemNum] RewardItem itemNum
             */
    
            /**
             * Constructs a new RewardItem.
             * @memberof pb
             * @classdesc Represents a RewardItem.
             * @implements IRewardItem
             * @constructor
             * @param {pb.IRewardItem=} [properties] Properties to set
             */
            function RewardItem(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RewardItem itemId.
             * @member {number} itemId
             * @memberof pb.RewardItem
             * @instance
             */
            RewardItem.prototype.itemId = 0;
    
            /**
             * RewardItem itemNum.
             * @member {number} itemNum
             * @memberof pb.RewardItem
             * @instance
             */
            RewardItem.prototype.itemNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new RewardItem instance using the specified properties.
             * @function create
             * @memberof pb.RewardItem
             * @static
             * @param {pb.IRewardItem=} [properties] Properties to set
             * @returns {pb.RewardItem} RewardItem instance
             */
            RewardItem.create = function create(properties) {
                return new RewardItem(properties);
            };
    
            /**
             * Encodes the specified RewardItem message. Does not implicitly {@link pb.RewardItem.verify|verify} messages.
             * @function encode
             * @memberof pb.RewardItem
             * @static
             * @param {pb.IRewardItem} message RewardItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RewardItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
                if (message.itemNum != null && Object.hasOwnProperty.call(message, "itemNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.itemNum);
                return writer;
            };
    
            /**
             * Decodes a RewardItem message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RewardItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RewardItem} RewardItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RewardItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RewardItem();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.itemId = reader.int32();
                        break;
                    case 2:
                        message.itemNum = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RewardItem;
        })();
    
        pb.UserData = (function() {
    
            /**
             * Properties of a UserData.
             * @memberof pb
             * @interface IUserData
             * @property {string|null} [uid] UserData uid
             * @property {number|null} [coin] UserData coin
             * @property {number|null} [leftSecond] UserData leftSecond
             * @property {number|null} [skinId] UserData skinId
             * @property {boolean|null} [online] UserData online
             * @property {number|null} [level] UserData level
             * @property {Array.<pb.ISkins1Msg>|null} [decorated] UserData decorated
             * @property {number|null} [winCount] UserData winCount
             * @property {number|null} [eatCount] UserData eatCount
             * @property {number|null} [round] UserData round
             * @property {number|null} [bufferTime] UserData bufferTime
             * @property {number|null} [color] UserData color
             */
    
            /**
             * Constructs a new UserData.
             * @memberof pb
             * @classdesc Represents a UserData.
             * @implements IUserData
             * @constructor
             * @param {pb.IUserData=} [properties] Properties to set
             */
            function UserData(properties) {
                this.decorated = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UserData uid.
             * @member {string} uid
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.uid = "";
    
            /**
             * UserData coin.
             * @member {number} coin
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * UserData leftSecond.
             * @member {number} leftSecond
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.leftSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * UserData skinId.
             * @member {number} skinId
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.skinId = 0;
    
            /**
             * UserData online.
             * @member {boolean} online
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.online = false;
    
            /**
             * UserData level.
             * @member {number} level
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.level = 0;
    
            /**
             * UserData decorated.
             * @member {Array.<pb.ISkins1Msg>} decorated
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.decorated = $util.emptyArray;
    
            /**
             * UserData winCount.
             * @member {number} winCount
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.winCount = 0;
    
            /**
             * UserData eatCount.
             * @member {number} eatCount
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.eatCount = 0;
    
            /**
             * UserData round.
             * @member {number} round
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.round = 0;
    
            /**
             * UserData bufferTime.
             * @member {number} bufferTime
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.bufferTime = 0;
    
            /**
             * UserData color.
             * @member {number} color
             * @memberof pb.UserData
             * @instance
             */
            UserData.prototype.color = 0;
    
            /**
             * Creates a new UserData instance using the specified properties.
             * @function create
             * @memberof pb.UserData
             * @static
             * @param {pb.IUserData=} [properties] Properties to set
             * @returns {pb.UserData} UserData instance
             */
            UserData.create = function create(properties) {
                return new UserData(properties);
            };
    
            /**
             * Encodes the specified UserData message. Does not implicitly {@link pb.UserData.verify|verify} messages.
             * @function encode
             * @memberof pb.UserData
             * @static
             * @param {pb.IUserData} message UserData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.coin);
                if (message.leftSecond != null && Object.hasOwnProperty.call(message, "leftSecond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.leftSecond);
                if (message.skinId != null && Object.hasOwnProperty.call(message, "skinId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.skinId);
                if (message.online != null && Object.hasOwnProperty.call(message, "online"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.online);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.level);
                if (message.decorated != null && message.decorated.length)
                    for (var i = 0; i < message.decorated.length; ++i)
                        $root.pb.Skins1Msg.encode(message.decorated[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.winCount != null && Object.hasOwnProperty.call(message, "winCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.winCount);
                if (message.eatCount != null && Object.hasOwnProperty.call(message, "eatCount"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.eatCount);
                if (message.round != null && Object.hasOwnProperty.call(message, "round"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.round);
                if (message.bufferTime != null && Object.hasOwnProperty.call(message, "bufferTime"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.bufferTime);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.color);
                return writer;
            };
    
            /**
             * Decodes a UserData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.UserData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.UserData} UserData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UserData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.coin = reader.int64();
                        break;
                    case 3:
                        message.leftSecond = reader.int64();
                        break;
                    case 4:
                        message.skinId = reader.int32();
                        break;
                    case 5:
                        message.online = reader.bool();
                        break;
                    case 6:
                        message.level = reader.int32();
                        break;
                    case 7:
                        if (!(message.decorated && message.decorated.length))
                            message.decorated = [];
                        message.decorated.push($root.pb.Skins1Msg.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.winCount = reader.int32();
                        break;
                    case 9:
                        message.eatCount = reader.int32();
                        break;
                    case 10:
                        message.round = reader.int32();
                        break;
                    case 11:
                        message.bufferTime = reader.int32();
                        break;
                    case 12:
                        message.color = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return UserData;
        })();
    
        pb.Skins1Msg = (function() {
    
            /**
             * Properties of a Skins1Msg.
             * @memberof pb
             * @interface ISkins1Msg
             * @property {number|null} [type] Skins1Msg type
             * @property {Array.<number>|null} [ids] Skins1Msg ids
             */
    
            /**
             * Constructs a new Skins1Msg.
             * @memberof pb
             * @classdesc Represents a Skins1Msg.
             * @implements ISkins1Msg
             * @constructor
             * @param {pb.ISkins1Msg=} [properties] Properties to set
             */
            function Skins1Msg(properties) {
                this.ids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Skins1Msg type.
             * @member {number} type
             * @memberof pb.Skins1Msg
             * @instance
             */
            Skins1Msg.prototype.type = 0;
    
            /**
             * Skins1Msg ids.
             * @member {Array.<number>} ids
             * @memberof pb.Skins1Msg
             * @instance
             */
            Skins1Msg.prototype.ids = $util.emptyArray;
    
            /**
             * Creates a new Skins1Msg instance using the specified properties.
             * @function create
             * @memberof pb.Skins1Msg
             * @static
             * @param {pb.ISkins1Msg=} [properties] Properties to set
             * @returns {pb.Skins1Msg} Skins1Msg instance
             */
            Skins1Msg.create = function create(properties) {
                return new Skins1Msg(properties);
            };
    
            /**
             * Encodes the specified Skins1Msg message. Does not implicitly {@link pb.Skins1Msg.verify|verify} messages.
             * @function encode
             * @memberof pb.Skins1Msg
             * @static
             * @param {pb.ISkins1Msg} message Skins1Msg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Skins1Msg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.ids != null && message.ids.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.ids.length; ++i)
                        writer.int32(message.ids[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Decodes a Skins1Msg message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Skins1Msg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Skins1Msg} Skins1Msg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Skins1Msg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Skins1Msg();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        if (!(message.ids && message.ids.length))
                            message.ids = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ids.push(reader.int32());
                        } else
                            message.ids.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Skins1Msg;
        })();
    
        pb.UserSkin1Message = (function() {
    
            /**
             * Properties of a UserSkin1Message.
             * @memberof pb
             * @interface IUserSkin1Message
             * @property {number|null} [crystalCoin] UserSkin1Message crystalCoin
             * @property {Array.<pb.ISkins1Msg>|null} [decorated] UserSkin1Message decorated
             * @property {Array.<pb.ISkins1Msg>|null} [owners] UserSkin1Message owners
             */
    
            /**
             * Constructs a new UserSkin1Message.
             * @memberof pb
             * @classdesc Represents a UserSkin1Message.
             * @implements IUserSkin1Message
             * @constructor
             * @param {pb.IUserSkin1Message=} [properties] Properties to set
             */
            function UserSkin1Message(properties) {
                this.decorated = [];
                this.owners = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UserSkin1Message crystalCoin.
             * @member {number} crystalCoin
             * @memberof pb.UserSkin1Message
             * @instance
             */
            UserSkin1Message.prototype.crystalCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * UserSkin1Message decorated.
             * @member {Array.<pb.ISkins1Msg>} decorated
             * @memberof pb.UserSkin1Message
             * @instance
             */
            UserSkin1Message.prototype.decorated = $util.emptyArray;
    
            /**
             * UserSkin1Message owners.
             * @member {Array.<pb.ISkins1Msg>} owners
             * @memberof pb.UserSkin1Message
             * @instance
             */
            UserSkin1Message.prototype.owners = $util.emptyArray;
    
            /**
             * Creates a new UserSkin1Message instance using the specified properties.
             * @function create
             * @memberof pb.UserSkin1Message
             * @static
             * @param {pb.IUserSkin1Message=} [properties] Properties to set
             * @returns {pb.UserSkin1Message} UserSkin1Message instance
             */
            UserSkin1Message.create = function create(properties) {
                return new UserSkin1Message(properties);
            };
    
            /**
             * Encodes the specified UserSkin1Message message. Does not implicitly {@link pb.UserSkin1Message.verify|verify} messages.
             * @function encode
             * @memberof pb.UserSkin1Message
             * @static
             * @param {pb.IUserSkin1Message} message UserSkin1Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserSkin1Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.crystalCoin != null && Object.hasOwnProperty.call(message, "crystalCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.crystalCoin);
                if (message.decorated != null && message.decorated.length)
                    for (var i = 0; i < message.decorated.length; ++i)
                        $root.pb.Skins1Msg.encode(message.decorated[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.owners != null && message.owners.length)
                    for (var i = 0; i < message.owners.length; ++i)
                        $root.pb.Skins1Msg.encode(message.owners[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a UserSkin1Message message from the specified reader or buffer.
             * @function decode
             * @memberof pb.UserSkin1Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.UserSkin1Message} UserSkin1Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserSkin1Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UserSkin1Message();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.crystalCoin = reader.int64();
                        break;
                    case 2:
                        if (!(message.decorated && message.decorated.length))
                            message.decorated = [];
                        message.decorated.push($root.pb.Skins1Msg.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.owners && message.owners.length))
                            message.owners = [];
                        message.owners.push($root.pb.Skins1Msg.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return UserSkin1Message;
        })();
    
        pb.ReadyGoRes = (function() {
    
            /**
             * Properties of a ReadyGoRes.
             * @memberof pb
             * @interface IReadyGoRes
             * @property {number|null} [code] ReadyGoRes code
             * @property {string|null} [msg] ReadyGoRes msg
             * @property {pb.IReadyGoResData|null} [data] ReadyGoRes data
             */
    
            /**
             * Constructs a new ReadyGoRes.
             * @memberof pb
             * @classdesc Represents a ReadyGoRes.
             * @implements IReadyGoRes
             * @constructor
             * @param {pb.IReadyGoRes=} [properties] Properties to set
             */
            function ReadyGoRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReadyGoRes code.
             * @member {number} code
             * @memberof pb.ReadyGoRes
             * @instance
             */
            ReadyGoRes.prototype.code = 0;
    
            /**
             * ReadyGoRes msg.
             * @member {string} msg
             * @memberof pb.ReadyGoRes
             * @instance
             */
            ReadyGoRes.prototype.msg = "";
    
            /**
             * ReadyGoRes data.
             * @member {pb.IReadyGoResData|null|undefined} data
             * @memberof pb.ReadyGoRes
             * @instance
             */
            ReadyGoRes.prototype.data = null;
    
            /**
             * Creates a new ReadyGoRes instance using the specified properties.
             * @function create
             * @memberof pb.ReadyGoRes
             * @static
             * @param {pb.IReadyGoRes=} [properties] Properties to set
             * @returns {pb.ReadyGoRes} ReadyGoRes instance
             */
            ReadyGoRes.create = function create(properties) {
                return new ReadyGoRes(properties);
            };
    
            /**
             * Encodes the specified ReadyGoRes message. Does not implicitly {@link pb.ReadyGoRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ReadyGoRes
             * @static
             * @param {pb.IReadyGoRes} message ReadyGoRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadyGoRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.ReadyGoResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a ReadyGoRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReadyGoRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReadyGoRes} ReadyGoRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadyGoRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReadyGoRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.ReadyGoResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReadyGoRes;
        })();
    
        pb.ReadyGoResData = (function() {
    
            /**
             * Properties of a ReadyGoResData.
             * @memberof pb
             * @interface IReadyGoResData
             * @property {string|null} [first_uid] ReadyGoResData first_uid
             * @property {string|null} [ai_config] ReadyGoResData ai_config
             * @property {Array.<pb.IFlyer>|null} [flyer] ReadyGoResData flyer
             * @property {pb.IChessBoard|null} [chessboard] ReadyGoResData chessboard
             * @property {number|null} [start_time] ReadyGoResData start_time
             * @property {Array.<pb.IPlayer>|null} [players] ReadyGoResData players
             * @property {number|null} [roundEndTime] ReadyGoResData roundEndTime
             * @property {Array.<pb.IUserData>|null} [userDatas] ReadyGoResData userDatas
             * @property {number|null} [loseCoin] ReadyGoResData loseCoin
             * @property {number|null} [winCoin] ReadyGoResData winCoin
             * @property {number|null} [gameMode] ReadyGoResData gameMode
             */
    
            /**
             * Constructs a new ReadyGoResData.
             * @memberof pb
             * @classdesc Represents a ReadyGoResData.
             * @implements IReadyGoResData
             * @constructor
             * @param {pb.IReadyGoResData=} [properties] Properties to set
             */
            function ReadyGoResData(properties) {
                this.flyer = [];
                this.players = [];
                this.userDatas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReadyGoResData first_uid.
             * @member {string} first_uid
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.first_uid = "";
    
            /**
             * ReadyGoResData ai_config.
             * @member {string} ai_config
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.ai_config = "";
    
            /**
             * ReadyGoResData flyer.
             * @member {Array.<pb.IFlyer>} flyer
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.flyer = $util.emptyArray;
    
            /**
             * ReadyGoResData chessboard.
             * @member {pb.IChessBoard|null|undefined} chessboard
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.chessboard = null;
    
            /**
             * ReadyGoResData start_time.
             * @member {number} start_time
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.start_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReadyGoResData players.
             * @member {Array.<pb.IPlayer>} players
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.players = $util.emptyArray;
    
            /**
             * ReadyGoResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReadyGoResData userDatas.
             * @member {Array.<pb.IUserData>} userDatas
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.userDatas = $util.emptyArray;
    
            /**
             * ReadyGoResData loseCoin.
             * @member {number} loseCoin
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.loseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReadyGoResData winCoin.
             * @member {number} winCoin
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.winCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReadyGoResData gameMode.
             * @member {number} gameMode
             * @memberof pb.ReadyGoResData
             * @instance
             */
            ReadyGoResData.prototype.gameMode = 0;
    
            /**
             * Creates a new ReadyGoResData instance using the specified properties.
             * @function create
             * @memberof pb.ReadyGoResData
             * @static
             * @param {pb.IReadyGoResData=} [properties] Properties to set
             * @returns {pb.ReadyGoResData} ReadyGoResData instance
             */
            ReadyGoResData.create = function create(properties) {
                return new ReadyGoResData(properties);
            };
    
            /**
             * Encodes the specified ReadyGoResData message. Does not implicitly {@link pb.ReadyGoResData.verify|verify} messages.
             * @function encode
             * @memberof pb.ReadyGoResData
             * @static
             * @param {pb.IReadyGoResData} message ReadyGoResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReadyGoResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.first_uid != null && Object.hasOwnProperty.call(message, "first_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.first_uid);
                if (message.ai_config != null && Object.hasOwnProperty.call(message, "ai_config"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.ai_config);
                if (message.flyer != null && message.flyer.length)
                    for (var i = 0; i < message.flyer.length; ++i)
                        $root.pb.Flyer.encode(message.flyer[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.chessboard != null && Object.hasOwnProperty.call(message, "chessboard"))
                    $root.pb.ChessBoard.encode(message.chessboard, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.start_time != null && Object.hasOwnProperty.call(message, "start_time"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.start_time);
                if (message.players != null && message.players.length)
                    for (var i = 0; i < message.players.length; ++i)
                        $root.pb.Player.encode(message.players[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.roundEndTime);
                if (message.userDatas != null && message.userDatas.length)
                    for (var i = 0; i < message.userDatas.length; ++i)
                        $root.pb.UserData.encode(message.userDatas[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.loseCoin != null && Object.hasOwnProperty.call(message, "loseCoin"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.loseCoin);
                if (message.winCoin != null && Object.hasOwnProperty.call(message, "winCoin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.winCoin);
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gameMode);
                return writer;
            };
    
            /**
             * Decodes a ReadyGoResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReadyGoResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReadyGoResData} ReadyGoResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReadyGoResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReadyGoResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.first_uid = reader.string();
                        break;
                    case 2:
                        message.ai_config = reader.string();
                        break;
                    case 3:
                        if (!(message.flyer && message.flyer.length))
                            message.flyer = [];
                        message.flyer.push($root.pb.Flyer.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.chessboard = $root.pb.ChessBoard.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.start_time = reader.int64();
                        break;
                    case 6:
                        if (!(message.players && message.players.length))
                            message.players = [];
                        message.players.push($root.pb.Player.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.roundEndTime = reader.int64();
                        break;
                    case 8:
                        if (!(message.userDatas && message.userDatas.length))
                            message.userDatas = [];
                        message.userDatas.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.loseCoin = reader.int64();
                        break;
                    case 10:
                        message.winCoin = reader.int64();
                        break;
                    case 11:
                        message.gameMode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReadyGoResData;
        })();
    
        pb.Flyer = (function() {
    
            /**
             * Properties of a Flyer.
             * @memberof pb
             * @interface IFlyer
             * @property {string|null} [uid] Flyer uid
             * @property {number|null} [color] Flyer color
             * @property {number|null} [plane_num] Flyer plane_num
             * @property {Array.<pb.IPosition>|null} [path] Flyer path
             * @property {Array.<pb.IPosition>|null} [safe_positions] Flyer safe_positions
             * @property {number|null} [guide_player] Flyer guide_player
             */
    
            /**
             * Constructs a new Flyer.
             * @memberof pb
             * @classdesc Represents a Flyer.
             * @implements IFlyer
             * @constructor
             * @param {pb.IFlyer=} [properties] Properties to set
             */
            function Flyer(properties) {
                this.path = [];
                this.safe_positions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Flyer uid.
             * @member {string} uid
             * @memberof pb.Flyer
             * @instance
             */
            Flyer.prototype.uid = "";
    
            /**
             * Flyer color.
             * @member {number} color
             * @memberof pb.Flyer
             * @instance
             */
            Flyer.prototype.color = 0;
    
            /**
             * Flyer plane_num.
             * @member {number} plane_num
             * @memberof pb.Flyer
             * @instance
             */
            Flyer.prototype.plane_num = 0;
    
            /**
             * Flyer path.
             * @member {Array.<pb.IPosition>} path
             * @memberof pb.Flyer
             * @instance
             */
            Flyer.prototype.path = $util.emptyArray;
    
            /**
             * Flyer safe_positions.
             * @member {Array.<pb.IPosition>} safe_positions
             * @memberof pb.Flyer
             * @instance
             */
            Flyer.prototype.safe_positions = $util.emptyArray;
    
            /**
             * Flyer guide_player.
             * @member {number} guide_player
             * @memberof pb.Flyer
             * @instance
             */
            Flyer.prototype.guide_player = 0;
    
            /**
             * Creates a new Flyer instance using the specified properties.
             * @function create
             * @memberof pb.Flyer
             * @static
             * @param {pb.IFlyer=} [properties] Properties to set
             * @returns {pb.Flyer} Flyer instance
             */
            Flyer.create = function create(properties) {
                return new Flyer(properties);
            };
    
            /**
             * Encodes the specified Flyer message. Does not implicitly {@link pb.Flyer.verify|verify} messages.
             * @function encode
             * @memberof pb.Flyer
             * @static
             * @param {pb.IFlyer} message Flyer message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Flyer.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
                if (message.plane_num != null && Object.hasOwnProperty.call(message, "plane_num"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.plane_num);
                if (message.path != null && message.path.length)
                    for (var i = 0; i < message.path.length; ++i)
                        $root.pb.Position.encode(message.path[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.safe_positions != null && message.safe_positions.length)
                    for (var i = 0; i < message.safe_positions.length; ++i)
                        $root.pb.Position.encode(message.safe_positions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.guide_player != null && Object.hasOwnProperty.call(message, "guide_player"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.guide_player);
                return writer;
            };
    
            /**
             * Decodes a Flyer message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Flyer
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Flyer} Flyer
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Flyer.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Flyer();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.color = reader.int32();
                        break;
                    case 3:
                        message.plane_num = reader.int32();
                        break;
                    case 4:
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push($root.pb.Position.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.safe_positions && message.safe_positions.length))
                            message.safe_positions = [];
                        message.safe_positions.push($root.pb.Position.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.guide_player = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Flyer;
        })();
    
        pb.ChessBoard = (function() {
    
            /**
             * Properties of a ChessBoard.
             * @memberof pb
             * @interface IChessBoard
             * @property {Array.<pb.IAirPortPlane>|null} [airport_planes] ChessBoard airport_planes
             * @property {Array.<pb.IPlane>|null} [plane] ChessBoard plane
             */
    
            /**
             * Constructs a new ChessBoard.
             * @memberof pb
             * @classdesc Represents a ChessBoard.
             * @implements IChessBoard
             * @constructor
             * @param {pb.IChessBoard=} [properties] Properties to set
             */
            function ChessBoard(properties) {
                this.airport_planes = [];
                this.plane = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ChessBoard airport_planes.
             * @member {Array.<pb.IAirPortPlane>} airport_planes
             * @memberof pb.ChessBoard
             * @instance
             */
            ChessBoard.prototype.airport_planes = $util.emptyArray;
    
            /**
             * ChessBoard plane.
             * @member {Array.<pb.IPlane>} plane
             * @memberof pb.ChessBoard
             * @instance
             */
            ChessBoard.prototype.plane = $util.emptyArray;
    
            /**
             * Creates a new ChessBoard instance using the specified properties.
             * @function create
             * @memberof pb.ChessBoard
             * @static
             * @param {pb.IChessBoard=} [properties] Properties to set
             * @returns {pb.ChessBoard} ChessBoard instance
             */
            ChessBoard.create = function create(properties) {
                return new ChessBoard(properties);
            };
    
            /**
             * Encodes the specified ChessBoard message. Does not implicitly {@link pb.ChessBoard.verify|verify} messages.
             * @function encode
             * @memberof pb.ChessBoard
             * @static
             * @param {pb.IChessBoard} message ChessBoard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChessBoard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.airport_planes != null && message.airport_planes.length)
                    for (var i = 0; i < message.airport_planes.length; ++i)
                        $root.pb.AirPortPlane.encode(message.airport_planes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.plane != null && message.plane.length)
                    for (var i = 0; i < message.plane.length; ++i)
                        $root.pb.Plane.encode(message.plane[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a ChessBoard message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ChessBoard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ChessBoard} ChessBoard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChessBoard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChessBoard();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.airport_planes && message.airport_planes.length))
                            message.airport_planes = [];
                        message.airport_planes.push($root.pb.AirPortPlane.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.plane && message.plane.length))
                            message.plane = [];
                        message.plane.push($root.pb.Plane.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ChessBoard;
        })();
    
        pb.AirPortPlane = (function() {
    
            /**
             * Properties of an AirPortPlane.
             * @memberof pb
             * @interface IAirPortPlane
             * @property {number|null} [color] AirPortPlane color
             * @property {number|null} [plane] AirPortPlane plane
             * @property {number|null} [pos] AirPortPlane pos
             */
    
            /**
             * Constructs a new AirPortPlane.
             * @memberof pb
             * @classdesc Represents an AirPortPlane.
             * @implements IAirPortPlane
             * @constructor
             * @param {pb.IAirPortPlane=} [properties] Properties to set
             */
            function AirPortPlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AirPortPlane color.
             * @member {number} color
             * @memberof pb.AirPortPlane
             * @instance
             */
            AirPortPlane.prototype.color = 0;
    
            /**
             * AirPortPlane plane.
             * @member {number} plane
             * @memberof pb.AirPortPlane
             * @instance
             */
            AirPortPlane.prototype.plane = 0;
    
            /**
             * AirPortPlane pos.
             * @member {number} pos
             * @memberof pb.AirPortPlane
             * @instance
             */
            AirPortPlane.prototype.pos = 0;
    
            /**
             * Creates a new AirPortPlane instance using the specified properties.
             * @function create
             * @memberof pb.AirPortPlane
             * @static
             * @param {pb.IAirPortPlane=} [properties] Properties to set
             * @returns {pb.AirPortPlane} AirPortPlane instance
             */
            AirPortPlane.create = function create(properties) {
                return new AirPortPlane(properties);
            };
    
            /**
             * Encodes the specified AirPortPlane message. Does not implicitly {@link pb.AirPortPlane.verify|verify} messages.
             * @function encode
             * @memberof pb.AirPortPlane
             * @static
             * @param {pb.IAirPortPlane} message AirPortPlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AirPortPlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pos);
                return writer;
            };
    
            /**
             * Decodes an AirPortPlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AirPortPlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AirPortPlane} AirPortPlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AirPortPlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AirPortPlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.pos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AirPortPlane;
        })();
    
        pb.Plane = (function() {
    
            /**
             * Properties of a Plane.
             * @memberof pb
             * @interface IPlane
             * @property {number|null} [x] Plane x
             * @property {number|null} [y] Plane y
             * @property {number|null} [color] Plane color
             * @property {number|null} [plane] Plane plane
             */
    
            /**
             * Constructs a new Plane.
             * @memberof pb
             * @classdesc Represents a Plane.
             * @implements IPlane
             * @constructor
             * @param {pb.IPlane=} [properties] Properties to set
             */
            function Plane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Plane x.
             * @member {number} x
             * @memberof pb.Plane
             * @instance
             */
            Plane.prototype.x = 0;
    
            /**
             * Plane y.
             * @member {number} y
             * @memberof pb.Plane
             * @instance
             */
            Plane.prototype.y = 0;
    
            /**
             * Plane color.
             * @member {number} color
             * @memberof pb.Plane
             * @instance
             */
            Plane.prototype.color = 0;
    
            /**
             * Plane plane.
             * @member {number} plane
             * @memberof pb.Plane
             * @instance
             */
            Plane.prototype.plane = 0;
    
            /**
             * Creates a new Plane instance using the specified properties.
             * @function create
             * @memberof pb.Plane
             * @static
             * @param {pb.IPlane=} [properties] Properties to set
             * @returns {pb.Plane} Plane instance
             */
            Plane.create = function create(properties) {
                return new Plane(properties);
            };
    
            /**
             * Encodes the specified Plane message. Does not implicitly {@link pb.Plane.verify|verify} messages.
             * @function encode
             * @memberof pb.Plane
             * @static
             * @param {pb.IPlane} message Plane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Plane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.plane);
                return writer;
            };
    
            /**
             * Decodes a Plane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Plane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Plane} Plane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Plane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Plane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.x = reader.int32();
                        break;
                    case 2:
                        message.y = reader.int32();
                        break;
                    case 3:
                        message.color = reader.int32();
                        break;
                    case 4:
                        message.plane = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Plane;
        })();
    
        pb.RaceGameOverMessage = (function() {
    
            /**
             * Properties of a RaceGameOverMessage.
             * @memberof pb
             * @interface IRaceGameOverMessage
             * @property {string|null} [winUid] RaceGameOverMessage winUid
             * @property {Array.<pb.IRaceUserMessage>|null} [users] RaceGameOverMessage users
             * @property {number|null} [baseAwardCount] RaceGameOverMessage baseAwardCount
             * @property {pb.IRaceAwardMessage|null} [raceAward] RaceGameOverMessage raceAward
             * @property {number|null} [ticketCoin] RaceGameOverMessage ticketCoin
             * @property {number|null} [extraCoin] RaceGameOverMessage extraCoin
             */
    
            /**
             * Constructs a new RaceGameOverMessage.
             * @memberof pb
             * @classdesc Represents a RaceGameOverMessage.
             * @implements IRaceGameOverMessage
             * @constructor
             * @param {pb.IRaceGameOverMessage=} [properties] Properties to set
             */
            function RaceGameOverMessage(properties) {
                this.users = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceGameOverMessage winUid.
             * @member {string} winUid
             * @memberof pb.RaceGameOverMessage
             * @instance
             */
            RaceGameOverMessage.prototype.winUid = "";
    
            /**
             * RaceGameOverMessage users.
             * @member {Array.<pb.IRaceUserMessage>} users
             * @memberof pb.RaceGameOverMessage
             * @instance
             */
            RaceGameOverMessage.prototype.users = $util.emptyArray;
    
            /**
             * RaceGameOverMessage baseAwardCount.
             * @member {number} baseAwardCount
             * @memberof pb.RaceGameOverMessage
             * @instance
             */
            RaceGameOverMessage.prototype.baseAwardCount = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * RaceGameOverMessage raceAward.
             * @member {pb.IRaceAwardMessage|null|undefined} raceAward
             * @memberof pb.RaceGameOverMessage
             * @instance
             */
            RaceGameOverMessage.prototype.raceAward = null;
    
            /**
             * RaceGameOverMessage ticketCoin.
             * @member {number} ticketCoin
             * @memberof pb.RaceGameOverMessage
             * @instance
             */
            RaceGameOverMessage.prototype.ticketCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * RaceGameOverMessage extraCoin.
             * @member {number} extraCoin
             * @memberof pb.RaceGameOverMessage
             * @instance
             */
            RaceGameOverMessage.prototype.extraCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new RaceGameOverMessage instance using the specified properties.
             * @function create
             * @memberof pb.RaceGameOverMessage
             * @static
             * @param {pb.IRaceGameOverMessage=} [properties] Properties to set
             * @returns {pb.RaceGameOverMessage} RaceGameOverMessage instance
             */
            RaceGameOverMessage.create = function create(properties) {
                return new RaceGameOverMessage(properties);
            };
    
            /**
             * Encodes the specified RaceGameOverMessage message. Does not implicitly {@link pb.RaceGameOverMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceGameOverMessage
             * @static
             * @param {pb.IRaceGameOverMessage} message RaceGameOverMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceGameOverMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.winUid != null && Object.hasOwnProperty.call(message, "winUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.winUid);
                if (message.users != null && message.users.length)
                    for (var i = 0; i < message.users.length; ++i)
                        $root.pb.RaceUserMessage.encode(message.users[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.baseAwardCount != null && Object.hasOwnProperty.call(message, "baseAwardCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.baseAwardCount);
                if (message.raceAward != null && Object.hasOwnProperty.call(message, "raceAward"))
                    $root.pb.RaceAwardMessage.encode(message.raceAward, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.ticketCoin != null && Object.hasOwnProperty.call(message, "ticketCoin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.ticketCoin);
                if (message.extraCoin != null && Object.hasOwnProperty.call(message, "extraCoin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.extraCoin);
                return writer;
            };
    
            /**
             * Decodes a RaceGameOverMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceGameOverMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceGameOverMessage} RaceGameOverMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceGameOverMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceGameOverMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.winUid = reader.string();
                        break;
                    case 2:
                        if (!(message.users && message.users.length))
                            message.users = [];
                        message.users.push($root.pb.RaceUserMessage.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.baseAwardCount = reader.int64();
                        break;
                    case 4:
                        message.raceAward = $root.pb.RaceAwardMessage.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.ticketCoin = reader.int64();
                        break;
                    case 6:
                        message.extraCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceGameOverMessage;
        })();
    
        pb.RaceUserMessage = (function() {
    
            /**
             * Properties of a RaceUserMessage.
             * @memberof pb
             * @interface IRaceUserMessage
             * @property {string|null} [uid] RaceUserMessage uid
             * @property {number|null} [winCount] RaceUserMessage winCount
             * @property {number|null} [bestWinCount] RaceUserMessage bestWinCount
             * @property {number|null} [shareCount] RaceUserMessage shareCount
             * @property {string|null} [shareId] RaceUserMessage shareId
             * @property {number|null} [rebornCount] RaceUserMessage rebornCount
             * @property {string|null} [rebornId] RaceUserMessage rebornId
             * @property {number|null} [leftFreeTicket] RaceUserMessage leftFreeTicket
             * @property {number|null} [leftBuyTicket] RaceUserMessage leftBuyTicket
             * @property {number|null} [dayLeftRebornCount] RaceUserMessage dayLeftRebornCount
             */
    
            /**
             * Constructs a new RaceUserMessage.
             * @memberof pb
             * @classdesc Represents a RaceUserMessage.
             * @implements IRaceUserMessage
             * @constructor
             * @param {pb.IRaceUserMessage=} [properties] Properties to set
             */
            function RaceUserMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceUserMessage uid.
             * @member {string} uid
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.uid = "";
    
            /**
             * RaceUserMessage winCount.
             * @member {number} winCount
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.winCount = 0;
    
            /**
             * RaceUserMessage bestWinCount.
             * @member {number} bestWinCount
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.bestWinCount = 0;
    
            /**
             * RaceUserMessage shareCount.
             * @member {number} shareCount
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.shareCount = 0;
    
            /**
             * RaceUserMessage shareId.
             * @member {string} shareId
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.shareId = "";
    
            /**
             * RaceUserMessage rebornCount.
             * @member {number} rebornCount
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.rebornCount = 0;
    
            /**
             * RaceUserMessage rebornId.
             * @member {string} rebornId
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.rebornId = "";
    
            /**
             * RaceUserMessage leftFreeTicket.
             * @member {number} leftFreeTicket
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.leftFreeTicket = 0;
    
            /**
             * RaceUserMessage leftBuyTicket.
             * @member {number} leftBuyTicket
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.leftBuyTicket = 0;
    
            /**
             * RaceUserMessage dayLeftRebornCount.
             * @member {number} dayLeftRebornCount
             * @memberof pb.RaceUserMessage
             * @instance
             */
            RaceUserMessage.prototype.dayLeftRebornCount = 0;
    
            /**
             * Creates a new RaceUserMessage instance using the specified properties.
             * @function create
             * @memberof pb.RaceUserMessage
             * @static
             * @param {pb.IRaceUserMessage=} [properties] Properties to set
             * @returns {pb.RaceUserMessage} RaceUserMessage instance
             */
            RaceUserMessage.create = function create(properties) {
                return new RaceUserMessage(properties);
            };
    
            /**
             * Encodes the specified RaceUserMessage message. Does not implicitly {@link pb.RaceUserMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceUserMessage
             * @static
             * @param {pb.IRaceUserMessage} message RaceUserMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceUserMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.winCount != null && Object.hasOwnProperty.call(message, "winCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.winCount);
                if (message.bestWinCount != null && Object.hasOwnProperty.call(message, "bestWinCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.bestWinCount);
                if (message.shareCount != null && Object.hasOwnProperty.call(message, "shareCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.shareCount);
                if (message.shareId != null && Object.hasOwnProperty.call(message, "shareId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.shareId);
                if (message.rebornCount != null && Object.hasOwnProperty.call(message, "rebornCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rebornCount);
                if (message.rebornId != null && Object.hasOwnProperty.call(message, "rebornId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.rebornId);
                if (message.leftFreeTicket != null && Object.hasOwnProperty.call(message, "leftFreeTicket"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.leftFreeTicket);
                if (message.leftBuyTicket != null && Object.hasOwnProperty.call(message, "leftBuyTicket"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.leftBuyTicket);
                if (message.dayLeftRebornCount != null && Object.hasOwnProperty.call(message, "dayLeftRebornCount"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.dayLeftRebornCount);
                return writer;
            };
    
            /**
             * Decodes a RaceUserMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceUserMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceUserMessage} RaceUserMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceUserMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceUserMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.winCount = reader.int32();
                        break;
                    case 3:
                        message.bestWinCount = reader.int32();
                        break;
                    case 4:
                        message.shareCount = reader.int32();
                        break;
                    case 5:
                        message.shareId = reader.string();
                        break;
                    case 6:
                        message.rebornCount = reader.int32();
                        break;
                    case 7:
                        message.rebornId = reader.string();
                        break;
                    case 8:
                        message.leftFreeTicket = reader.int32();
                        break;
                    case 9:
                        message.leftBuyTicket = reader.int32();
                        break;
                    case 10:
                        message.dayLeftRebornCount = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceUserMessage;
        })();
    
        pb.SixModeGameOverMessage = (function() {
    
            /**
             * Properties of a SixModeGameOverMessage.
             * @memberof pb
             * @interface ISixModeGameOverMessage
             * @property {Array.<number>|null} [rank] SixModeGameOverMessage rank
             * @property {Array.<number>|null} [coinChange] SixModeGameOverMessage coinChange
             */
    
            /**
             * Constructs a new SixModeGameOverMessage.
             * @memberof pb
             * @classdesc Represents a SixModeGameOverMessage.
             * @implements ISixModeGameOverMessage
             * @constructor
             * @param {pb.ISixModeGameOverMessage=} [properties] Properties to set
             */
            function SixModeGameOverMessage(properties) {
                this.rank = [];
                this.coinChange = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeGameOverMessage rank.
             * @member {Array.<number>} rank
             * @memberof pb.SixModeGameOverMessage
             * @instance
             */
            SixModeGameOverMessage.prototype.rank = $util.emptyArray;
    
            /**
             * SixModeGameOverMessage coinChange.
             * @member {Array.<number>} coinChange
             * @memberof pb.SixModeGameOverMessage
             * @instance
             */
            SixModeGameOverMessage.prototype.coinChange = $util.emptyArray;
    
            /**
             * Creates a new SixModeGameOverMessage instance using the specified properties.
             * @function create
             * @memberof pb.SixModeGameOverMessage
             * @static
             * @param {pb.ISixModeGameOverMessage=} [properties] Properties to set
             * @returns {pb.SixModeGameOverMessage} SixModeGameOverMessage instance
             */
            SixModeGameOverMessage.create = function create(properties) {
                return new SixModeGameOverMessage(properties);
            };
    
            /**
             * Encodes the specified SixModeGameOverMessage message. Does not implicitly {@link pb.SixModeGameOverMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeGameOverMessage
             * @static
             * @param {pb.ISixModeGameOverMessage} message SixModeGameOverMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeGameOverMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rank != null && message.rank.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.rank.length; ++i)
                        writer.int32(message.rank[i]);
                    writer.ldelim();
                }
                if (message.coinChange != null && message.coinChange.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.coinChange.length; ++i)
                        writer.int32(message.coinChange[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Decodes a SixModeGameOverMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeGameOverMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeGameOverMessage} SixModeGameOverMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeGameOverMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeGameOverMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.rank && message.rank.length))
                            message.rank = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.rank.push(reader.int32());
                        } else
                            message.rank.push(reader.int32());
                        break;
                    case 2:
                        if (!(message.coinChange && message.coinChange.length))
                            message.coinChange = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.coinChange.push(reader.int32());
                        } else
                            message.coinChange.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeGameOverMessage;
        })();
    
        pb.GhostModeGameOverMessage = (function() {
    
            /**
             * Properties of a GhostModeGameOverMessage.
             * @memberof pb
             * @interface IGhostModeGameOverMessage
             * @property {Array.<pb.IRewardItem>|null} [winArwards] GhostModeGameOverMessage winArwards
             * @property {Array.<pb.IRewardItem>|null} [lostArwards] GhostModeGameOverMessage lostArwards
             * @property {Array.<string>|null} [winners] GhostModeGameOverMessage winners
             * @property {number|null} [ghostScore] GhostModeGameOverMessage ghostScore
             * @property {number|null} [userScore] GhostModeGameOverMessage userScore
             */
    
            /**
             * Constructs a new GhostModeGameOverMessage.
             * @memberof pb
             * @classdesc Represents a GhostModeGameOverMessage.
             * @implements IGhostModeGameOverMessage
             * @constructor
             * @param {pb.IGhostModeGameOverMessage=} [properties] Properties to set
             */
            function GhostModeGameOverMessage(properties) {
                this.winArwards = [];
                this.lostArwards = [];
                this.winners = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostModeGameOverMessage winArwards.
             * @member {Array.<pb.IRewardItem>} winArwards
             * @memberof pb.GhostModeGameOverMessage
             * @instance
             */
            GhostModeGameOverMessage.prototype.winArwards = $util.emptyArray;
    
            /**
             * GhostModeGameOverMessage lostArwards.
             * @member {Array.<pb.IRewardItem>} lostArwards
             * @memberof pb.GhostModeGameOverMessage
             * @instance
             */
            GhostModeGameOverMessage.prototype.lostArwards = $util.emptyArray;
    
            /**
             * GhostModeGameOverMessage winners.
             * @member {Array.<string>} winners
             * @memberof pb.GhostModeGameOverMessage
             * @instance
             */
            GhostModeGameOverMessage.prototype.winners = $util.emptyArray;
    
            /**
             * GhostModeGameOverMessage ghostScore.
             * @member {number} ghostScore
             * @memberof pb.GhostModeGameOverMessage
             * @instance
             */
            GhostModeGameOverMessage.prototype.ghostScore = 0;
    
            /**
             * GhostModeGameOverMessage userScore.
             * @member {number} userScore
             * @memberof pb.GhostModeGameOverMessage
             * @instance
             */
            GhostModeGameOverMessage.prototype.userScore = 0;
    
            /**
             * Creates a new GhostModeGameOverMessage instance using the specified properties.
             * @function create
             * @memberof pb.GhostModeGameOverMessage
             * @static
             * @param {pb.IGhostModeGameOverMessage=} [properties] Properties to set
             * @returns {pb.GhostModeGameOverMessage} GhostModeGameOverMessage instance
             */
            GhostModeGameOverMessage.create = function create(properties) {
                return new GhostModeGameOverMessage(properties);
            };
    
            /**
             * Encodes the specified GhostModeGameOverMessage message. Does not implicitly {@link pb.GhostModeGameOverMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostModeGameOverMessage
             * @static
             * @param {pb.IGhostModeGameOverMessage} message GhostModeGameOverMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostModeGameOverMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.winArwards != null && message.winArwards.length)
                    for (var i = 0; i < message.winArwards.length; ++i)
                        $root.pb.RewardItem.encode(message.winArwards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.lostArwards != null && message.lostArwards.length)
                    for (var i = 0; i < message.lostArwards.length; ++i)
                        $root.pb.RewardItem.encode(message.lostArwards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.winners != null && message.winners.length)
                    for (var i = 0; i < message.winners.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.winners[i]);
                if (message.ghostScore != null && Object.hasOwnProperty.call(message, "ghostScore"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ghostScore);
                if (message.userScore != null && Object.hasOwnProperty.call(message, "userScore"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.userScore);
                return writer;
            };
    
            /**
             * Decodes a GhostModeGameOverMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostModeGameOverMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostModeGameOverMessage} GhostModeGameOverMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostModeGameOverMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostModeGameOverMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.winArwards && message.winArwards.length))
                            message.winArwards = [];
                        message.winArwards.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.lostArwards && message.lostArwards.length))
                            message.lostArwards = [];
                        message.lostArwards.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.winners && message.winners.length))
                            message.winners = [];
                        message.winners.push(reader.string());
                        break;
                    case 4:
                        message.ghostScore = reader.int32();
                        break;
                    case 5:
                        message.userScore = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostModeGameOverMessage;
        })();
    
        pb.GameOverRes = (function() {
    
            /**
             * Properties of a GameOverRes.
             * @memberof pb
             * @interface IGameOverRes
             * @property {number|null} [code] GameOverRes code
             * @property {string|null} [msg] GameOverRes msg
             * @property {pb.IGameOverResData|null} [data] GameOverRes data
             */
    
            /**
             * Constructs a new GameOverRes.
             * @memberof pb
             * @classdesc Represents a GameOverRes.
             * @implements IGameOverRes
             * @constructor
             * @param {pb.IGameOverRes=} [properties] Properties to set
             */
            function GameOverRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GameOverRes code.
             * @member {number} code
             * @memberof pb.GameOverRes
             * @instance
             */
            GameOverRes.prototype.code = 0;
    
            /**
             * GameOverRes msg.
             * @member {string} msg
             * @memberof pb.GameOverRes
             * @instance
             */
            GameOverRes.prototype.msg = "";
    
            /**
             * GameOverRes data.
             * @member {pb.IGameOverResData|null|undefined} data
             * @memberof pb.GameOverRes
             * @instance
             */
            GameOverRes.prototype.data = null;
    
            /**
             * Creates a new GameOverRes instance using the specified properties.
             * @function create
             * @memberof pb.GameOverRes
             * @static
             * @param {pb.IGameOverRes=} [properties] Properties to set
             * @returns {pb.GameOverRes} GameOverRes instance
             */
            GameOverRes.create = function create(properties) {
                return new GameOverRes(properties);
            };
    
            /**
             * Encodes the specified GameOverRes message. Does not implicitly {@link pb.GameOverRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GameOverRes
             * @static
             * @param {pb.IGameOverRes} message GameOverRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameOverRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.GameOverResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GameOverRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GameOverRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GameOverRes} GameOverRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameOverRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GameOverRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.GameOverResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GameOverRes;
        })();
    
        pb.GameOverResData = (function() {
    
            /**
             * Properties of a GameOverResData.
             * @memberof pb
             * @interface IGameOverResData
             * @property {string|null} [reason] GameOverResData reason
             * @property {string|null} [winUid] GameOverResData winUid
             * @property {string|null} [winTeamid] GameOverResData winTeamid
             * @property {pb.IGameResult|null} [result] GameOverResData result
             * @property {number|null} [grade] GameOverResData grade
             * @property {number|null} [gameType] GameOverResData gameType
             * @property {Array.<pb.IUserLevelMessage>|null} [userMessages] GameOverResData userMessages
             * @property {Array.<pb.IUserData>|null} [userData] GameOverResData userData
             * @property {boolean|null} [needQueryAiInvite] GameOverResData needQueryAiInvite
             * @property {number|null} [winnerMuti] GameOverResData winnerMuti
             * @property {string|null} [videoId] GameOverResData videoId
             * @property {pb.IRaceGameOverMessage|null} [message] GameOverResData message
             * @property {number|null} [gameMode] GameOverResData gameMode
             * @property {pb.ISixModeGameOverMessage|null} [sixmodeMessage] GameOverResData sixmodeMessage
             * @property {pb.IGhostModeGameOverMessage|null} [ghostModeMessage] GameOverResData ghostModeMessage
             */
    
            /**
             * Constructs a new GameOverResData.
             * @memberof pb
             * @classdesc Represents a GameOverResData.
             * @implements IGameOverResData
             * @constructor
             * @param {pb.IGameOverResData=} [properties] Properties to set
             */
            function GameOverResData(properties) {
                this.userMessages = [];
                this.userData = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GameOverResData reason.
             * @member {string} reason
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.reason = "";
    
            /**
             * GameOverResData winUid.
             * @member {string} winUid
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.winUid = "";
    
            /**
             * GameOverResData winTeamid.
             * @member {string} winTeamid
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.winTeamid = "";
    
            /**
             * GameOverResData result.
             * @member {pb.IGameResult|null|undefined} result
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.result = null;
    
            /**
             * GameOverResData grade.
             * @member {number} grade
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.grade = 0;
    
            /**
             * GameOverResData gameType.
             * @member {number} gameType
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.gameType = 0;
    
            /**
             * GameOverResData userMessages.
             * @member {Array.<pb.IUserLevelMessage>} userMessages
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.userMessages = $util.emptyArray;
    
            /**
             * GameOverResData userData.
             * @member {Array.<pb.IUserData>} userData
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.userData = $util.emptyArray;
    
            /**
             * GameOverResData needQueryAiInvite.
             * @member {boolean} needQueryAiInvite
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.needQueryAiInvite = false;
    
            /**
             * GameOverResData winnerMuti.
             * @member {number} winnerMuti
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.winnerMuti = 0;
    
            /**
             * GameOverResData videoId.
             * @member {string} videoId
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.videoId = "";
    
            /**
             * GameOverResData message.
             * @member {pb.IRaceGameOverMessage|null|undefined} message
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.message = null;
    
            /**
             * GameOverResData gameMode.
             * @member {number} gameMode
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.gameMode = 0;
    
            /**
             * GameOverResData sixmodeMessage.
             * @member {pb.ISixModeGameOverMessage|null|undefined} sixmodeMessage
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.sixmodeMessage = null;
    
            /**
             * GameOverResData ghostModeMessage.
             * @member {pb.IGhostModeGameOverMessage|null|undefined} ghostModeMessage
             * @memberof pb.GameOverResData
             * @instance
             */
            GameOverResData.prototype.ghostModeMessage = null;
    
            /**
             * Creates a new GameOverResData instance using the specified properties.
             * @function create
             * @memberof pb.GameOverResData
             * @static
             * @param {pb.IGameOverResData=} [properties] Properties to set
             * @returns {pb.GameOverResData} GameOverResData instance
             */
            GameOverResData.create = function create(properties) {
                return new GameOverResData(properties);
            };
    
            /**
             * Encodes the specified GameOverResData message. Does not implicitly {@link pb.GameOverResData.verify|verify} messages.
             * @function encode
             * @memberof pb.GameOverResData
             * @static
             * @param {pb.IGameOverResData} message GameOverResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameOverResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
                if (message.winUid != null && Object.hasOwnProperty.call(message, "winUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.winUid);
                if (message.winTeamid != null && Object.hasOwnProperty.call(message, "winTeamid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.winTeamid);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    $root.pb.GameResult.encode(message.result, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.grade);
                if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.gameType);
                if (message.userMessages != null && message.userMessages.length)
                    for (var i = 0; i < message.userMessages.length; ++i)
                        $root.pb.UserLevelMessage.encode(message.userMessages[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.userData != null && message.userData.length)
                    for (var i = 0; i < message.userData.length; ++i)
                        $root.pb.UserData.encode(message.userData[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.needQueryAiInvite != null && Object.hasOwnProperty.call(message, "needQueryAiInvite"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.needQueryAiInvite);
                if (message.winnerMuti != null && Object.hasOwnProperty.call(message, "winnerMuti"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.winnerMuti);
                if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.videoId);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.pb.RaceGameOverMessage.encode(message.message, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.gameMode);
                if (message.sixmodeMessage != null && Object.hasOwnProperty.call(message, "sixmodeMessage"))
                    $root.pb.SixModeGameOverMessage.encode(message.sixmodeMessage, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.ghostModeMessage != null && Object.hasOwnProperty.call(message, "ghostModeMessage"))
                    $root.pb.GhostModeGameOverMessage.encode(message.ghostModeMessage, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GameOverResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GameOverResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GameOverResData} GameOverResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameOverResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GameOverResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.reason = reader.string();
                        break;
                    case 2:
                        message.winUid = reader.string();
                        break;
                    case 3:
                        message.winTeamid = reader.string();
                        break;
                    case 4:
                        message.result = $root.pb.GameResult.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.grade = reader.int32();
                        break;
                    case 6:
                        message.gameType = reader.int32();
                        break;
                    case 7:
                        if (!(message.userMessages && message.userMessages.length))
                            message.userMessages = [];
                        message.userMessages.push($root.pb.UserLevelMessage.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.userData && message.userData.length))
                            message.userData = [];
                        message.userData.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 9:
                        message.needQueryAiInvite = reader.bool();
                        break;
                    case 10:
                        message.winnerMuti = reader.int32();
                        break;
                    case 11:
                        message.videoId = reader.string();
                        break;
                    case 12:
                        message.message = $root.pb.RaceGameOverMessage.decode(reader, reader.uint32());
                        break;
                    case 13:
                        message.gameMode = reader.int32();
                        break;
                    case 14:
                        message.sixmodeMessage = $root.pb.SixModeGameOverMessage.decode(reader, reader.uint32());
                        break;
                    case 15:
                        message.ghostModeMessage = $root.pb.GhostModeGameOverMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GameOverResData;
        })();
    
        pb.UserLevelMessage = (function() {
    
            /**
             * Properties of a UserLevelMessage.
             * @memberof pb
             * @interface IUserLevelMessage
             * @property {string|null} [uid] UserLevelMessage uid
             * @property {pb.ILevelMessage|null} [pre] UserLevelMessage pre
             * @property {pb.ILevelMessage|null} [cur] UserLevelMessage cur
             */
    
            /**
             * Constructs a new UserLevelMessage.
             * @memberof pb
             * @classdesc Represents a UserLevelMessage.
             * @implements IUserLevelMessage
             * @constructor
             * @param {pb.IUserLevelMessage=} [properties] Properties to set
             */
            function UserLevelMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UserLevelMessage uid.
             * @member {string} uid
             * @memberof pb.UserLevelMessage
             * @instance
             */
            UserLevelMessage.prototype.uid = "";
    
            /**
             * UserLevelMessage pre.
             * @member {pb.ILevelMessage|null|undefined} pre
             * @memberof pb.UserLevelMessage
             * @instance
             */
            UserLevelMessage.prototype.pre = null;
    
            /**
             * UserLevelMessage cur.
             * @member {pb.ILevelMessage|null|undefined} cur
             * @memberof pb.UserLevelMessage
             * @instance
             */
            UserLevelMessage.prototype.cur = null;
    
            /**
             * Creates a new UserLevelMessage instance using the specified properties.
             * @function create
             * @memberof pb.UserLevelMessage
             * @static
             * @param {pb.IUserLevelMessage=} [properties] Properties to set
             * @returns {pb.UserLevelMessage} UserLevelMessage instance
             */
            UserLevelMessage.create = function create(properties) {
                return new UserLevelMessage(properties);
            };
    
            /**
             * Encodes the specified UserLevelMessage message. Does not implicitly {@link pb.UserLevelMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.UserLevelMessage
             * @static
             * @param {pb.IUserLevelMessage} message UserLevelMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserLevelMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.pre != null && Object.hasOwnProperty.call(message, "pre"))
                    $root.pb.LevelMessage.encode(message.pre, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cur != null && Object.hasOwnProperty.call(message, "cur"))
                    $root.pb.LevelMessage.encode(message.cur, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a UserLevelMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.UserLevelMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.UserLevelMessage} UserLevelMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserLevelMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UserLevelMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.pre = $root.pb.LevelMessage.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.cur = $root.pb.LevelMessage.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return UserLevelMessage;
        })();
    
        pb.GameResult = (function() {
    
            /**
             * Properties of a GameResult.
             * @memberof pb
             * @interface IGameResult
             * @property {number|null} [timestamp] GameResult timestamp
             * @property {string|null} [nonstr] GameResult nonstr
             * @property {string|null} [sign] GameResult sign
             * @property {string|null} [gametype] GameResult gametype
             * @property {pb.IGameResultDetail|null} [result] GameResult result
             */
    
            /**
             * Constructs a new GameResult.
             * @memberof pb
             * @classdesc Represents a GameResult.
             * @implements IGameResult
             * @constructor
             * @param {pb.IGameResult=} [properties] Properties to set
             */
            function GameResult(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GameResult timestamp.
             * @member {number} timestamp
             * @memberof pb.GameResult
             * @instance
             */
            GameResult.prototype.timestamp = 0;
    
            /**
             * GameResult nonstr.
             * @member {string} nonstr
             * @memberof pb.GameResult
             * @instance
             */
            GameResult.prototype.nonstr = "";
    
            /**
             * GameResult sign.
             * @member {string} sign
             * @memberof pb.GameResult
             * @instance
             */
            GameResult.prototype.sign = "";
    
            /**
             * GameResult gametype.
             * @member {string} gametype
             * @memberof pb.GameResult
             * @instance
             */
            GameResult.prototype.gametype = "";
    
            /**
             * GameResult result.
             * @member {pb.IGameResultDetail|null|undefined} result
             * @memberof pb.GameResult
             * @instance
             */
            GameResult.prototype.result = null;
    
            /**
             * Creates a new GameResult instance using the specified properties.
             * @function create
             * @memberof pb.GameResult
             * @static
             * @param {pb.IGameResult=} [properties] Properties to set
             * @returns {pb.GameResult} GameResult instance
             */
            GameResult.create = function create(properties) {
                return new GameResult(properties);
            };
    
            /**
             * Encodes the specified GameResult message. Does not implicitly {@link pb.GameResult.verify|verify} messages.
             * @function encode
             * @memberof pb.GameResult
             * @static
             * @param {pb.IGameResult} message GameResult message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameResult.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.timestamp);
                if (message.nonstr != null && Object.hasOwnProperty.call(message, "nonstr"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nonstr);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sign);
                if (message.gametype != null && Object.hasOwnProperty.call(message, "gametype"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.gametype);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    $root.pb.GameResultDetail.encode(message.result, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GameResult message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GameResult
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GameResult} GameResult
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameResult.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GameResult();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.timestamp = reader.int32();
                        break;
                    case 2:
                        message.nonstr = reader.string();
                        break;
                    case 3:
                        message.sign = reader.string();
                        break;
                    case 4:
                        message.gametype = reader.string();
                        break;
                    case 5:
                        message.result = $root.pb.GameResultDetail.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GameResult;
        })();
    
        pb.GameResultDetail = (function() {
    
            /**
             * Properties of a GameResultDetail.
             * @memberof pb
             * @interface IGameResultDetail
             * @property {string|null} [gameid] GameResultDetail gameid
             * @property {string|null} [roomid] GameResultDetail roomid
             * @property {string|null} [channelid] GameResultDetail channelid
             * @property {string|null} [resulttype] GameResultDetail resulttype
             * @property {Array.<string>|null} [users] GameResultDetail users
             * @property {Array.<string>|null} [winners] GameResultDetail winners
             * @property {Array.<string>|null} [jifen] GameResultDetail jifen
             * @property {number|null} [subgamemode] GameResultDetail subgamemode
             * @property {number|null} [juci] GameResultDetail juci
             * @property {Array.<string>|null} [hallId] GameResultDetail hallId
             */
    
            /**
             * Constructs a new GameResultDetail.
             * @memberof pb
             * @classdesc Represents a GameResultDetail.
             * @implements IGameResultDetail
             * @constructor
             * @param {pb.IGameResultDetail=} [properties] Properties to set
             */
            function GameResultDetail(properties) {
                this.users = [];
                this.winners = [];
                this.jifen = [];
                this.hallId = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GameResultDetail gameid.
             * @member {string} gameid
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.gameid = "";
    
            /**
             * GameResultDetail roomid.
             * @member {string} roomid
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.roomid = "";
    
            /**
             * GameResultDetail channelid.
             * @member {string} channelid
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.channelid = "";
    
            /**
             * GameResultDetail resulttype.
             * @member {string} resulttype
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.resulttype = "";
    
            /**
             * GameResultDetail users.
             * @member {Array.<string>} users
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.users = $util.emptyArray;
    
            /**
             * GameResultDetail winners.
             * @member {Array.<string>} winners
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.winners = $util.emptyArray;
    
            /**
             * GameResultDetail jifen.
             * @member {Array.<string>} jifen
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.jifen = $util.emptyArray;
    
            /**
             * GameResultDetail subgamemode.
             * @member {number} subgamemode
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.subgamemode = 0;
    
            /**
             * GameResultDetail juci.
             * @member {number} juci
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.juci = 0;
    
            /**
             * GameResultDetail hallId.
             * @member {Array.<string>} hallId
             * @memberof pb.GameResultDetail
             * @instance
             */
            GameResultDetail.prototype.hallId = $util.emptyArray;
    
            /**
             * Creates a new GameResultDetail instance using the specified properties.
             * @function create
             * @memberof pb.GameResultDetail
             * @static
             * @param {pb.IGameResultDetail=} [properties] Properties to set
             * @returns {pb.GameResultDetail} GameResultDetail instance
             */
            GameResultDetail.create = function create(properties) {
                return new GameResultDetail(properties);
            };
    
            /**
             * Encodes the specified GameResultDetail message. Does not implicitly {@link pb.GameResultDetail.verify|verify} messages.
             * @function encode
             * @memberof pb.GameResultDetail
             * @static
             * @param {pb.IGameResultDetail} message GameResultDetail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameResultDetail.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.gameid != null && Object.hasOwnProperty.call(message, "gameid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.gameid);
                if (message.roomid != null && Object.hasOwnProperty.call(message, "roomid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomid);
                if (message.channelid != null && Object.hasOwnProperty.call(message, "channelid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channelid);
                if (message.resulttype != null && Object.hasOwnProperty.call(message, "resulttype"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.resulttype);
                if (message.users != null && message.users.length)
                    for (var i = 0; i < message.users.length; ++i)
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.users[i]);
                if (message.winners != null && message.winners.length)
                    for (var i = 0; i < message.winners.length; ++i)
                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.winners[i]);
                if (message.jifen != null && message.jifen.length)
                    for (var i = 0; i < message.jifen.length; ++i)
                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.jifen[i]);
                if (message.subgamemode != null && Object.hasOwnProperty.call(message, "subgamemode"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.subgamemode);
                if (message.juci != null && Object.hasOwnProperty.call(message, "juci"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.juci);
                if (message.hallId != null && message.hallId.length)
                    for (var i = 0; i < message.hallId.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.hallId[i]);
                return writer;
            };
    
            /**
             * Decodes a GameResultDetail message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GameResultDetail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GameResultDetail} GameResultDetail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameResultDetail.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GameResultDetail();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.gameid = reader.string();
                        break;
                    case 2:
                        message.roomid = reader.string();
                        break;
                    case 3:
                        message.channelid = reader.string();
                        break;
                    case 4:
                        message.resulttype = reader.string();
                        break;
                    case 5:
                        if (!(message.users && message.users.length))
                            message.users = [];
                        message.users.push(reader.string());
                        break;
                    case 6:
                        if (!(message.winners && message.winners.length))
                            message.winners = [];
                        message.winners.push(reader.string());
                        break;
                    case 7:
                        if (!(message.jifen && message.jifen.length))
                            message.jifen = [];
                        message.jifen.push(reader.string());
                        break;
                    case 8:
                        message.subgamemode = reader.int32();
                        break;
                    case 9:
                        message.juci = reader.int32();
                        break;
                    case 10:
                        if (!(message.hallId && message.hallId.length))
                            message.hallId = [];
                        message.hallId.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GameResultDetail;
        })();
    
        pb.TeamsDetail = (function() {
    
            /**
             * Properties of a TeamsDetail.
             * @memberof pb
             * @interface ITeamsDetail
             * @property {string|null} [teamid] TeamsDetail teamid
             * @property {Array.<string>|null} [uids] TeamsDetail uids
             */
    
            /**
             * Constructs a new TeamsDetail.
             * @memberof pb
             * @classdesc Represents a TeamsDetail.
             * @implements ITeamsDetail
             * @constructor
             * @param {pb.ITeamsDetail=} [properties] Properties to set
             */
            function TeamsDetail(properties) {
                this.uids = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TeamsDetail teamid.
             * @member {string} teamid
             * @memberof pb.TeamsDetail
             * @instance
             */
            TeamsDetail.prototype.teamid = "";
    
            /**
             * TeamsDetail uids.
             * @member {Array.<string>} uids
             * @memberof pb.TeamsDetail
             * @instance
             */
            TeamsDetail.prototype.uids = $util.emptyArray;
    
            /**
             * Creates a new TeamsDetail instance using the specified properties.
             * @function create
             * @memberof pb.TeamsDetail
             * @static
             * @param {pb.ITeamsDetail=} [properties] Properties to set
             * @returns {pb.TeamsDetail} TeamsDetail instance
             */
            TeamsDetail.create = function create(properties) {
                return new TeamsDetail(properties);
            };
    
            /**
             * Encodes the specified TeamsDetail message. Does not implicitly {@link pb.TeamsDetail.verify|verify} messages.
             * @function encode
             * @memberof pb.TeamsDetail
             * @static
             * @param {pb.ITeamsDetail} message TeamsDetail message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TeamsDetail.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.teamid != null && Object.hasOwnProperty.call(message, "teamid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.teamid);
                if (message.uids != null && message.uids.length)
                    for (var i = 0; i < message.uids.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.uids[i]);
                return writer;
            };
    
            /**
             * Decodes a TeamsDetail message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TeamsDetail
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TeamsDetail} TeamsDetail
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TeamsDetail.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TeamsDetail();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.teamid = reader.string();
                        break;
                    case 2:
                        if (!(message.uids && message.uids.length))
                            message.uids = [];
                        message.uids.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TeamsDetail;
        })();
    
        pb.ReLoginRes = (function() {
    
            /**
             * Properties of a ReLoginRes.
             * @memberof pb
             * @interface IReLoginRes
             * @property {number|null} [code] ReLoginRes code
             * @property {string|null} [msg] ReLoginRes msg
             * @property {pb.IReLoginResData|null} [data] ReLoginRes data
             */
    
            /**
             * Constructs a new ReLoginRes.
             * @memberof pb
             * @classdesc Represents a ReLoginRes.
             * @implements IReLoginRes
             * @constructor
             * @param {pb.IReLoginRes=} [properties] Properties to set
             */
            function ReLoginRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReLoginRes code.
             * @member {number} code
             * @memberof pb.ReLoginRes
             * @instance
             */
            ReLoginRes.prototype.code = 0;
    
            /**
             * ReLoginRes msg.
             * @member {string} msg
             * @memberof pb.ReLoginRes
             * @instance
             */
            ReLoginRes.prototype.msg = "";
    
            /**
             * ReLoginRes data.
             * @member {pb.IReLoginResData|null|undefined} data
             * @memberof pb.ReLoginRes
             * @instance
             */
            ReLoginRes.prototype.data = null;
    
            /**
             * Creates a new ReLoginRes instance using the specified properties.
             * @function create
             * @memberof pb.ReLoginRes
             * @static
             * @param {pb.IReLoginRes=} [properties] Properties to set
             * @returns {pb.ReLoginRes} ReLoginRes instance
             */
            ReLoginRes.create = function create(properties) {
                return new ReLoginRes(properties);
            };
    
            /**
             * Encodes the specified ReLoginRes message. Does not implicitly {@link pb.ReLoginRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ReLoginRes
             * @static
             * @param {pb.IReLoginRes} message ReLoginRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReLoginRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.ReLoginResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a ReLoginRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReLoginRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReLoginRes} ReLoginRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReLoginRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReLoginRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.ReLoginResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReLoginRes;
        })();
    
        pb.ReLoginResData = (function() {
    
            /**
             * Properties of a ReLoginResData.
             * @memberof pb
             * @interface IReLoginResData
             * @property {string|null} [stage] ReLoginResData stage
             * @property {string|null} [curuid] ReLoginResData curuid
             * @property {number|null} [dicenum] ReLoginResData dicenum
             * @property {string|null} [ai_config] ReLoginResData ai_config
             * @property {Array.<pb.IFlyer>|null} [flyer] ReLoginResData flyer
             * @property {pb.IChessBoard|null} [chessboard] ReLoginResData chessboard
             * @property {number|null} [roundEndTime] ReLoginResData roundEndTime
             * @property {pb.DiceNumResType|null} [dicetype] ReLoginResData dicetype
             * @property {Array.<pb.IPlayer>|null} [players] ReLoginResData players
             * @property {number|null} [coin] ReLoginResData coin
             * @property {number|null} [gameMode] ReLoginResData gameMode
             * @property {number|null} [leftSecond] ReLoginResData leftSecond
             * @property {Array.<pb.IUserData>|null} [userDatas] ReLoginResData userDatas
             * @property {number|null} [loseCoin] ReLoginResData loseCoin
             * @property {number|null} [winCoin] ReLoginResData winCoin
             */
    
            /**
             * Constructs a new ReLoginResData.
             * @memberof pb
             * @classdesc Represents a ReLoginResData.
             * @implements IReLoginResData
             * @constructor
             * @param {pb.IReLoginResData=} [properties] Properties to set
             */
            function ReLoginResData(properties) {
                this.flyer = [];
                this.players = [];
                this.userDatas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReLoginResData stage.
             * @member {string} stage
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.stage = "";
    
            /**
             * ReLoginResData curuid.
             * @member {string} curuid
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.curuid = "";
    
            /**
             * ReLoginResData dicenum.
             * @member {number} dicenum
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.dicenum = 0;
    
            /**
             * ReLoginResData ai_config.
             * @member {string} ai_config
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.ai_config = "";
    
            /**
             * ReLoginResData flyer.
             * @member {Array.<pb.IFlyer>} flyer
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.flyer = $util.emptyArray;
    
            /**
             * ReLoginResData chessboard.
             * @member {pb.IChessBoard|null|undefined} chessboard
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.chessboard = null;
    
            /**
             * ReLoginResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReLoginResData dicetype.
             * @member {pb.DiceNumResType} dicetype
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.dicetype = 0;
    
            /**
             * ReLoginResData players.
             * @member {Array.<pb.IPlayer>} players
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.players = $util.emptyArray;
    
            /**
             * ReLoginResData coin.
             * @member {number} coin
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReLoginResData gameMode.
             * @member {number} gameMode
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.gameMode = 0;
    
            /**
             * ReLoginResData leftSecond.
             * @member {number} leftSecond
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.leftSecond = 0;
    
            /**
             * ReLoginResData userDatas.
             * @member {Array.<pb.IUserData>} userDatas
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.userDatas = $util.emptyArray;
    
            /**
             * ReLoginResData loseCoin.
             * @member {number} loseCoin
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.loseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReLoginResData winCoin.
             * @member {number} winCoin
             * @memberof pb.ReLoginResData
             * @instance
             */
            ReLoginResData.prototype.winCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new ReLoginResData instance using the specified properties.
             * @function create
             * @memberof pb.ReLoginResData
             * @static
             * @param {pb.IReLoginResData=} [properties] Properties to set
             * @returns {pb.ReLoginResData} ReLoginResData instance
             */
            ReLoginResData.create = function create(properties) {
                return new ReLoginResData(properties);
            };
    
            /**
             * Encodes the specified ReLoginResData message. Does not implicitly {@link pb.ReLoginResData.verify|verify} messages.
             * @function encode
             * @memberof pb.ReLoginResData
             * @static
             * @param {pb.IReLoginResData} message ReLoginResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReLoginResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stage);
                if (message.curuid != null && Object.hasOwnProperty.call(message, "curuid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.curuid);
                if (message.dicenum != null && Object.hasOwnProperty.call(message, "dicenum"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.dicenum);
                if (message.ai_config != null && Object.hasOwnProperty.call(message, "ai_config"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.ai_config);
                if (message.flyer != null && message.flyer.length)
                    for (var i = 0; i < message.flyer.length; ++i)
                        $root.pb.Flyer.encode(message.flyer[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.chessboard != null && Object.hasOwnProperty.call(message, "chessboard"))
                    $root.pb.ChessBoard.encode(message.chessboard, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.roundEndTime);
                if (message.dicetype != null && Object.hasOwnProperty.call(message, "dicetype"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.dicetype);
                if (message.players != null && message.players.length)
                    for (var i = 0; i < message.players.length; ++i)
                        $root.pb.Player.encode(message.players[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.coin);
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gameMode);
                if (message.leftSecond != null && Object.hasOwnProperty.call(message, "leftSecond"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.leftSecond);
                if (message.userDatas != null && message.userDatas.length)
                    for (var i = 0; i < message.userDatas.length; ++i)
                        $root.pb.UserData.encode(message.userDatas[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.loseCoin != null && Object.hasOwnProperty.call(message, "loseCoin"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.loseCoin);
                if (message.winCoin != null && Object.hasOwnProperty.call(message, "winCoin"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int64(message.winCoin);
                return writer;
            };
    
            /**
             * Decodes a ReLoginResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReLoginResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReLoginResData} ReLoginResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReLoginResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReLoginResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stage = reader.string();
                        break;
                    case 2:
                        message.curuid = reader.string();
                        break;
                    case 3:
                        message.dicenum = reader.int32();
                        break;
                    case 4:
                        message.ai_config = reader.string();
                        break;
                    case 5:
                        if (!(message.flyer && message.flyer.length))
                            message.flyer = [];
                        message.flyer.push($root.pb.Flyer.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.chessboard = $root.pb.ChessBoard.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.roundEndTime = reader.int64();
                        break;
                    case 8:
                        message.dicetype = reader.int32();
                        break;
                    case 9:
                        if (!(message.players && message.players.length))
                            message.players = [];
                        message.players.push($root.pb.Player.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.coin = reader.int64();
                        break;
                    case 11:
                        message.gameMode = reader.int32();
                        break;
                    case 12:
                        message.leftSecond = reader.int32();
                        break;
                    case 13:
                        if (!(message.userDatas && message.userDatas.length))
                            message.userDatas = [];
                        message.userDatas.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        message.loseCoin = reader.int64();
                        break;
                    case 15:
                        message.winCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReLoginResData;
        })();
    
        pb.DiceNumReq = (function() {
    
            /**
             * Properties of a DiceNumReq.
             * @memberof pb
             * @interface IDiceNumReq
             * @property {number|null} [num] DiceNumReq num
             */
    
            /**
             * Constructs a new DiceNumReq.
             * @memberof pb
             * @classdesc Represents a DiceNumReq.
             * @implements IDiceNumReq
             * @constructor
             * @param {pb.IDiceNumReq=} [properties] Properties to set
             */
            function DiceNumReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DiceNumReq num.
             * @member {number} num
             * @memberof pb.DiceNumReq
             * @instance
             */
            DiceNumReq.prototype.num = 0;
    
            /**
             * Creates a new DiceNumReq instance using the specified properties.
             * @function create
             * @memberof pb.DiceNumReq
             * @static
             * @param {pb.IDiceNumReq=} [properties] Properties to set
             * @returns {pb.DiceNumReq} DiceNumReq instance
             */
            DiceNumReq.create = function create(properties) {
                return new DiceNumReq(properties);
            };
    
            /**
             * Encodes the specified DiceNumReq message. Does not implicitly {@link pb.DiceNumReq.verify|verify} messages.
             * @function encode
             * @memberof pb.DiceNumReq
             * @static
             * @param {pb.IDiceNumReq} message DiceNumReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceNumReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                return writer;
            };
    
            /**
             * Decodes a DiceNumReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DiceNumReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DiceNumReq} DiceNumReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceNumReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiceNumReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DiceNumReq;
        })();
    
        pb.DiceNumRes = (function() {
    
            /**
             * Properties of a DiceNumRes.
             * @memberof pb
             * @interface IDiceNumRes
             * @property {number|null} [code] DiceNumRes code
             * @property {string|null} [msg] DiceNumRes msg
             * @property {pb.IDiceNumData|null} [data] DiceNumRes data
             */
    
            /**
             * Constructs a new DiceNumRes.
             * @memberof pb
             * @classdesc Represents a DiceNumRes.
             * @implements IDiceNumRes
             * @constructor
             * @param {pb.IDiceNumRes=} [properties] Properties to set
             */
            function DiceNumRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DiceNumRes code.
             * @member {number} code
             * @memberof pb.DiceNumRes
             * @instance
             */
            DiceNumRes.prototype.code = 0;
    
            /**
             * DiceNumRes msg.
             * @member {string} msg
             * @memberof pb.DiceNumRes
             * @instance
             */
            DiceNumRes.prototype.msg = "";
    
            /**
             * DiceNumRes data.
             * @member {pb.IDiceNumData|null|undefined} data
             * @memberof pb.DiceNumRes
             * @instance
             */
            DiceNumRes.prototype.data = null;
    
            /**
             * Creates a new DiceNumRes instance using the specified properties.
             * @function create
             * @memberof pb.DiceNumRes
             * @static
             * @param {pb.IDiceNumRes=} [properties] Properties to set
             * @returns {pb.DiceNumRes} DiceNumRes instance
             */
            DiceNumRes.create = function create(properties) {
                return new DiceNumRes(properties);
            };
    
            /**
             * Encodes the specified DiceNumRes message. Does not implicitly {@link pb.DiceNumRes.verify|verify} messages.
             * @function encode
             * @memberof pb.DiceNumRes
             * @static
             * @param {pb.IDiceNumRes} message DiceNumRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceNumRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.DiceNumData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a DiceNumRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DiceNumRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DiceNumRes} DiceNumRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceNumRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiceNumRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.DiceNumData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DiceNumRes;
        })();
    
        pb.DiceNumData = (function() {
    
            /**
             * Properties of a DiceNumData.
             * @memberof pb
             * @interface IDiceNumData
             * @property {number|null} [num] DiceNumData num
             * @property {number|null} [roundEndTime] DiceNumData roundEndTime
             * @property {pb.DiceNumResType|null} [type] DiceNumData type
             */
    
            /**
             * Constructs a new DiceNumData.
             * @memberof pb
             * @classdesc Represents a DiceNumData.
             * @implements IDiceNumData
             * @constructor
             * @param {pb.IDiceNumData=} [properties] Properties to set
             */
            function DiceNumData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DiceNumData num.
             * @member {number} num
             * @memberof pb.DiceNumData
             * @instance
             */
            DiceNumData.prototype.num = 0;
    
            /**
             * DiceNumData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.DiceNumData
             * @instance
             */
            DiceNumData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * DiceNumData type.
             * @member {pb.DiceNumResType} type
             * @memberof pb.DiceNumData
             * @instance
             */
            DiceNumData.prototype.type = 0;
    
            /**
             * Creates a new DiceNumData instance using the specified properties.
             * @function create
             * @memberof pb.DiceNumData
             * @static
             * @param {pb.IDiceNumData=} [properties] Properties to set
             * @returns {pb.DiceNumData} DiceNumData instance
             */
            DiceNumData.create = function create(properties) {
                return new DiceNumData(properties);
            };
    
            /**
             * Encodes the specified DiceNumData message. Does not implicitly {@link pb.DiceNumData.verify|verify} messages.
             * @function encode
             * @memberof pb.DiceNumData
             * @static
             * @param {pb.IDiceNumData} message DiceNumData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceNumData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roundEndTime);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                return writer;
            };
    
            /**
             * Decodes a DiceNumData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DiceNumData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DiceNumData} DiceNumData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceNumData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiceNumData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.roundEndTime = reader.int64();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DiceNumData;
        })();
    
        /**
         * DiceNumResType enum.
         * @name pb.DiceNumResType
         * @enum {number}
         * @property {number} COMMON=0 COMMON value
         * @property {number} FAIL666=1 FAIL666 value
         */
        pb.DiceNumResType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "COMMON"] = 0;
            values[valuesById[1] = "FAIL666"] = 1;
            return values;
        })();
    
        pb.MoveReq = (function() {
    
            /**
             * Properties of a MoveReq.
             * @memberof pb
             * @interface IMoveReq
             * @property {number|null} [color] MoveReq color
             * @property {number|null} [plane] MoveReq plane
             * @property {pb.MoveType|null} [type] MoveReq type
             * @property {number|null} [diceNum] MoveReq diceNum
             */
    
            /**
             * Constructs a new MoveReq.
             * @memberof pb
             * @classdesc Represents a MoveReq.
             * @implements IMoveReq
             * @constructor
             * @param {pb.IMoveReq=} [properties] Properties to set
             */
            function MoveReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MoveReq color.
             * @member {number} color
             * @memberof pb.MoveReq
             * @instance
             */
            MoveReq.prototype.color = 0;
    
            /**
             * MoveReq plane.
             * @member {number} plane
             * @memberof pb.MoveReq
             * @instance
             */
            MoveReq.prototype.plane = 0;
    
            /**
             * MoveReq type.
             * @member {pb.MoveType} type
             * @memberof pb.MoveReq
             * @instance
             */
            MoveReq.prototype.type = 0;
    
            /**
             * MoveReq diceNum.
             * @member {number} diceNum
             * @memberof pb.MoveReq
             * @instance
             */
            MoveReq.prototype.diceNum = 0;
    
            /**
             * Creates a new MoveReq instance using the specified properties.
             * @function create
             * @memberof pb.MoveReq
             * @static
             * @param {pb.IMoveReq=} [properties] Properties to set
             * @returns {pb.MoveReq} MoveReq instance
             */
            MoveReq.create = function create(properties) {
                return new MoveReq(properties);
            };
    
            /**
             * Encodes the specified MoveReq message. Does not implicitly {@link pb.MoveReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MoveReq
             * @static
             * @param {pb.IMoveReq} message MoveReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.diceNum != null && Object.hasOwnProperty.call(message, "diceNum"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.diceNum);
                return writer;
            };
    
            /**
             * Decodes a MoveReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MoveReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MoveReq} MoveReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MoveReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.diceNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MoveReq;
        })();
    
        /**
         * MoveType enum.
         * @name pb.MoveType
         * @enum {number}
         * @property {number} NORMAL=0 NORMAL value
         * @property {number} TAKEOFF=1 TAKEOFF value
         * @property {number} NOMOVE=2 NOMOVE value
         */
        pb.MoveType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NORMAL"] = 0;
            values[valuesById[1] = "TAKEOFF"] = 1;
            values[valuesById[2] = "NOMOVE"] = 2;
            return values;
        })();
    
        pb.CrashPlane = (function() {
    
            /**
             * Properties of a CrashPlane.
             * @memberof pb
             * @interface ICrashPlane
             * @property {number|null} [color] CrashPlane color
             * @property {number|null} [plane] CrashPlane plane
             * @property {number|null} [x] CrashPlane x
             * @property {number|null} [y] CrashPlane y
             * @property {number|null} [pos] CrashPlane pos
             */
    
            /**
             * Constructs a new CrashPlane.
             * @memberof pb
             * @classdesc Represents a CrashPlane.
             * @implements ICrashPlane
             * @constructor
             * @param {pb.ICrashPlane=} [properties] Properties to set
             */
            function CrashPlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CrashPlane color.
             * @member {number} color
             * @memberof pb.CrashPlane
             * @instance
             */
            CrashPlane.prototype.color = 0;
    
            /**
             * CrashPlane plane.
             * @member {number} plane
             * @memberof pb.CrashPlane
             * @instance
             */
            CrashPlane.prototype.plane = 0;
    
            /**
             * CrashPlane x.
             * @member {number} x
             * @memberof pb.CrashPlane
             * @instance
             */
            CrashPlane.prototype.x = 0;
    
            /**
             * CrashPlane y.
             * @member {number} y
             * @memberof pb.CrashPlane
             * @instance
             */
            CrashPlane.prototype.y = 0;
    
            /**
             * CrashPlane pos.
             * @member {number} pos
             * @memberof pb.CrashPlane
             * @instance
             */
            CrashPlane.prototype.pos = 0;
    
            /**
             * Creates a new CrashPlane instance using the specified properties.
             * @function create
             * @memberof pb.CrashPlane
             * @static
             * @param {pb.ICrashPlane=} [properties] Properties to set
             * @returns {pb.CrashPlane} CrashPlane instance
             */
            CrashPlane.create = function create(properties) {
                return new CrashPlane(properties);
            };
    
            /**
             * Encodes the specified CrashPlane message. Does not implicitly {@link pb.CrashPlane.verify|verify} messages.
             * @function encode
             * @memberof pb.CrashPlane
             * @static
             * @param {pb.ICrashPlane} message CrashPlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CrashPlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.y);
                if (message.pos != null && Object.hasOwnProperty.call(message, "pos"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.pos);
                return writer;
            };
    
            /**
             * Decodes a CrashPlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CrashPlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CrashPlane} CrashPlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CrashPlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CrashPlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.x = reader.int32();
                        break;
                    case 4:
                        message.y = reader.int32();
                        break;
                    case 5:
                        message.pos = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CrashPlane;
        })();
    
        pb.Position = (function() {
    
            /**
             * Properties of a Position.
             * @memberof pb
             * @interface IPosition
             * @property {number|null} [x] Position x
             * @property {number|null} [y] Position y
             */
    
            /**
             * Constructs a new Position.
             * @memberof pb
             * @classdesc Represents a Position.
             * @implements IPosition
             * @constructor
             * @param {pb.IPosition=} [properties] Properties to set
             */
            function Position(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Position x.
             * @member {number} x
             * @memberof pb.Position
             * @instance
             */
            Position.prototype.x = 0;
    
            /**
             * Position y.
             * @member {number} y
             * @memberof pb.Position
             * @instance
             */
            Position.prototype.y = 0;
    
            /**
             * Creates a new Position instance using the specified properties.
             * @function create
             * @memberof pb.Position
             * @static
             * @param {pb.IPosition=} [properties] Properties to set
             * @returns {pb.Position} Position instance
             */
            Position.create = function create(properties) {
                return new Position(properties);
            };
    
            /**
             * Encodes the specified Position message. Does not implicitly {@link pb.Position.verify|verify} messages.
             * @function encode
             * @memberof pb.Position
             * @static
             * @param {pb.IPosition} message Position message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Position.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
                return writer;
            };
    
            /**
             * Decodes a Position message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Position
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Position} Position
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Position.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Position();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.x = reader.int32();
                        break;
                    case 2:
                        message.y = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Position;
        })();
    
        pb.MoveRes = (function() {
    
            /**
             * Properties of a MoveRes.
             * @memberof pb
             * @interface IMoveRes
             * @property {number|null} [code] MoveRes code
             * @property {string|null} [msg] MoveRes msg
             * @property {pb.IMoveResData|null} [data] MoveRes data
             */
    
            /**
             * Constructs a new MoveRes.
             * @memberof pb
             * @classdesc Represents a MoveRes.
             * @implements IMoveRes
             * @constructor
             * @param {pb.IMoveRes=} [properties] Properties to set
             */
            function MoveRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MoveRes code.
             * @member {number} code
             * @memberof pb.MoveRes
             * @instance
             */
            MoveRes.prototype.code = 0;
    
            /**
             * MoveRes msg.
             * @member {string} msg
             * @memberof pb.MoveRes
             * @instance
             */
            MoveRes.prototype.msg = "";
    
            /**
             * MoveRes data.
             * @member {pb.IMoveResData|null|undefined} data
             * @memberof pb.MoveRes
             * @instance
             */
            MoveRes.prototype.data = null;
    
            /**
             * Creates a new MoveRes instance using the specified properties.
             * @function create
             * @memberof pb.MoveRes
             * @static
             * @param {pb.IMoveRes=} [properties] Properties to set
             * @returns {pb.MoveRes} MoveRes instance
             */
            MoveRes.create = function create(properties) {
                return new MoveRes(properties);
            };
    
            /**
             * Encodes the specified MoveRes message. Does not implicitly {@link pb.MoveRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MoveRes
             * @static
             * @param {pb.IMoveRes} message MoveRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.MoveResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a MoveRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MoveRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MoveRes} MoveRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MoveRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.MoveResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MoveRes;
        })();
    
        pb.MoveResData = (function() {
    
            /**
             * Properties of a MoveResData.
             * @memberof pb
             * @interface IMoveResData
             * @property {string|null} [uid] MoveResData uid
             * @property {pb.IPlane|null} [plane] MoveResData plane
             * @property {pb.IAirPortPlane|null} [airport_plane] MoveResData airport_plane
             * @property {pb.MoveType|null} [type] MoveResData type
             * @property {Array.<pb.ICrashPlane>|null} [crashPlanes] MoveResData crashPlanes
             * @property {string|null} [next_uid] MoveResData next_uid
             * @property {number|null} [roundEndTime] MoveResData roundEndTime
             * @property {number|null} [diceNum] MoveResData diceNum
             * @property {boolean|null} [extendRoundOn2v2] MoveResData extendRoundOn2v2
             */
    
            /**
             * Constructs a new MoveResData.
             * @memberof pb
             * @classdesc Represents a MoveResData.
             * @implements IMoveResData
             * @constructor
             * @param {pb.IMoveResData=} [properties] Properties to set
             */
            function MoveResData(properties) {
                this.crashPlanes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MoveResData uid.
             * @member {string} uid
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.uid = "";
    
            /**
             * MoveResData plane.
             * @member {pb.IPlane|null|undefined} plane
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.plane = null;
    
            /**
             * MoveResData airport_plane.
             * @member {pb.IAirPortPlane|null|undefined} airport_plane
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.airport_plane = null;
    
            /**
             * MoveResData type.
             * @member {pb.MoveType} type
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.type = 0;
    
            /**
             * MoveResData crashPlanes.
             * @member {Array.<pb.ICrashPlane>} crashPlanes
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.crashPlanes = $util.emptyArray;
    
            /**
             * MoveResData next_uid.
             * @member {string} next_uid
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.next_uid = "";
    
            /**
             * MoveResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MoveResData diceNum.
             * @member {number} diceNum
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.diceNum = 0;
    
            /**
             * MoveResData extendRoundOn2v2.
             * @member {boolean} extendRoundOn2v2
             * @memberof pb.MoveResData
             * @instance
             */
            MoveResData.prototype.extendRoundOn2v2 = false;
    
            /**
             * Creates a new MoveResData instance using the specified properties.
             * @function create
             * @memberof pb.MoveResData
             * @static
             * @param {pb.IMoveResData=} [properties] Properties to set
             * @returns {pb.MoveResData} MoveResData instance
             */
            MoveResData.create = function create(properties) {
                return new MoveResData(properties);
            };
    
            /**
             * Encodes the specified MoveResData message. Does not implicitly {@link pb.MoveResData.verify|verify} messages.
             * @function encode
             * @memberof pb.MoveResData
             * @static
             * @param {pb.IMoveResData} message MoveResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MoveResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    $root.pb.Plane.encode(message.plane, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.airport_plane != null && Object.hasOwnProperty.call(message, "airport_plane"))
                    $root.pb.AirPortPlane.encode(message.airport_plane, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                if (message.crashPlanes != null && message.crashPlanes.length)
                    for (var i = 0; i < message.crashPlanes.length; ++i)
                        $root.pb.CrashPlane.encode(message.crashPlanes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.next_uid != null && Object.hasOwnProperty.call(message, "next_uid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.next_uid);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.roundEndTime);
                if (message.diceNum != null && Object.hasOwnProperty.call(message, "diceNum"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.diceNum);
                if (message.extendRoundOn2v2 != null && Object.hasOwnProperty.call(message, "extendRoundOn2v2"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.extendRoundOn2v2);
                return writer;
            };
    
            /**
             * Decodes a MoveResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MoveResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MoveResData} MoveResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MoveResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MoveResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.plane = $root.pb.Plane.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.airport_plane = $root.pb.AirPortPlane.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    case 5:
                        if (!(message.crashPlanes && message.crashPlanes.length))
                            message.crashPlanes = [];
                        message.crashPlanes.push($root.pb.CrashPlane.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.next_uid = reader.string();
                        break;
                    case 7:
                        message.roundEndTime = reader.int64();
                        break;
                    case 8:
                        message.diceNum = reader.int32();
                        break;
                    case 9:
                        message.extendRoundOn2v2 = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MoveResData;
        })();
    
        pb.PlayExitReq = (function() {
    
            /**
             * Properties of a PlayExitReq.
             * @memberof pb
             * @interface IPlayExitReq
             */
    
            /**
             * Constructs a new PlayExitReq.
             * @memberof pb
             * @classdesc Represents a PlayExitReq.
             * @implements IPlayExitReq
             * @constructor
             * @param {pb.IPlayExitReq=} [properties] Properties to set
             */
            function PlayExitReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PlayExitReq instance using the specified properties.
             * @function create
             * @memberof pb.PlayExitReq
             * @static
             * @param {pb.IPlayExitReq=} [properties] Properties to set
             * @returns {pb.PlayExitReq} PlayExitReq instance
             */
            PlayExitReq.create = function create(properties) {
                return new PlayExitReq(properties);
            };
    
            /**
             * Encodes the specified PlayExitReq message. Does not implicitly {@link pb.PlayExitReq.verify|verify} messages.
             * @function encode
             * @memberof pb.PlayExitReq
             * @static
             * @param {pb.IPlayExitReq} message PlayExitReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayExitReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a PlayExitReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlayExitReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlayExitReq} PlayExitReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayExitReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayExitReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlayExitReq;
        })();
    
        pb.PlayExitRes = (function() {
    
            /**
             * Properties of a PlayExitRes.
             * @memberof pb
             * @interface IPlayExitRes
             * @property {number|null} [code] PlayExitRes code
             * @property {string|null} [msg] PlayExitRes msg
             * @property {string|null} [uid] PlayExitRes uid
             */
    
            /**
             * Constructs a new PlayExitRes.
             * @memberof pb
             * @classdesc Represents a PlayExitRes.
             * @implements IPlayExitRes
             * @constructor
             * @param {pb.IPlayExitRes=} [properties] Properties to set
             */
            function PlayExitRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayExitRes code.
             * @member {number} code
             * @memberof pb.PlayExitRes
             * @instance
             */
            PlayExitRes.prototype.code = 0;
    
            /**
             * PlayExitRes msg.
             * @member {string} msg
             * @memberof pb.PlayExitRes
             * @instance
             */
            PlayExitRes.prototype.msg = "";
    
            /**
             * PlayExitRes uid.
             * @member {string} uid
             * @memberof pb.PlayExitRes
             * @instance
             */
            PlayExitRes.prototype.uid = "";
    
            /**
             * Creates a new PlayExitRes instance using the specified properties.
             * @function create
             * @memberof pb.PlayExitRes
             * @static
             * @param {pb.IPlayExitRes=} [properties] Properties to set
             * @returns {pb.PlayExitRes} PlayExitRes instance
             */
            PlayExitRes.create = function create(properties) {
                return new PlayExitRes(properties);
            };
    
            /**
             * Encodes the specified PlayExitRes message. Does not implicitly {@link pb.PlayExitRes.verify|verify} messages.
             * @function encode
             * @memberof pb.PlayExitRes
             * @static
             * @param {pb.IPlayExitRes} message PlayExitRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayExitRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.uid);
                return writer;
            };
    
            /**
             * Decodes a PlayExitRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlayExitRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlayExitRes} PlayExitRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayExitRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayExitRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.uid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlayExitRes;
        })();
    
        pb.PlayReEnterRes = (function() {
    
            /**
             * Properties of a PlayReEnterRes.
             * @memberof pb
             * @interface IPlayReEnterRes
             * @property {number|null} [code] PlayReEnterRes code
             * @property {string|null} [msg] PlayReEnterRes msg
             * @property {string|null} [uid] PlayReEnterRes uid
             */
    
            /**
             * Constructs a new PlayReEnterRes.
             * @memberof pb
             * @classdesc Represents a PlayReEnterRes.
             * @implements IPlayReEnterRes
             * @constructor
             * @param {pb.IPlayReEnterRes=} [properties] Properties to set
             */
            function PlayReEnterRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayReEnterRes code.
             * @member {number} code
             * @memberof pb.PlayReEnterRes
             * @instance
             */
            PlayReEnterRes.prototype.code = 0;
    
            /**
             * PlayReEnterRes msg.
             * @member {string} msg
             * @memberof pb.PlayReEnterRes
             * @instance
             */
            PlayReEnterRes.prototype.msg = "";
    
            /**
             * PlayReEnterRes uid.
             * @member {string} uid
             * @memberof pb.PlayReEnterRes
             * @instance
             */
            PlayReEnterRes.prototype.uid = "";
    
            /**
             * Creates a new PlayReEnterRes instance using the specified properties.
             * @function create
             * @memberof pb.PlayReEnterRes
             * @static
             * @param {pb.IPlayReEnterRes=} [properties] Properties to set
             * @returns {pb.PlayReEnterRes} PlayReEnterRes instance
             */
            PlayReEnterRes.create = function create(properties) {
                return new PlayReEnterRes(properties);
            };
    
            /**
             * Encodes the specified PlayReEnterRes message. Does not implicitly {@link pb.PlayReEnterRes.verify|verify} messages.
             * @function encode
             * @memberof pb.PlayReEnterRes
             * @static
             * @param {pb.IPlayReEnterRes} message PlayReEnterRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayReEnterRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.uid);
                return writer;
            };
    
            /**
             * Decodes a PlayReEnterRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlayReEnterRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlayReEnterRes} PlayReEnterRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayReEnterRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayReEnterRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.uid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlayReEnterRes;
        })();
    
        pb.MatchReq = (function() {
    
            /**
             * Properties of a MatchReq.
             * @memberof pb
             * @interface IMatchReq
             * @property {number|null} [grade] MatchReq grade
             * @property {number|null} [gameType] MatchReq gameType
             * @property {string|null} [sn] MatchReq sn
             */
    
            /**
             * Constructs a new MatchReq.
             * @memberof pb
             * @classdesc Represents a MatchReq.
             * @implements IMatchReq
             * @constructor
             * @param {pb.IMatchReq=} [properties] Properties to set
             */
            function MatchReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchReq grade.
             * @member {number} grade
             * @memberof pb.MatchReq
             * @instance
             */
            MatchReq.prototype.grade = 0;
    
            /**
             * MatchReq gameType.
             * @member {number} gameType
             * @memberof pb.MatchReq
             * @instance
             */
            MatchReq.prototype.gameType = 0;
    
            /**
             * MatchReq sn.
             * @member {string} sn
             * @memberof pb.MatchReq
             * @instance
             */
            MatchReq.prototype.sn = "";
    
            /**
             * Creates a new MatchReq instance using the specified properties.
             * @function create
             * @memberof pb.MatchReq
             * @static
             * @param {pb.IMatchReq=} [properties] Properties to set
             * @returns {pb.MatchReq} MatchReq instance
             */
            MatchReq.create = function create(properties) {
                return new MatchReq(properties);
            };
    
            /**
             * Encodes the specified MatchReq message. Does not implicitly {@link pb.MatchReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchReq
             * @static
             * @param {pb.IMatchReq} message MatchReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grade);
                if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.gameType);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 100, wireType 2 =*/802).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a MatchReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchReq} MatchReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grade = reader.int32();
                        break;
                    case 2:
                        message.gameType = reader.int32();
                        break;
                    case 100:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchReq;
        })();
    
        pb.MatchRes = (function() {
    
            /**
             * Properties of a MatchRes.
             * @memberof pb
             * @interface IMatchRes
             * @property {number|null} [code] MatchRes code
             * @property {string|null} [roomId] MatchRes roomId
             * @property {number|null} [timestamp] MatchRes timestamp
             * @property {string|null} [opt] MatchRes opt
             * @property {string|null} [sign] MatchRes sign
             * @property {string|null} [problemUid] MatchRes problemUid
             * @property {number|null} [gameType] MatchRes gameType
             * @property {string|null} [sn] MatchRes sn
             */
    
            /**
             * Constructs a new MatchRes.
             * @memberof pb
             * @classdesc Represents a MatchRes.
             * @implements IMatchRes
             * @constructor
             * @param {pb.IMatchRes=} [properties] Properties to set
             */
            function MatchRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchRes code.
             * @member {number} code
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.code = 0;
    
            /**
             * MatchRes roomId.
             * @member {string} roomId
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.roomId = "";
    
            /**
             * MatchRes timestamp.
             * @member {number} timestamp
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MatchRes opt.
             * @member {string} opt
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.opt = "";
    
            /**
             * MatchRes sign.
             * @member {string} sign
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.sign = "";
    
            /**
             * MatchRes problemUid.
             * @member {string} problemUid
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.problemUid = "";
    
            /**
             * MatchRes gameType.
             * @member {number} gameType
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.gameType = 0;
    
            /**
             * MatchRes sn.
             * @member {string} sn
             * @memberof pb.MatchRes
             * @instance
             */
            MatchRes.prototype.sn = "";
    
            /**
             * Creates a new MatchRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchRes
             * @static
             * @param {pb.IMatchRes=} [properties] Properties to set
             * @returns {pb.MatchRes} MatchRes instance
             */
            MatchRes.create = function create(properties) {
                return new MatchRes(properties);
            };
    
            /**
             * Encodes the specified MatchRes message. Does not implicitly {@link pb.MatchRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchRes
             * @static
             * @param {pb.IMatchRes} message MatchRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);
                if (message.problemUid != null && Object.hasOwnProperty.call(message, "problemUid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.problemUid);
                if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.gameType);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 100, wireType 2 =*/802).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a MatchRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchRes} MatchRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.roomId = reader.string();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.opt = reader.string();
                        break;
                    case 5:
                        message.sign = reader.string();
                        break;
                    case 6:
                        message.problemUid = reader.string();
                        break;
                    case 7:
                        message.gameType = reader.int32();
                        break;
                    case 100:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchRes;
        })();
    
        pb.CancelMatchReq = (function() {
    
            /**
             * Properties of a CancelMatchReq.
             * @memberof pb
             * @interface ICancelMatchReq
             * @property {string|null} [sn] CancelMatchReq sn
             */
    
            /**
             * Constructs a new CancelMatchReq.
             * @memberof pb
             * @classdesc Represents a CancelMatchReq.
             * @implements ICancelMatchReq
             * @constructor
             * @param {pb.ICancelMatchReq=} [properties] Properties to set
             */
            function CancelMatchReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CancelMatchReq sn.
             * @member {string} sn
             * @memberof pb.CancelMatchReq
             * @instance
             */
            CancelMatchReq.prototype.sn = "";
    
            /**
             * Creates a new CancelMatchReq instance using the specified properties.
             * @function create
             * @memberof pb.CancelMatchReq
             * @static
             * @param {pb.ICancelMatchReq=} [properties] Properties to set
             * @returns {pb.CancelMatchReq} CancelMatchReq instance
             */
            CancelMatchReq.create = function create(properties) {
                return new CancelMatchReq(properties);
            };
    
            /**
             * Encodes the specified CancelMatchReq message. Does not implicitly {@link pb.CancelMatchReq.verify|verify} messages.
             * @function encode
             * @memberof pb.CancelMatchReq
             * @static
             * @param {pb.ICancelMatchReq} message CancelMatchReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelMatchReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 100, wireType 2 =*/802).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a CancelMatchReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CancelMatchReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CancelMatchReq} CancelMatchReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelMatchReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelMatchReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 100:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CancelMatchReq;
        })();
    
        pb.CancelMatchRes = (function() {
    
            /**
             * Properties of a CancelMatchRes.
             * @memberof pb
             * @interface ICancelMatchRes
             * @property {number|null} [code] CancelMatchRes code
             */
    
            /**
             * Constructs a new CancelMatchRes.
             * @memberof pb
             * @classdesc Represents a CancelMatchRes.
             * @implements ICancelMatchRes
             * @constructor
             * @param {pb.ICancelMatchRes=} [properties] Properties to set
             */
            function CancelMatchRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CancelMatchRes code.
             * @member {number} code
             * @memberof pb.CancelMatchRes
             * @instance
             */
            CancelMatchRes.prototype.code = 0;
    
            /**
             * Creates a new CancelMatchRes instance using the specified properties.
             * @function create
             * @memberof pb.CancelMatchRes
             * @static
             * @param {pb.ICancelMatchRes=} [properties] Properties to set
             * @returns {pb.CancelMatchRes} CancelMatchRes instance
             */
            CancelMatchRes.create = function create(properties) {
                return new CancelMatchRes(properties);
            };
    
            /**
             * Encodes the specified CancelMatchRes message. Does not implicitly {@link pb.CancelMatchRes.verify|verify} messages.
             * @function encode
             * @memberof pb.CancelMatchRes
             * @static
             * @param {pb.ICancelMatchRes} message CancelMatchRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelMatchRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a CancelMatchRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CancelMatchRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CancelMatchRes} CancelMatchRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelMatchRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelMatchRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CancelMatchRes;
        })();
    
        pb.ReJoinRes = (function() {
    
            /**
             * Properties of a ReJoinRes.
             * @memberof pb
             * @interface IReJoinRes
             * @property {string|null} [roomId] ReJoinRes roomId
             * @property {number|null} [timestamp] ReJoinRes timestamp
             * @property {string|null} [opt] ReJoinRes opt
             * @property {string|null} [sign] ReJoinRes sign
             * @property {boolean|null} [canNotJoin] ReJoinRes canNotJoin
             * @property {string|null} [sn] ReJoinRes sn
             */
    
            /**
             * Constructs a new ReJoinRes.
             * @memberof pb
             * @classdesc Represents a ReJoinRes.
             * @implements IReJoinRes
             * @constructor
             * @param {pb.IReJoinRes=} [properties] Properties to set
             */
            function ReJoinRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReJoinRes roomId.
             * @member {string} roomId
             * @memberof pb.ReJoinRes
             * @instance
             */
            ReJoinRes.prototype.roomId = "";
    
            /**
             * ReJoinRes timestamp.
             * @member {number} timestamp
             * @memberof pb.ReJoinRes
             * @instance
             */
            ReJoinRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReJoinRes opt.
             * @member {string} opt
             * @memberof pb.ReJoinRes
             * @instance
             */
            ReJoinRes.prototype.opt = "";
    
            /**
             * ReJoinRes sign.
             * @member {string} sign
             * @memberof pb.ReJoinRes
             * @instance
             */
            ReJoinRes.prototype.sign = "";
    
            /**
             * ReJoinRes canNotJoin.
             * @member {boolean} canNotJoin
             * @memberof pb.ReJoinRes
             * @instance
             */
            ReJoinRes.prototype.canNotJoin = false;
    
            /**
             * ReJoinRes sn.
             * @member {string} sn
             * @memberof pb.ReJoinRes
             * @instance
             */
            ReJoinRes.prototype.sn = "";
    
            /**
             * Creates a new ReJoinRes instance using the specified properties.
             * @function create
             * @memberof pb.ReJoinRes
             * @static
             * @param {pb.IReJoinRes=} [properties] Properties to set
             * @returns {pb.ReJoinRes} ReJoinRes instance
             */
            ReJoinRes.create = function create(properties) {
                return new ReJoinRes(properties);
            };
    
            /**
             * Encodes the specified ReJoinRes message. Does not implicitly {@link pb.ReJoinRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ReJoinRes
             * @static
             * @param {pb.IReJoinRes} message ReJoinRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReJoinRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);
                if (message.canNotJoin != null && Object.hasOwnProperty.call(message, "canNotJoin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.canNotJoin);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 100, wireType 2 =*/802).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a ReJoinRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReJoinRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReJoinRes} ReJoinRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReJoinRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReJoinRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.opt = reader.string();
                        break;
                    case 4:
                        message.sign = reader.string();
                        break;
                    case 5:
                        message.canNotJoin = reader.bool();
                        break;
                    case 100:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReJoinRes;
        })();
    
        pb.NewRoomReq = (function() {
    
            /**
             * Properties of a NewRoomReq.
             * @memberof pb
             * @interface INewRoomReq
             */
    
            /**
             * Constructs a new NewRoomReq.
             * @memberof pb
             * @classdesc Represents a NewRoomReq.
             * @implements INewRoomReq
             * @constructor
             * @param {pb.INewRoomReq=} [properties] Properties to set
             */
            function NewRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new NewRoomReq instance using the specified properties.
             * @function create
             * @memberof pb.NewRoomReq
             * @static
             * @param {pb.INewRoomReq=} [properties] Properties to set
             * @returns {pb.NewRoomReq} NewRoomReq instance
             */
            NewRoomReq.create = function create(properties) {
                return new NewRoomReq(properties);
            };
    
            /**
             * Encodes the specified NewRoomReq message. Does not implicitly {@link pb.NewRoomReq.verify|verify} messages.
             * @function encode
             * @memberof pb.NewRoomReq
             * @static
             * @param {pb.INewRoomReq} message NewRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a NewRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.NewRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.NewRoomReq} NewRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.NewRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return NewRoomReq;
        })();
    
        pb.NewRoomRes = (function() {
    
            /**
             * Properties of a NewRoomRes.
             * @memberof pb
             * @interface INewRoomRes
             * @property {string|null} [roomId] NewRoomRes roomId
             * @property {number|null} [timestamp] NewRoomRes timestamp
             * @property {string|null} [opt] NewRoomRes opt
             * @property {string|null} [sign] NewRoomRes sign
             */
    
            /**
             * Constructs a new NewRoomRes.
             * @memberof pb
             * @classdesc Represents a NewRoomRes.
             * @implements INewRoomRes
             * @constructor
             * @param {pb.INewRoomRes=} [properties] Properties to set
             */
            function NewRoomRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NewRoomRes roomId.
             * @member {string} roomId
             * @memberof pb.NewRoomRes
             * @instance
             */
            NewRoomRes.prototype.roomId = "";
    
            /**
             * NewRoomRes timestamp.
             * @member {number} timestamp
             * @memberof pb.NewRoomRes
             * @instance
             */
            NewRoomRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * NewRoomRes opt.
             * @member {string} opt
             * @memberof pb.NewRoomRes
             * @instance
             */
            NewRoomRes.prototype.opt = "";
    
            /**
             * NewRoomRes sign.
             * @member {string} sign
             * @memberof pb.NewRoomRes
             * @instance
             */
            NewRoomRes.prototype.sign = "";
    
            /**
             * Creates a new NewRoomRes instance using the specified properties.
             * @function create
             * @memberof pb.NewRoomRes
             * @static
             * @param {pb.INewRoomRes=} [properties] Properties to set
             * @returns {pb.NewRoomRes} NewRoomRes instance
             */
            NewRoomRes.create = function create(properties) {
                return new NewRoomRes(properties);
            };
    
            /**
             * Encodes the specified NewRoomRes message. Does not implicitly {@link pb.NewRoomRes.verify|verify} messages.
             * @function encode
             * @memberof pb.NewRoomRes
             * @static
             * @param {pb.INewRoomRes} message NewRoomRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewRoomRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);
                return writer;
            };
    
            /**
             * Decodes a NewRoomRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.NewRoomRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.NewRoomRes} NewRoomRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewRoomRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.NewRoomRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.opt = reader.string();
                        break;
                    case 4:
                        message.sign = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return NewRoomRes;
        })();
    
        pb.SignReq = (function() {
    
            /**
             * Properties of a SignReq.
             * @memberof pb
             * @interface ISignReq
             */
    
            /**
             * Constructs a new SignReq.
             * @memberof pb
             * @classdesc Represents a SignReq.
             * @implements ISignReq
             * @constructor
             * @param {pb.ISignReq=} [properties] Properties to set
             */
            function SignReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SignReq instance using the specified properties.
             * @function create
             * @memberof pb.SignReq
             * @static
             * @param {pb.ISignReq=} [properties] Properties to set
             * @returns {pb.SignReq} SignReq instance
             */
            SignReq.create = function create(properties) {
                return new SignReq(properties);
            };
    
            /**
             * Encodes the specified SignReq message. Does not implicitly {@link pb.SignReq.verify|verify} messages.
             * @function encode
             * @memberof pb.SignReq
             * @static
             * @param {pb.ISignReq} message SignReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a SignReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SignReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SignReq} SignReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SignReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SignReq;
        })();
    
        pb.SignRes = (function() {
    
            /**
             * Properties of a SignRes.
             * @memberof pb
             * @interface ISignRes
             * @property {number|null} [coin] SignRes coin
             * @property {number|null} [leftSecond] SignRes leftSecond
             * @property {number|null} [code] SignRes code
             */
    
            /**
             * Constructs a new SignRes.
             * @memberof pb
             * @classdesc Represents a SignRes.
             * @implements ISignRes
             * @constructor
             * @param {pb.ISignRes=} [properties] Properties to set
             */
            function SignRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SignRes coin.
             * @member {number} coin
             * @memberof pb.SignRes
             * @instance
             */
            SignRes.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SignRes leftSecond.
             * @member {number} leftSecond
             * @memberof pb.SignRes
             * @instance
             */
            SignRes.prototype.leftSecond = 0;
    
            /**
             * SignRes code.
             * @member {number} code
             * @memberof pb.SignRes
             * @instance
             */
            SignRes.prototype.code = 0;
    
            /**
             * Creates a new SignRes instance using the specified properties.
             * @function create
             * @memberof pb.SignRes
             * @static
             * @param {pb.ISignRes=} [properties] Properties to set
             * @returns {pb.SignRes} SignRes instance
             */
            SignRes.create = function create(properties) {
                return new SignRes(properties);
            };
    
            /**
             * Encodes the specified SignRes message. Does not implicitly {@link pb.SignRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SignRes
             * @static
             * @param {pb.ISignRes} message SignRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.coin);
                if (message.leftSecond != null && Object.hasOwnProperty.call(message, "leftSecond"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.leftSecond);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a SignRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SignRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SignRes} SignRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SignRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.coin = reader.int64();
                        break;
                    case 2:
                        message.leftSecond = reader.int32();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SignRes;
        })();
    
        pb.GetAllUserMessageReq = (function() {
    
            /**
             * Properties of a GetAllUserMessageReq.
             * @memberof pb
             * @interface IGetAllUserMessageReq
             */
    
            /**
             * Constructs a new GetAllUserMessageReq.
             * @memberof pb
             * @classdesc Represents a GetAllUserMessageReq.
             * @implements IGetAllUserMessageReq
             * @constructor
             * @param {pb.IGetAllUserMessageReq=} [properties] Properties to set
             */
            function GetAllUserMessageReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetAllUserMessageReq instance using the specified properties.
             * @function create
             * @memberof pb.GetAllUserMessageReq
             * @static
             * @param {pb.IGetAllUserMessageReq=} [properties] Properties to set
             * @returns {pb.GetAllUserMessageReq} GetAllUserMessageReq instance
             */
            GetAllUserMessageReq.create = function create(properties) {
                return new GetAllUserMessageReq(properties);
            };
    
            /**
             * Encodes the specified GetAllUserMessageReq message. Does not implicitly {@link pb.GetAllUserMessageReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAllUserMessageReq
             * @static
             * @param {pb.IGetAllUserMessageReq} message GetAllUserMessageReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllUserMessageReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetAllUserMessageReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAllUserMessageReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAllUserMessageReq} GetAllUserMessageReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllUserMessageReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAllUserMessageReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAllUserMessageReq;
        })();
    
        pb.GetAllUserMessageRes = (function() {
    
            /**
             * Properties of a GetAllUserMessageRes.
             * @memberof pb
             * @interface IGetAllUserMessageRes
             * @property {Array.<pb.IUserData>|null} [userDatas] GetAllUserMessageRes userDatas
             * @property {number|null} [loseCoin] GetAllUserMessageRes loseCoin
             * @property {number|null} [winCoin] GetAllUserMessageRes winCoin
             * @property {number|null} [code] GetAllUserMessageRes code
             */
    
            /**
             * Constructs a new GetAllUserMessageRes.
             * @memberof pb
             * @classdesc Represents a GetAllUserMessageRes.
             * @implements IGetAllUserMessageRes
             * @constructor
             * @param {pb.IGetAllUserMessageRes=} [properties] Properties to set
             */
            function GetAllUserMessageRes(properties) {
                this.userDatas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetAllUserMessageRes userDatas.
             * @member {Array.<pb.IUserData>} userDatas
             * @memberof pb.GetAllUserMessageRes
             * @instance
             */
            GetAllUserMessageRes.prototype.userDatas = $util.emptyArray;
    
            /**
             * GetAllUserMessageRes loseCoin.
             * @member {number} loseCoin
             * @memberof pb.GetAllUserMessageRes
             * @instance
             */
            GetAllUserMessageRes.prototype.loseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GetAllUserMessageRes winCoin.
             * @member {number} winCoin
             * @memberof pb.GetAllUserMessageRes
             * @instance
             */
            GetAllUserMessageRes.prototype.winCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GetAllUserMessageRes code.
             * @member {number} code
             * @memberof pb.GetAllUserMessageRes
             * @instance
             */
            GetAllUserMessageRes.prototype.code = 0;
    
            /**
             * Creates a new GetAllUserMessageRes instance using the specified properties.
             * @function create
             * @memberof pb.GetAllUserMessageRes
             * @static
             * @param {pb.IGetAllUserMessageRes=} [properties] Properties to set
             * @returns {pb.GetAllUserMessageRes} GetAllUserMessageRes instance
             */
            GetAllUserMessageRes.create = function create(properties) {
                return new GetAllUserMessageRes(properties);
            };
    
            /**
             * Encodes the specified GetAllUserMessageRes message. Does not implicitly {@link pb.GetAllUserMessageRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAllUserMessageRes
             * @static
             * @param {pb.IGetAllUserMessageRes} message GetAllUserMessageRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllUserMessageRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userDatas != null && message.userDatas.length)
                    for (var i = 0; i < message.userDatas.length; ++i)
                        $root.pb.UserData.encode(message.userDatas[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.loseCoin != null && Object.hasOwnProperty.call(message, "loseCoin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.loseCoin);
                if (message.winCoin != null && Object.hasOwnProperty.call(message, "winCoin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.winCoin);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetAllUserMessageRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAllUserMessageRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAllUserMessageRes} GetAllUserMessageRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllUserMessageRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAllUserMessageRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.userDatas && message.userDatas.length))
                            message.userDatas = [];
                        message.userDatas.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.loseCoin = reader.int64();
                        break;
                    case 3:
                        message.winCoin = reader.int64();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAllUserMessageRes;
        })();
    
        pb.CheckZhuanPanReq = (function() {
    
            /**
             * Properties of a CheckZhuanPanReq.
             * @memberof pb
             * @interface ICheckZhuanPanReq
             */
    
            /**
             * Constructs a new CheckZhuanPanReq.
             * @memberof pb
             * @classdesc Represents a CheckZhuanPanReq.
             * @implements ICheckZhuanPanReq
             * @constructor
             * @param {pb.ICheckZhuanPanReq=} [properties] Properties to set
             */
            function CheckZhuanPanReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new CheckZhuanPanReq instance using the specified properties.
             * @function create
             * @memberof pb.CheckZhuanPanReq
             * @static
             * @param {pb.ICheckZhuanPanReq=} [properties] Properties to set
             * @returns {pb.CheckZhuanPanReq} CheckZhuanPanReq instance
             */
            CheckZhuanPanReq.create = function create(properties) {
                return new CheckZhuanPanReq(properties);
            };
    
            /**
             * Encodes the specified CheckZhuanPanReq message. Does not implicitly {@link pb.CheckZhuanPanReq.verify|verify} messages.
             * @function encode
             * @memberof pb.CheckZhuanPanReq
             * @static
             * @param {pb.ICheckZhuanPanReq} message CheckZhuanPanReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckZhuanPanReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a CheckZhuanPanReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CheckZhuanPanReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CheckZhuanPanReq} CheckZhuanPanReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckZhuanPanReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CheckZhuanPanReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CheckZhuanPanReq;
        })();
    
        pb.CheckZhuanPanRes = (function() {
    
            /**
             * Properties of a CheckZhuanPanRes.
             * @memberof pb
             * @interface ICheckZhuanPanRes
             * @property {number|null} [code] CheckZhuanPanRes code
             * @property {number|null} [zhuanPanTime] CheckZhuanPanRes zhuanPanTime
             * @property {number|null} [serverTime] CheckZhuanPanRes serverTime
             * @property {Array.<pb.IZhuanpanEntityPB>|null} [zhuanPans] CheckZhuanPanRes zhuanPans
             */
    
            /**
             * Constructs a new CheckZhuanPanRes.
             * @memberof pb
             * @classdesc Represents a CheckZhuanPanRes.
             * @implements ICheckZhuanPanRes
             * @constructor
             * @param {pb.ICheckZhuanPanRes=} [properties] Properties to set
             */
            function CheckZhuanPanRes(properties) {
                this.zhuanPans = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CheckZhuanPanRes code.
             * @member {number} code
             * @memberof pb.CheckZhuanPanRes
             * @instance
             */
            CheckZhuanPanRes.prototype.code = 0;
    
            /**
             * CheckZhuanPanRes zhuanPanTime.
             * @member {number} zhuanPanTime
             * @memberof pb.CheckZhuanPanRes
             * @instance
             */
            CheckZhuanPanRes.prototype.zhuanPanTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CheckZhuanPanRes serverTime.
             * @member {number} serverTime
             * @memberof pb.CheckZhuanPanRes
             * @instance
             */
            CheckZhuanPanRes.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * CheckZhuanPanRes zhuanPans.
             * @member {Array.<pb.IZhuanpanEntityPB>} zhuanPans
             * @memberof pb.CheckZhuanPanRes
             * @instance
             */
            CheckZhuanPanRes.prototype.zhuanPans = $util.emptyArray;
    
            /**
             * Creates a new CheckZhuanPanRes instance using the specified properties.
             * @function create
             * @memberof pb.CheckZhuanPanRes
             * @static
             * @param {pb.ICheckZhuanPanRes=} [properties] Properties to set
             * @returns {pb.CheckZhuanPanRes} CheckZhuanPanRes instance
             */
            CheckZhuanPanRes.create = function create(properties) {
                return new CheckZhuanPanRes(properties);
            };
    
            /**
             * Encodes the specified CheckZhuanPanRes message. Does not implicitly {@link pb.CheckZhuanPanRes.verify|verify} messages.
             * @function encode
             * @memberof pb.CheckZhuanPanRes
             * @static
             * @param {pb.ICheckZhuanPanRes} message CheckZhuanPanRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckZhuanPanRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.zhuanPanTime != null && Object.hasOwnProperty.call(message, "zhuanPanTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.zhuanPanTime);
                if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.serverTime);
                if (message.zhuanPans != null && message.zhuanPans.length)
                    for (var i = 0; i < message.zhuanPans.length; ++i)
                        $root.pb.ZhuanpanEntityPB.encode(message.zhuanPans[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a CheckZhuanPanRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CheckZhuanPanRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CheckZhuanPanRes} CheckZhuanPanRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckZhuanPanRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CheckZhuanPanRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.zhuanPanTime = reader.int64();
                        break;
                    case 3:
                        message.serverTime = reader.int64();
                        break;
                    case 4:
                        if (!(message.zhuanPans && message.zhuanPans.length))
                            message.zhuanPans = [];
                        message.zhuanPans.push($root.pb.ZhuanpanEntityPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CheckZhuanPanRes;
        })();
    
        pb.ZhuanpanEntityPB = (function() {
    
            /**
             * Properties of a ZhuanpanEntityPB.
             * @memberof pb
             * @interface IZhuanpanEntityPB
             * @property {number|null} [id] ZhuanpanEntityPB id
             * @property {number|null} [money] ZhuanpanEntityPB money
             */
    
            /**
             * Constructs a new ZhuanpanEntityPB.
             * @memberof pb
             * @classdesc Represents a ZhuanpanEntityPB.
             * @implements IZhuanpanEntityPB
             * @constructor
             * @param {pb.IZhuanpanEntityPB=} [properties] Properties to set
             */
            function ZhuanpanEntityPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuanpanEntityPB id.
             * @member {number} id
             * @memberof pb.ZhuanpanEntityPB
             * @instance
             */
            ZhuanpanEntityPB.prototype.id = 0;
    
            /**
             * ZhuanpanEntityPB money.
             * @member {number} money
             * @memberof pb.ZhuanpanEntityPB
             * @instance
             */
            ZhuanpanEntityPB.prototype.money = 0;
    
            /**
             * Creates a new ZhuanpanEntityPB instance using the specified properties.
             * @function create
             * @memberof pb.ZhuanpanEntityPB
             * @static
             * @param {pb.IZhuanpanEntityPB=} [properties] Properties to set
             * @returns {pb.ZhuanpanEntityPB} ZhuanpanEntityPB instance
             */
            ZhuanpanEntityPB.create = function create(properties) {
                return new ZhuanpanEntityPB(properties);
            };
    
            /**
             * Encodes the specified ZhuanpanEntityPB message. Does not implicitly {@link pb.ZhuanpanEntityPB.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuanpanEntityPB
             * @static
             * @param {pb.IZhuanpanEntityPB} message ZhuanpanEntityPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuanpanEntityPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.money != null && Object.hasOwnProperty.call(message, "money"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.money);
                return writer;
            };
    
            /**
             * Decodes a ZhuanpanEntityPB message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuanpanEntityPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuanpanEntityPB} ZhuanpanEntityPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuanpanEntityPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuanpanEntityPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.money = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuanpanEntityPB;
        })();
    
        pb.ZhuanPanReq = (function() {
    
            /**
             * Properties of a ZhuanPanReq.
             * @memberof pb
             * @interface IZhuanPanReq
             */
    
            /**
             * Constructs a new ZhuanPanReq.
             * @memberof pb
             * @classdesc Represents a ZhuanPanReq.
             * @implements IZhuanPanReq
             * @constructor
             * @param {pb.IZhuanPanReq=} [properties] Properties to set
             */
            function ZhuanPanReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ZhuanPanReq instance using the specified properties.
             * @function create
             * @memberof pb.ZhuanPanReq
             * @static
             * @param {pb.IZhuanPanReq=} [properties] Properties to set
             * @returns {pb.ZhuanPanReq} ZhuanPanReq instance
             */
            ZhuanPanReq.create = function create(properties) {
                return new ZhuanPanReq(properties);
            };
    
            /**
             * Encodes the specified ZhuanPanReq message. Does not implicitly {@link pb.ZhuanPanReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuanPanReq
             * @static
             * @param {pb.IZhuanPanReq} message ZhuanPanReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuanPanReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a ZhuanPanReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuanPanReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuanPanReq} ZhuanPanReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuanPanReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuanPanReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuanPanReq;
        })();
    
        pb.ZhuanPanRes = (function() {
    
            /**
             * Properties of a ZhuanPanRes.
             * @memberof pb
             * @interface IZhuanPanRes
             * @property {number|null} [code] ZhuanPanRes code
             * @property {number|null} [zhuanPanTime] ZhuanPanRes zhuanPanTime
             * @property {pb.IZhuanpanEntityPB|null} [zhuanpanPB] ZhuanPanRes zhuanpanPB
             * @property {number|null} [totalMoney] ZhuanPanRes totalMoney
             */
    
            /**
             * Constructs a new ZhuanPanRes.
             * @memberof pb
             * @classdesc Represents a ZhuanPanRes.
             * @implements IZhuanPanRes
             * @constructor
             * @param {pb.IZhuanPanRes=} [properties] Properties to set
             */
            function ZhuanPanRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuanPanRes code.
             * @member {number} code
             * @memberof pb.ZhuanPanRes
             * @instance
             */
            ZhuanPanRes.prototype.code = 0;
    
            /**
             * ZhuanPanRes zhuanPanTime.
             * @member {number} zhuanPanTime
             * @memberof pb.ZhuanPanRes
             * @instance
             */
            ZhuanPanRes.prototype.zhuanPanTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ZhuanPanRes zhuanpanPB.
             * @member {pb.IZhuanpanEntityPB|null|undefined} zhuanpanPB
             * @memberof pb.ZhuanPanRes
             * @instance
             */
            ZhuanPanRes.prototype.zhuanpanPB = null;
    
            /**
             * ZhuanPanRes totalMoney.
             * @member {number} totalMoney
             * @memberof pb.ZhuanPanRes
             * @instance
             */
            ZhuanPanRes.prototype.totalMoney = 0;
    
            /**
             * Creates a new ZhuanPanRes instance using the specified properties.
             * @function create
             * @memberof pb.ZhuanPanRes
             * @static
             * @param {pb.IZhuanPanRes=} [properties] Properties to set
             * @returns {pb.ZhuanPanRes} ZhuanPanRes instance
             */
            ZhuanPanRes.create = function create(properties) {
                return new ZhuanPanRes(properties);
            };
    
            /**
             * Encodes the specified ZhuanPanRes message. Does not implicitly {@link pb.ZhuanPanRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuanPanRes
             * @static
             * @param {pb.IZhuanPanRes} message ZhuanPanRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuanPanRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.zhuanPanTime != null && Object.hasOwnProperty.call(message, "zhuanPanTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.zhuanPanTime);
                if (message.zhuanpanPB != null && Object.hasOwnProperty.call(message, "zhuanpanPB"))
                    $root.pb.ZhuanpanEntityPB.encode(message.zhuanpanPB, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.totalMoney != null && Object.hasOwnProperty.call(message, "totalMoney"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.totalMoney);
                return writer;
            };
    
            /**
             * Decodes a ZhuanPanRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuanPanRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuanPanRes} ZhuanPanRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuanPanRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuanPanRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.zhuanPanTime = reader.int64();
                        break;
                    case 3:
                        message.zhuanpanPB = $root.pb.ZhuanpanEntityPB.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.totalMoney = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuanPanRes;
        })();
    
        pb.ShareMessageReq = (function() {
    
            /**
             * Properties of a ShareMessageReq.
             * @memberof pb
             * @interface IShareMessageReq
             */
    
            /**
             * Constructs a new ShareMessageReq.
             * @memberof pb
             * @classdesc Represents a ShareMessageReq.
             * @implements IShareMessageReq
             * @constructor
             * @param {pb.IShareMessageReq=} [properties] Properties to set
             */
            function ShareMessageReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ShareMessageReq instance using the specified properties.
             * @function create
             * @memberof pb.ShareMessageReq
             * @static
             * @param {pb.IShareMessageReq=} [properties] Properties to set
             * @returns {pb.ShareMessageReq} ShareMessageReq instance
             */
            ShareMessageReq.create = function create(properties) {
                return new ShareMessageReq(properties);
            };
    
            /**
             * Encodes the specified ShareMessageReq message. Does not implicitly {@link pb.ShareMessageReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ShareMessageReq
             * @static
             * @param {pb.IShareMessageReq} message ShareMessageReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareMessageReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a ShareMessageReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ShareMessageReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ShareMessageReq} ShareMessageReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareMessageReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShareMessageReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ShareMessageReq;
        })();
    
        pb.ShareMessageRes = (function() {
    
            /**
             * Properties of a ShareMessageRes.
             * @memberof pb
             * @interface IShareMessageRes
             * @property {number|null} [leftCount] ShareMessageRes leftCount
             * @property {number|null} [nextRefreshTime] ShareMessageRes nextRefreshTime
             * @property {number|null} [shareCoin] ShareMessageRes shareCoin
             */
    
            /**
             * Constructs a new ShareMessageRes.
             * @memberof pb
             * @classdesc Represents a ShareMessageRes.
             * @implements IShareMessageRes
             * @constructor
             * @param {pb.IShareMessageRes=} [properties] Properties to set
             */
            function ShareMessageRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ShareMessageRes leftCount.
             * @member {number} leftCount
             * @memberof pb.ShareMessageRes
             * @instance
             */
            ShareMessageRes.prototype.leftCount = 0;
    
            /**
             * ShareMessageRes nextRefreshTime.
             * @member {number} nextRefreshTime
             * @memberof pb.ShareMessageRes
             * @instance
             */
            ShareMessageRes.prototype.nextRefreshTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ShareMessageRes shareCoin.
             * @member {number} shareCoin
             * @memberof pb.ShareMessageRes
             * @instance
             */
            ShareMessageRes.prototype.shareCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new ShareMessageRes instance using the specified properties.
             * @function create
             * @memberof pb.ShareMessageRes
             * @static
             * @param {pb.IShareMessageRes=} [properties] Properties to set
             * @returns {pb.ShareMessageRes} ShareMessageRes instance
             */
            ShareMessageRes.create = function create(properties) {
                return new ShareMessageRes(properties);
            };
    
            /**
             * Encodes the specified ShareMessageRes message. Does not implicitly {@link pb.ShareMessageRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ShareMessageRes
             * @static
             * @param {pb.IShareMessageRes} message ShareMessageRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareMessageRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftCount != null && Object.hasOwnProperty.call(message, "leftCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leftCount);
                if (message.nextRefreshTime != null && Object.hasOwnProperty.call(message, "nextRefreshTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.nextRefreshTime);
                if (message.shareCoin != null && Object.hasOwnProperty.call(message, "shareCoin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.shareCoin);
                return writer;
            };
    
            /**
             * Decodes a ShareMessageRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ShareMessageRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ShareMessageRes} ShareMessageRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareMessageRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShareMessageRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftCount = reader.int32();
                        break;
                    case 2:
                        message.nextRefreshTime = reader.int64();
                        break;
                    case 3:
                        message.shareCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ShareMessageRes;
        })();
    
        pb.ShareAwardReq = (function() {
    
            /**
             * Properties of a ShareAwardReq.
             * @memberof pb
             * @interface IShareAwardReq
             * @property {string|null} [sn] ShareAwardReq sn
             */
    
            /**
             * Constructs a new ShareAwardReq.
             * @memberof pb
             * @classdesc Represents a ShareAwardReq.
             * @implements IShareAwardReq
             * @constructor
             * @param {pb.IShareAwardReq=} [properties] Properties to set
             */
            function ShareAwardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ShareAwardReq sn.
             * @member {string} sn
             * @memberof pb.ShareAwardReq
             * @instance
             */
            ShareAwardReq.prototype.sn = "";
    
            /**
             * Creates a new ShareAwardReq instance using the specified properties.
             * @function create
             * @memberof pb.ShareAwardReq
             * @static
             * @param {pb.IShareAwardReq=} [properties] Properties to set
             * @returns {pb.ShareAwardReq} ShareAwardReq instance
             */
            ShareAwardReq.create = function create(properties) {
                return new ShareAwardReq(properties);
            };
    
            /**
             * Encodes the specified ShareAwardReq message. Does not implicitly {@link pb.ShareAwardReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ShareAwardReq
             * @static
             * @param {pb.IShareAwardReq} message ShareAwardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareAwardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a ShareAwardReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ShareAwardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ShareAwardReq} ShareAwardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareAwardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShareAwardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ShareAwardReq;
        })();
    
        pb.ShareAwardRes = (function() {
    
            /**
             * Properties of a ShareAwardRes.
             * @memberof pb
             * @interface IShareAwardRes
             * @property {number|null} [leftCount] ShareAwardRes leftCount
             * @property {number|null} [coin] ShareAwardRes coin
             * @property {string|null} [sn] ShareAwardRes sn
             * @property {number|null} [code] ShareAwardRes code
             */
    
            /**
             * Constructs a new ShareAwardRes.
             * @memberof pb
             * @classdesc Represents a ShareAwardRes.
             * @implements IShareAwardRes
             * @constructor
             * @param {pb.IShareAwardRes=} [properties] Properties to set
             */
            function ShareAwardRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ShareAwardRes leftCount.
             * @member {number} leftCount
             * @memberof pb.ShareAwardRes
             * @instance
             */
            ShareAwardRes.prototype.leftCount = 0;
    
            /**
             * ShareAwardRes coin.
             * @member {number} coin
             * @memberof pb.ShareAwardRes
             * @instance
             */
            ShareAwardRes.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ShareAwardRes sn.
             * @member {string} sn
             * @memberof pb.ShareAwardRes
             * @instance
             */
            ShareAwardRes.prototype.sn = "";
    
            /**
             * ShareAwardRes code.
             * @member {number} code
             * @memberof pb.ShareAwardRes
             * @instance
             */
            ShareAwardRes.prototype.code = 0;
    
            /**
             * Creates a new ShareAwardRes instance using the specified properties.
             * @function create
             * @memberof pb.ShareAwardRes
             * @static
             * @param {pb.IShareAwardRes=} [properties] Properties to set
             * @returns {pb.ShareAwardRes} ShareAwardRes instance
             */
            ShareAwardRes.create = function create(properties) {
                return new ShareAwardRes(properties);
            };
    
            /**
             * Encodes the specified ShareAwardRes message. Does not implicitly {@link pb.ShareAwardRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ShareAwardRes
             * @static
             * @param {pb.IShareAwardRes} message ShareAwardRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareAwardRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftCount != null && Object.hasOwnProperty.call(message, "leftCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leftCount);
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.coin);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.sn);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a ShareAwardRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ShareAwardRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ShareAwardRes} ShareAwardRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareAwardRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShareAwardRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftCount = reader.int32();
                        break;
                    case 2:
                        message.coin = reader.int64();
                        break;
                    case 3:
                        message.sn = reader.string();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ShareAwardRes;
        })();
    
        pb.PlayerStatus = (function() {
    
            /**
             * Properties of a PlayerStatus.
             * @memberof pb
             * @interface IPlayerStatus
             * @property {string|null} [uid] PlayerStatus uid
             * @property {number|null} [status] PlayerStatus status
             */
    
            /**
             * Constructs a new PlayerStatus.
             * @memberof pb
             * @classdesc Represents a PlayerStatus.
             * @implements IPlayerStatus
             * @constructor
             * @param {pb.IPlayerStatus=} [properties] Properties to set
             */
            function PlayerStatus(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayerStatus uid.
             * @member {string} uid
             * @memberof pb.PlayerStatus
             * @instance
             */
            PlayerStatus.prototype.uid = "";
    
            /**
             * PlayerStatus status.
             * @member {number} status
             * @memberof pb.PlayerStatus
             * @instance
             */
            PlayerStatus.prototype.status = 0;
    
            /**
             * Creates a new PlayerStatus instance using the specified properties.
             * @function create
             * @memberof pb.PlayerStatus
             * @static
             * @param {pb.IPlayerStatus=} [properties] Properties to set
             * @returns {pb.PlayerStatus} PlayerStatus instance
             */
            PlayerStatus.create = function create(properties) {
                return new PlayerStatus(properties);
            };
    
            /**
             * Encodes the specified PlayerStatus message. Does not implicitly {@link pb.PlayerStatus.verify|verify} messages.
             * @function encode
             * @memberof pb.PlayerStatus
             * @static
             * @param {pb.IPlayerStatus} message PlayerStatus message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerStatus.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                return writer;
            };
    
            /**
             * Decodes a PlayerStatus message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlayerStatus
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlayerStatus} PlayerStatus
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerStatus.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayerStatus();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlayerStatus;
        })();
    
        pb.PlayerStatusRes = (function() {
    
            /**
             * Properties of a PlayerStatusRes.
             * @memberof pb
             * @interface IPlayerStatusRes
             * @property {Array.<pb.IPlayerStatus>|null} [playerStatus] PlayerStatusRes playerStatus
             * @property {string|null} [masterUid] PlayerStatusRes masterUid
             */
    
            /**
             * Constructs a new PlayerStatusRes.
             * @memberof pb
             * @classdesc Represents a PlayerStatusRes.
             * @implements IPlayerStatusRes
             * @constructor
             * @param {pb.IPlayerStatusRes=} [properties] Properties to set
             */
            function PlayerStatusRes(properties) {
                this.playerStatus = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayerStatusRes playerStatus.
             * @member {Array.<pb.IPlayerStatus>} playerStatus
             * @memberof pb.PlayerStatusRes
             * @instance
             */
            PlayerStatusRes.prototype.playerStatus = $util.emptyArray;
    
            /**
             * PlayerStatusRes masterUid.
             * @member {string} masterUid
             * @memberof pb.PlayerStatusRes
             * @instance
             */
            PlayerStatusRes.prototype.masterUid = "";
    
            /**
             * Creates a new PlayerStatusRes instance using the specified properties.
             * @function create
             * @memberof pb.PlayerStatusRes
             * @static
             * @param {pb.IPlayerStatusRes=} [properties] Properties to set
             * @returns {pb.PlayerStatusRes} PlayerStatusRes instance
             */
            PlayerStatusRes.create = function create(properties) {
                return new PlayerStatusRes(properties);
            };
    
            /**
             * Encodes the specified PlayerStatusRes message. Does not implicitly {@link pb.PlayerStatusRes.verify|verify} messages.
             * @function encode
             * @memberof pb.PlayerStatusRes
             * @static
             * @param {pb.IPlayerStatusRes} message PlayerStatusRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayerStatusRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.playerStatus != null && message.playerStatus.length)
                    for (var i = 0; i < message.playerStatus.length; ++i)
                        $root.pb.PlayerStatus.encode(message.playerStatus[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.masterUid != null && Object.hasOwnProperty.call(message, "masterUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.masterUid);
                return writer;
            };
    
            /**
             * Decodes a PlayerStatusRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlayerStatusRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlayerStatusRes} PlayerStatusRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayerStatusRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayerStatusRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.playerStatus && message.playerStatus.length))
                            message.playerStatus = [];
                        message.playerStatus.push($root.pb.PlayerStatus.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.masterUid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlayerStatusRes;
        })();
    
        pb.AiUidGetReq = (function() {
    
            /**
             * Properties of an AiUidGetReq.
             * @memberof pb
             * @interface IAiUidGetReq
             */
    
            /**
             * Constructs a new AiUidGetReq.
             * @memberof pb
             * @classdesc Represents an AiUidGetReq.
             * @implements IAiUidGetReq
             * @constructor
             * @param {pb.IAiUidGetReq=} [properties] Properties to set
             */
            function AiUidGetReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new AiUidGetReq instance using the specified properties.
             * @function create
             * @memberof pb.AiUidGetReq
             * @static
             * @param {pb.IAiUidGetReq=} [properties] Properties to set
             * @returns {pb.AiUidGetReq} AiUidGetReq instance
             */
            AiUidGetReq.create = function create(properties) {
                return new AiUidGetReq(properties);
            };
    
            /**
             * Encodes the specified AiUidGetReq message. Does not implicitly {@link pb.AiUidGetReq.verify|verify} messages.
             * @function encode
             * @memberof pb.AiUidGetReq
             * @static
             * @param {pb.IAiUidGetReq} message AiUidGetReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AiUidGetReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes an AiUidGetReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AiUidGetReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AiUidGetReq} AiUidGetReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AiUidGetReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AiUidGetReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AiUidGetReq;
        })();
    
        pb.AiUidGetRes = (function() {
    
            /**
             * Properties of an AiUidGetRes.
             * @memberof pb
             * @interface IAiUidGetRes
             * @property {string|null} [uid] AiUidGetRes uid
             * @property {number|null} [code] AiUidGetRes code
             */
    
            /**
             * Constructs a new AiUidGetRes.
             * @memberof pb
             * @classdesc Represents an AiUidGetRes.
             * @implements IAiUidGetRes
             * @constructor
             * @param {pb.IAiUidGetRes=} [properties] Properties to set
             */
            function AiUidGetRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AiUidGetRes uid.
             * @member {string} uid
             * @memberof pb.AiUidGetRes
             * @instance
             */
            AiUidGetRes.prototype.uid = "";
    
            /**
             * AiUidGetRes code.
             * @member {number} code
             * @memberof pb.AiUidGetRes
             * @instance
             */
            AiUidGetRes.prototype.code = 0;
    
            /**
             * Creates a new AiUidGetRes instance using the specified properties.
             * @function create
             * @memberof pb.AiUidGetRes
             * @static
             * @param {pb.IAiUidGetRes=} [properties] Properties to set
             * @returns {pb.AiUidGetRes} AiUidGetRes instance
             */
            AiUidGetRes.create = function create(properties) {
                return new AiUidGetRes(properties);
            };
    
            /**
             * Encodes the specified AiUidGetRes message. Does not implicitly {@link pb.AiUidGetRes.verify|verify} messages.
             * @function encode
             * @memberof pb.AiUidGetRes
             * @static
             * @param {pb.IAiUidGetRes} message AiUidGetRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AiUidGetRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes an AiUidGetRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AiUidGetRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AiUidGetRes} AiUidGetRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AiUidGetRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AiUidGetRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AiUidGetRes;
        })();
    
        pb.PlayWithAiReq = (function() {
    
            /**
             * Properties of a PlayWithAiReq.
             * @memberof pb
             * @interface IPlayWithAiReq
             * @property {string|null} [uid] PlayWithAiReq uid
             */
    
            /**
             * Constructs a new PlayWithAiReq.
             * @memberof pb
             * @classdesc Represents a PlayWithAiReq.
             * @implements IPlayWithAiReq
             * @constructor
             * @param {pb.IPlayWithAiReq=} [properties] Properties to set
             */
            function PlayWithAiReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayWithAiReq uid.
             * @member {string} uid
             * @memberof pb.PlayWithAiReq
             * @instance
             */
            PlayWithAiReq.prototype.uid = "";
    
            /**
             * Creates a new PlayWithAiReq instance using the specified properties.
             * @function create
             * @memberof pb.PlayWithAiReq
             * @static
             * @param {pb.IPlayWithAiReq=} [properties] Properties to set
             * @returns {pb.PlayWithAiReq} PlayWithAiReq instance
             */
            PlayWithAiReq.create = function create(properties) {
                return new PlayWithAiReq(properties);
            };
    
            /**
             * Encodes the specified PlayWithAiReq message. Does not implicitly {@link pb.PlayWithAiReq.verify|verify} messages.
             * @function encode
             * @memberof pb.PlayWithAiReq
             * @static
             * @param {pb.IPlayWithAiReq} message PlayWithAiReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayWithAiReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                return writer;
            };
    
            /**
             * Decodes a PlayWithAiReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlayWithAiReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlayWithAiReq} PlayWithAiReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayWithAiReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayWithAiReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlayWithAiReq;
        })();
    
        pb.PlayWithAiRes = (function() {
    
            /**
             * Properties of a PlayWithAiRes.
             * @memberof pb
             * @interface IPlayWithAiRes
             * @property {string|null} [uid] PlayWithAiRes uid
             * @property {string|null} [roomId] PlayWithAiRes roomId
             * @property {number|null} [timestamp] PlayWithAiRes timestamp
             * @property {string|null} [opt] PlayWithAiRes opt
             * @property {string|null} [sign] PlayWithAiRes sign
             * @property {number|null} [code] PlayWithAiRes code
             */
    
            /**
             * Constructs a new PlayWithAiRes.
             * @memberof pb
             * @classdesc Represents a PlayWithAiRes.
             * @implements IPlayWithAiRes
             * @constructor
             * @param {pb.IPlayWithAiRes=} [properties] Properties to set
             */
            function PlayWithAiRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlayWithAiRes uid.
             * @member {string} uid
             * @memberof pb.PlayWithAiRes
             * @instance
             */
            PlayWithAiRes.prototype.uid = "";
    
            /**
             * PlayWithAiRes roomId.
             * @member {string} roomId
             * @memberof pb.PlayWithAiRes
             * @instance
             */
            PlayWithAiRes.prototype.roomId = "";
    
            /**
             * PlayWithAiRes timestamp.
             * @member {number} timestamp
             * @memberof pb.PlayWithAiRes
             * @instance
             */
            PlayWithAiRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * PlayWithAiRes opt.
             * @member {string} opt
             * @memberof pb.PlayWithAiRes
             * @instance
             */
            PlayWithAiRes.prototype.opt = "";
    
            /**
             * PlayWithAiRes sign.
             * @member {string} sign
             * @memberof pb.PlayWithAiRes
             * @instance
             */
            PlayWithAiRes.prototype.sign = "";
    
            /**
             * PlayWithAiRes code.
             * @member {number} code
             * @memberof pb.PlayWithAiRes
             * @instance
             */
            PlayWithAiRes.prototype.code = 0;
    
            /**
             * Creates a new PlayWithAiRes instance using the specified properties.
             * @function create
             * @memberof pb.PlayWithAiRes
             * @static
             * @param {pb.IPlayWithAiRes=} [properties] Properties to set
             * @returns {pb.PlayWithAiRes} PlayWithAiRes instance
             */
            PlayWithAiRes.create = function create(properties) {
                return new PlayWithAiRes(properties);
            };
    
            /**
             * Encodes the specified PlayWithAiRes message. Does not implicitly {@link pb.PlayWithAiRes.verify|verify} messages.
             * @function encode
             * @memberof pb.PlayWithAiRes
             * @static
             * @param {pb.IPlayWithAiRes} message PlayWithAiRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlayWithAiRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a PlayWithAiRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlayWithAiRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlayWithAiRes} PlayWithAiRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlayWithAiRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayWithAiRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.roomId = reader.string();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.opt = reader.string();
                        break;
                    case 5:
                        message.sign = reader.string();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlayWithAiRes;
        })();
    
        pb.QueryAutoStatusReq = (function() {
    
            /**
             * Properties of a QueryAutoStatusReq.
             * @memberof pb
             * @interface IQueryAutoStatusReq
             */
    
            /**
             * Constructs a new QueryAutoStatusReq.
             * @memberof pb
             * @classdesc Represents a QueryAutoStatusReq.
             * @implements IQueryAutoStatusReq
             * @constructor
             * @param {pb.IQueryAutoStatusReq=} [properties] Properties to set
             */
            function QueryAutoStatusReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new QueryAutoStatusReq instance using the specified properties.
             * @function create
             * @memberof pb.QueryAutoStatusReq
             * @static
             * @param {pb.IQueryAutoStatusReq=} [properties] Properties to set
             * @returns {pb.QueryAutoStatusReq} QueryAutoStatusReq instance
             */
            QueryAutoStatusReq.create = function create(properties) {
                return new QueryAutoStatusReq(properties);
            };
    
            /**
             * Encodes the specified QueryAutoStatusReq message. Does not implicitly {@link pb.QueryAutoStatusReq.verify|verify} messages.
             * @function encode
             * @memberof pb.QueryAutoStatusReq
             * @static
             * @param {pb.IQueryAutoStatusReq} message QueryAutoStatusReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryAutoStatusReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a QueryAutoStatusReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.QueryAutoStatusReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.QueryAutoStatusReq} QueryAutoStatusReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryAutoStatusReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.QueryAutoStatusReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return QueryAutoStatusReq;
        })();
    
        pb.QueryAutoStatusRes = (function() {
    
            /**
             * Properties of a QueryAutoStatusRes.
             * @memberof pb
             * @interface IQueryAutoStatusRes
             * @property {boolean|null} [auto] QueryAutoStatusRes auto
             * @property {number|null} [count] QueryAutoStatusRes count
             * @property {number|null} [existedSecond] QueryAutoStatusRes existedSecond
             */
    
            /**
             * Constructs a new QueryAutoStatusRes.
             * @memberof pb
             * @classdesc Represents a QueryAutoStatusRes.
             * @implements IQueryAutoStatusRes
             * @constructor
             * @param {pb.IQueryAutoStatusRes=} [properties] Properties to set
             */
            function QueryAutoStatusRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * QueryAutoStatusRes auto.
             * @member {boolean} auto
             * @memberof pb.QueryAutoStatusRes
             * @instance
             */
            QueryAutoStatusRes.prototype.auto = false;
    
            /**
             * QueryAutoStatusRes count.
             * @member {number} count
             * @memberof pb.QueryAutoStatusRes
             * @instance
             */
            QueryAutoStatusRes.prototype.count = 0;
    
            /**
             * QueryAutoStatusRes existedSecond.
             * @member {number} existedSecond
             * @memberof pb.QueryAutoStatusRes
             * @instance
             */
            QueryAutoStatusRes.prototype.existedSecond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new QueryAutoStatusRes instance using the specified properties.
             * @function create
             * @memberof pb.QueryAutoStatusRes
             * @static
             * @param {pb.IQueryAutoStatusRes=} [properties] Properties to set
             * @returns {pb.QueryAutoStatusRes} QueryAutoStatusRes instance
             */
            QueryAutoStatusRes.create = function create(properties) {
                return new QueryAutoStatusRes(properties);
            };
    
            /**
             * Encodes the specified QueryAutoStatusRes message. Does not implicitly {@link pb.QueryAutoStatusRes.verify|verify} messages.
             * @function encode
             * @memberof pb.QueryAutoStatusRes
             * @static
             * @param {pb.IQueryAutoStatusRes} message QueryAutoStatusRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryAutoStatusRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.auto != null && Object.hasOwnProperty.call(message, "auto"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.auto);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
                if (message.existedSecond != null && Object.hasOwnProperty.call(message, "existedSecond"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.existedSecond);
                return writer;
            };
    
            /**
             * Decodes a QueryAutoStatusRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.QueryAutoStatusRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.QueryAutoStatusRes} QueryAutoStatusRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryAutoStatusRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.QueryAutoStatusRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.auto = reader.bool();
                        break;
                    case 2:
                        message.count = reader.int32();
                        break;
                    case 3:
                        message.existedSecond = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return QueryAutoStatusRes;
        })();
    
        pb.CancelAutoStatusReq = (function() {
    
            /**
             * Properties of a CancelAutoStatusReq.
             * @memberof pb
             * @interface ICancelAutoStatusReq
             */
    
            /**
             * Constructs a new CancelAutoStatusReq.
             * @memberof pb
             * @classdesc Represents a CancelAutoStatusReq.
             * @implements ICancelAutoStatusReq
             * @constructor
             * @param {pb.ICancelAutoStatusReq=} [properties] Properties to set
             */
            function CancelAutoStatusReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new CancelAutoStatusReq instance using the specified properties.
             * @function create
             * @memberof pb.CancelAutoStatusReq
             * @static
             * @param {pb.ICancelAutoStatusReq=} [properties] Properties to set
             * @returns {pb.CancelAutoStatusReq} CancelAutoStatusReq instance
             */
            CancelAutoStatusReq.create = function create(properties) {
                return new CancelAutoStatusReq(properties);
            };
    
            /**
             * Encodes the specified CancelAutoStatusReq message. Does not implicitly {@link pb.CancelAutoStatusReq.verify|verify} messages.
             * @function encode
             * @memberof pb.CancelAutoStatusReq
             * @static
             * @param {pb.ICancelAutoStatusReq} message CancelAutoStatusReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelAutoStatusReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a CancelAutoStatusReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CancelAutoStatusReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CancelAutoStatusReq} CancelAutoStatusReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelAutoStatusReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelAutoStatusReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CancelAutoStatusReq;
        })();
    
        pb.CancelAutoStatusRes = (function() {
    
            /**
             * Properties of a CancelAutoStatusRes.
             * @memberof pb
             * @interface ICancelAutoStatusRes
             * @property {number|null} [code] CancelAutoStatusRes code
             */
    
            /**
             * Constructs a new CancelAutoStatusRes.
             * @memberof pb
             * @classdesc Represents a CancelAutoStatusRes.
             * @implements ICancelAutoStatusRes
             * @constructor
             * @param {pb.ICancelAutoStatusRes=} [properties] Properties to set
             */
            function CancelAutoStatusRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CancelAutoStatusRes code.
             * @member {number} code
             * @memberof pb.CancelAutoStatusRes
             * @instance
             */
            CancelAutoStatusRes.prototype.code = 0;
    
            /**
             * Creates a new CancelAutoStatusRes instance using the specified properties.
             * @function create
             * @memberof pb.CancelAutoStatusRes
             * @static
             * @param {pb.ICancelAutoStatusRes=} [properties] Properties to set
             * @returns {pb.CancelAutoStatusRes} CancelAutoStatusRes instance
             */
            CancelAutoStatusRes.create = function create(properties) {
                return new CancelAutoStatusRes(properties);
            };
    
            /**
             * Encodes the specified CancelAutoStatusRes message. Does not implicitly {@link pb.CancelAutoStatusRes.verify|verify} messages.
             * @function encode
             * @memberof pb.CancelAutoStatusRes
             * @static
             * @param {pb.ICancelAutoStatusRes} message CancelAutoStatusRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CancelAutoStatusRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a CancelAutoStatusRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CancelAutoStatusRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CancelAutoStatusRes} CancelAutoStatusRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CancelAutoStatusRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelAutoStatusRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CancelAutoStatusRes;
        })();
    
        pb.WordBroadCastReq = (function() {
    
            /**
             * Properties of a WordBroadCastReq.
             * @memberof pb
             * @interface IWordBroadCastReq
             * @property {string|null} [msg] WordBroadCastReq msg
             */
    
            /**
             * Constructs a new WordBroadCastReq.
             * @memberof pb
             * @classdesc Represents a WordBroadCastReq.
             * @implements IWordBroadCastReq
             * @constructor
             * @param {pb.IWordBroadCastReq=} [properties] Properties to set
             */
            function WordBroadCastReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * WordBroadCastReq msg.
             * @member {string} msg
             * @memberof pb.WordBroadCastReq
             * @instance
             */
            WordBroadCastReq.prototype.msg = "";
    
            /**
             * Creates a new WordBroadCastReq instance using the specified properties.
             * @function create
             * @memberof pb.WordBroadCastReq
             * @static
             * @param {pb.IWordBroadCastReq=} [properties] Properties to set
             * @returns {pb.WordBroadCastReq} WordBroadCastReq instance
             */
            WordBroadCastReq.create = function create(properties) {
                return new WordBroadCastReq(properties);
            };
    
            /**
             * Encodes the specified WordBroadCastReq message. Does not implicitly {@link pb.WordBroadCastReq.verify|verify} messages.
             * @function encode
             * @memberof pb.WordBroadCastReq
             * @static
             * @param {pb.IWordBroadCastReq} message WordBroadCastReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WordBroadCastReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.msg);
                return writer;
            };
    
            /**
             * Decodes a WordBroadCastReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.WordBroadCastReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.WordBroadCastReq} WordBroadCastReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WordBroadCastReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WordBroadCastReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.msg = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return WordBroadCastReq;
        })();
    
        pb.StateChangeReq = (function() {
    
            /**
             * Properties of a StateChangeReq.
             * @memberof pb
             * @interface IStateChangeReq
             * @property {number|null} [status] StateChangeReq status
             */
    
            /**
             * Constructs a new StateChangeReq.
             * @memberof pb
             * @classdesc Represents a StateChangeReq.
             * @implements IStateChangeReq
             * @constructor
             * @param {pb.IStateChangeReq=} [properties] Properties to set
             */
            function StateChangeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateChangeReq status.
             * @member {number} status
             * @memberof pb.StateChangeReq
             * @instance
             */
            StateChangeReq.prototype.status = 0;
    
            /**
             * Creates a new StateChangeReq instance using the specified properties.
             * @function create
             * @memberof pb.StateChangeReq
             * @static
             * @param {pb.IStateChangeReq=} [properties] Properties to set
             * @returns {pb.StateChangeReq} StateChangeReq instance
             */
            StateChangeReq.create = function create(properties) {
                return new StateChangeReq(properties);
            };
    
            /**
             * Encodes the specified StateChangeReq message. Does not implicitly {@link pb.StateChangeReq.verify|verify} messages.
             * @function encode
             * @memberof pb.StateChangeReq
             * @static
             * @param {pb.IStateChangeReq} message StateChangeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateChangeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);
                return writer;
            };
    
            /**
             * Decodes a StateChangeReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.StateChangeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.StateChangeReq} StateChangeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateChangeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.StateChangeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.status = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return StateChangeReq;
        })();
    
        pb.StateChangeRes = (function() {
    
            /**
             * Properties of a StateChangeRes.
             * @memberof pb
             * @interface IStateChangeRes
             * @property {string|null} [uid] StateChangeRes uid
             * @property {number|null} [status] StateChangeRes status
             * @property {string|null} [newMaster] StateChangeRes newMaster
             */
    
            /**
             * Constructs a new StateChangeRes.
             * @memberof pb
             * @classdesc Represents a StateChangeRes.
             * @implements IStateChangeRes
             * @constructor
             * @param {pb.IStateChangeRes=} [properties] Properties to set
             */
            function StateChangeRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * StateChangeRes uid.
             * @member {string} uid
             * @memberof pb.StateChangeRes
             * @instance
             */
            StateChangeRes.prototype.uid = "";
    
            /**
             * StateChangeRes status.
             * @member {number} status
             * @memberof pb.StateChangeRes
             * @instance
             */
            StateChangeRes.prototype.status = 0;
    
            /**
             * StateChangeRes newMaster.
             * @member {string} newMaster
             * @memberof pb.StateChangeRes
             * @instance
             */
            StateChangeRes.prototype.newMaster = "";
    
            /**
             * Creates a new StateChangeRes instance using the specified properties.
             * @function create
             * @memberof pb.StateChangeRes
             * @static
             * @param {pb.IStateChangeRes=} [properties] Properties to set
             * @returns {pb.StateChangeRes} StateChangeRes instance
             */
            StateChangeRes.create = function create(properties) {
                return new StateChangeRes(properties);
            };
    
            /**
             * Encodes the specified StateChangeRes message. Does not implicitly {@link pb.StateChangeRes.verify|verify} messages.
             * @function encode
             * @memberof pb.StateChangeRes
             * @static
             * @param {pb.IStateChangeRes} message StateChangeRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            StateChangeRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                if (message.newMaster != null && Object.hasOwnProperty.call(message, "newMaster"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.newMaster);
                return writer;
            };
    
            /**
             * Decodes a StateChangeRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.StateChangeRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.StateChangeRes} StateChangeRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            StateChangeRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.StateChangeRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.status = reader.int32();
                        break;
                    case 3:
                        message.newMaster = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return StateChangeRes;
        })();
    
        pb.WordBroadCastRes = (function() {
    
            /**
             * Properties of a WordBroadCastRes.
             * @memberof pb
             * @interface IWordBroadCastRes
             * @property {string|null} [msg] WordBroadCastRes msg
             * @property {string|null} [uid] WordBroadCastRes uid
             */
    
            /**
             * Constructs a new WordBroadCastRes.
             * @memberof pb
             * @classdesc Represents a WordBroadCastRes.
             * @implements IWordBroadCastRes
             * @constructor
             * @param {pb.IWordBroadCastRes=} [properties] Properties to set
             */
            function WordBroadCastRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * WordBroadCastRes msg.
             * @member {string} msg
             * @memberof pb.WordBroadCastRes
             * @instance
             */
            WordBroadCastRes.prototype.msg = "";
    
            /**
             * WordBroadCastRes uid.
             * @member {string} uid
             * @memberof pb.WordBroadCastRes
             * @instance
             */
            WordBroadCastRes.prototype.uid = "";
    
            /**
             * Creates a new WordBroadCastRes instance using the specified properties.
             * @function create
             * @memberof pb.WordBroadCastRes
             * @static
             * @param {pb.IWordBroadCastRes=} [properties] Properties to set
             * @returns {pb.WordBroadCastRes} WordBroadCastRes instance
             */
            WordBroadCastRes.create = function create(properties) {
                return new WordBroadCastRes(properties);
            };
    
            /**
             * Encodes the specified WordBroadCastRes message. Does not implicitly {@link pb.WordBroadCastRes.verify|verify} messages.
             * @function encode
             * @memberof pb.WordBroadCastRes
             * @static
             * @param {pb.IWordBroadCastRes} message WordBroadCastRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WordBroadCastRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.msg);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uid);
                return writer;
            };
    
            /**
             * Decodes a WordBroadCastRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.WordBroadCastRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.WordBroadCastRes} WordBroadCastRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WordBroadCastRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WordBroadCastRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.msg = reader.string();
                        break;
                    case 2:
                        message.uid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return WordBroadCastRes;
        })();
    
        pb.MsgItemSendReq = (function() {
    
            /**
             * Properties of a MsgItemSendReq.
             * @memberof pb
             * @interface IMsgItemSendReq
             * @property {number|null} [itemId] MsgItemSendReq itemId
             * @property {string|null} [toUid] MsgItemSendReq toUid
             */
    
            /**
             * Constructs a new MsgItemSendReq.
             * @memberof pb
             * @classdesc Represents a MsgItemSendReq.
             * @implements IMsgItemSendReq
             * @constructor
             * @param {pb.IMsgItemSendReq=} [properties] Properties to set
             */
            function MsgItemSendReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MsgItemSendReq itemId.
             * @member {number} itemId
             * @memberof pb.MsgItemSendReq
             * @instance
             */
            MsgItemSendReq.prototype.itemId = 0;
    
            /**
             * MsgItemSendReq toUid.
             * @member {string} toUid
             * @memberof pb.MsgItemSendReq
             * @instance
             */
            MsgItemSendReq.prototype.toUid = "";
    
            /**
             * Creates a new MsgItemSendReq instance using the specified properties.
             * @function create
             * @memberof pb.MsgItemSendReq
             * @static
             * @param {pb.IMsgItemSendReq=} [properties] Properties to set
             * @returns {pb.MsgItemSendReq} MsgItemSendReq instance
             */
            MsgItemSendReq.create = function create(properties) {
                return new MsgItemSendReq(properties);
            };
    
            /**
             * Encodes the specified MsgItemSendReq message. Does not implicitly {@link pb.MsgItemSendReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MsgItemSendReq
             * @static
             * @param {pb.IMsgItemSendReq} message MsgItemSendReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgItemSendReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
                if (message.toUid != null && Object.hasOwnProperty.call(message, "toUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.toUid);
                return writer;
            };
    
            /**
             * Decodes a MsgItemSendReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MsgItemSendReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MsgItemSendReq} MsgItemSendReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgItemSendReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MsgItemSendReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.itemId = reader.int32();
                        break;
                    case 2:
                        message.toUid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MsgItemSendReq;
        })();
    
        pb.MsgItemSendRes = (function() {
    
            /**
             * Properties of a MsgItemSendRes.
             * @memberof pb
             * @interface IMsgItemSendRes
             * @property {number|null} [itemId] MsgItemSendRes itemId
             * @property {string|null} [toUid] MsgItemSendRes toUid
             * @property {string|null} [fromUid] MsgItemSendRes fromUid
             * @property {number|null} [coin] MsgItemSendRes coin
             * @property {number|null} [code] MsgItemSendRes code
             */
    
            /**
             * Constructs a new MsgItemSendRes.
             * @memberof pb
             * @classdesc Represents a MsgItemSendRes.
             * @implements IMsgItemSendRes
             * @constructor
             * @param {pb.IMsgItemSendRes=} [properties] Properties to set
             */
            function MsgItemSendRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MsgItemSendRes itemId.
             * @member {number} itemId
             * @memberof pb.MsgItemSendRes
             * @instance
             */
            MsgItemSendRes.prototype.itemId = 0;
    
            /**
             * MsgItemSendRes toUid.
             * @member {string} toUid
             * @memberof pb.MsgItemSendRes
             * @instance
             */
            MsgItemSendRes.prototype.toUid = "";
    
            /**
             * MsgItemSendRes fromUid.
             * @member {string} fromUid
             * @memberof pb.MsgItemSendRes
             * @instance
             */
            MsgItemSendRes.prototype.fromUid = "";
    
            /**
             * MsgItemSendRes coin.
             * @member {number} coin
             * @memberof pb.MsgItemSendRes
             * @instance
             */
            MsgItemSendRes.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MsgItemSendRes code.
             * @member {number} code
             * @memberof pb.MsgItemSendRes
             * @instance
             */
            MsgItemSendRes.prototype.code = 0;
    
            /**
             * Creates a new MsgItemSendRes instance using the specified properties.
             * @function create
             * @memberof pb.MsgItemSendRes
             * @static
             * @param {pb.IMsgItemSendRes=} [properties] Properties to set
             * @returns {pb.MsgItemSendRes} MsgItemSendRes instance
             */
            MsgItemSendRes.create = function create(properties) {
                return new MsgItemSendRes(properties);
            };
    
            /**
             * Encodes the specified MsgItemSendRes message. Does not implicitly {@link pb.MsgItemSendRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MsgItemSendRes
             * @static
             * @param {pb.IMsgItemSendRes} message MsgItemSendRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MsgItemSendRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
                if (message.toUid != null && Object.hasOwnProperty.call(message, "toUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.toUid);
                if (message.fromUid != null && Object.hasOwnProperty.call(message, "fromUid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.fromUid);
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.coin);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a MsgItemSendRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MsgItemSendRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MsgItemSendRes} MsgItemSendRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MsgItemSendRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MsgItemSendRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.itemId = reader.int32();
                        break;
                    case 2:
                        message.toUid = reader.string();
                        break;
                    case 3:
                        message.fromUid = reader.string();
                        break;
                    case 4:
                        message.coin = reader.int64();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MsgItemSendRes;
        })();
    
        pb.ZhuanpanLevelMessage = (function() {
    
            /**
             * Properties of a ZhuanpanLevelMessage.
             * @memberof pb
             * @interface IZhuanpanLevelMessage
             * @property {number|null} [id] ZhuanpanLevelMessage id
             * @property {number|null} [money] ZhuanpanLevelMessage money
             * @property {number|null} [preMoney] ZhuanpanLevelMessage preMoney
             * @property {number|null} [updateCount] ZhuanpanLevelMessage updateCount
             */
    
            /**
             * Constructs a new ZhuanpanLevelMessage.
             * @memberof pb
             * @classdesc Represents a ZhuanpanLevelMessage.
             * @implements IZhuanpanLevelMessage
             * @constructor
             * @param {pb.IZhuanpanLevelMessage=} [properties] Properties to set
             */
            function ZhuanpanLevelMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuanpanLevelMessage id.
             * @member {number} id
             * @memberof pb.ZhuanpanLevelMessage
             * @instance
             */
            ZhuanpanLevelMessage.prototype.id = 0;
    
            /**
             * ZhuanpanLevelMessage money.
             * @member {number} money
             * @memberof pb.ZhuanpanLevelMessage
             * @instance
             */
            ZhuanpanLevelMessage.prototype.money = 0;
    
            /**
             * ZhuanpanLevelMessage preMoney.
             * @member {number} preMoney
             * @memberof pb.ZhuanpanLevelMessage
             * @instance
             */
            ZhuanpanLevelMessage.prototype.preMoney = 0;
    
            /**
             * ZhuanpanLevelMessage updateCount.
             * @member {number} updateCount
             * @memberof pb.ZhuanpanLevelMessage
             * @instance
             */
            ZhuanpanLevelMessage.prototype.updateCount = 0;
    
            /**
             * Creates a new ZhuanpanLevelMessage instance using the specified properties.
             * @function create
             * @memberof pb.ZhuanpanLevelMessage
             * @static
             * @param {pb.IZhuanpanLevelMessage=} [properties] Properties to set
             * @returns {pb.ZhuanpanLevelMessage} ZhuanpanLevelMessage instance
             */
            ZhuanpanLevelMessage.create = function create(properties) {
                return new ZhuanpanLevelMessage(properties);
            };
    
            /**
             * Encodes the specified ZhuanpanLevelMessage message. Does not implicitly {@link pb.ZhuanpanLevelMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuanpanLevelMessage
             * @static
             * @param {pb.IZhuanpanLevelMessage} message ZhuanpanLevelMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuanpanLevelMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.money != null && Object.hasOwnProperty.call(message, "money"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.money);
                if (message.preMoney != null && Object.hasOwnProperty.call(message, "preMoney"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.preMoney);
                if (message.updateCount != null && Object.hasOwnProperty.call(message, "updateCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.updateCount);
                return writer;
            };
    
            /**
             * Decodes a ZhuanpanLevelMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuanpanLevelMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuanpanLevelMessage} ZhuanpanLevelMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuanpanLevelMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuanpanLevelMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.money = reader.int32();
                        break;
                    case 3:
                        message.preMoney = reader.int32();
                        break;
                    case 4:
                        message.updateCount = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuanpanLevelMessage;
        })();
    
        pb.ReJoinRoomReq = (function() {
    
            /**
             * Properties of a ReJoinRoomReq.
             * @memberof pb
             * @interface IReJoinRoomReq
             * @property {string|null} [roomId] ReJoinRoomReq roomId
             */
    
            /**
             * Constructs a new ReJoinRoomReq.
             * @memberof pb
             * @classdesc Represents a ReJoinRoomReq.
             * @implements IReJoinRoomReq
             * @constructor
             * @param {pb.IReJoinRoomReq=} [properties] Properties to set
             */
            function ReJoinRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReJoinRoomReq roomId.
             * @member {string} roomId
             * @memberof pb.ReJoinRoomReq
             * @instance
             */
            ReJoinRoomReq.prototype.roomId = "";
    
            /**
             * Creates a new ReJoinRoomReq instance using the specified properties.
             * @function create
             * @memberof pb.ReJoinRoomReq
             * @static
             * @param {pb.IReJoinRoomReq=} [properties] Properties to set
             * @returns {pb.ReJoinRoomReq} ReJoinRoomReq instance
             */
            ReJoinRoomReq.create = function create(properties) {
                return new ReJoinRoomReq(properties);
            };
    
            /**
             * Encodes the specified ReJoinRoomReq message. Does not implicitly {@link pb.ReJoinRoomReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ReJoinRoomReq
             * @static
             * @param {pb.IReJoinRoomReq} message ReJoinRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReJoinRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                return writer;
            };
    
            /**
             * Decodes a ReJoinRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReJoinRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReJoinRoomReq} ReJoinRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReJoinRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReJoinRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReJoinRoomReq;
        })();
    
        pb.ReJoinRoomRes = (function() {
    
            /**
             * Properties of a ReJoinRoomRes.
             * @memberof pb
             * @interface IReJoinRoomRes
             * @property {string|null} [roomId] ReJoinRoomRes roomId
             * @property {number|null} [timestamp] ReJoinRoomRes timestamp
             * @property {string|null} [opt] ReJoinRoomRes opt
             * @property {string|null} [sign] ReJoinRoomRes sign
             * @property {number|null} [code] ReJoinRoomRes code
             * @property {string|null} [sn] ReJoinRoomRes sn
             */
    
            /**
             * Constructs a new ReJoinRoomRes.
             * @memberof pb
             * @classdesc Represents a ReJoinRoomRes.
             * @implements IReJoinRoomRes
             * @constructor
             * @param {pb.IReJoinRoomRes=} [properties] Properties to set
             */
            function ReJoinRoomRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ReJoinRoomRes roomId.
             * @member {string} roomId
             * @memberof pb.ReJoinRoomRes
             * @instance
             */
            ReJoinRoomRes.prototype.roomId = "";
    
            /**
             * ReJoinRoomRes timestamp.
             * @member {number} timestamp
             * @memberof pb.ReJoinRoomRes
             * @instance
             */
            ReJoinRoomRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ReJoinRoomRes opt.
             * @member {string} opt
             * @memberof pb.ReJoinRoomRes
             * @instance
             */
            ReJoinRoomRes.prototype.opt = "";
    
            /**
             * ReJoinRoomRes sign.
             * @member {string} sign
             * @memberof pb.ReJoinRoomRes
             * @instance
             */
            ReJoinRoomRes.prototype.sign = "";
    
            /**
             * ReJoinRoomRes code.
             * @member {number} code
             * @memberof pb.ReJoinRoomRes
             * @instance
             */
            ReJoinRoomRes.prototype.code = 0;
    
            /**
             * ReJoinRoomRes sn.
             * @member {string} sn
             * @memberof pb.ReJoinRoomRes
             * @instance
             */
            ReJoinRoomRes.prototype.sn = "";
    
            /**
             * Creates a new ReJoinRoomRes instance using the specified properties.
             * @function create
             * @memberof pb.ReJoinRoomRes
             * @static
             * @param {pb.IReJoinRoomRes=} [properties] Properties to set
             * @returns {pb.ReJoinRoomRes} ReJoinRoomRes instance
             */
            ReJoinRoomRes.create = function create(properties) {
                return new ReJoinRoomRes(properties);
            };
    
            /**
             * Encodes the specified ReJoinRoomRes message. Does not implicitly {@link pb.ReJoinRoomRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ReJoinRoomRes
             * @static
             * @param {pb.IReJoinRoomRes} message ReJoinRoomRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReJoinRoomRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.code);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 100, wireType 2 =*/802).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a ReJoinRoomRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ReJoinRoomRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ReJoinRoomRes} ReJoinRoomRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReJoinRoomRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReJoinRoomRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.opt = reader.string();
                        break;
                    case 4:
                        message.sign = reader.string();
                        break;
                    case 5:
                        message.code = reader.int32();
                        break;
                    case 100:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ReJoinRoomRes;
        })();
    
        pb.ZhuangPanLevelReq = (function() {
    
            /**
             * Properties of a ZhuangPanLevelReq.
             * @memberof pb
             * @interface IZhuangPanLevelReq
             * @property {boolean|null} [userCoin] ZhuangPanLevelReq userCoin
             */
    
            /**
             * Constructs a new ZhuangPanLevelReq.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevelReq.
             * @implements IZhuangPanLevelReq
             * @constructor
             * @param {pb.IZhuangPanLevelReq=} [properties] Properties to set
             */
            function ZhuangPanLevelReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuangPanLevelReq userCoin.
             * @member {boolean} userCoin
             * @memberof pb.ZhuangPanLevelReq
             * @instance
             */
            ZhuangPanLevelReq.prototype.userCoin = false;
    
            /**
             * Creates a new ZhuangPanLevelReq instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevelReq
             * @static
             * @param {pb.IZhuangPanLevelReq=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevelReq} ZhuangPanLevelReq instance
             */
            ZhuangPanLevelReq.create = function create(properties) {
                return new ZhuangPanLevelReq(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevelReq message. Does not implicitly {@link pb.ZhuangPanLevelReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevelReq
             * @static
             * @param {pb.IZhuangPanLevelReq} message ZhuangPanLevelReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevelReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userCoin != null && Object.hasOwnProperty.call(message, "userCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.userCoin);
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevelReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevelReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevelReq} ZhuangPanLevelReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevelReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevelReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.userCoin = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevelReq;
        })();
    
        pb.ZhuangPanLevelRes = (function() {
    
            /**
             * Properties of a ZhuangPanLevelRes.
             * @memberof pb
             * @interface IZhuangPanLevelRes
             * @property {boolean|null} [userCoin] ZhuangPanLevelRes userCoin
             * @property {pb.IZhuanpanLevelMessage|null} [zhuanPan] ZhuangPanLevelRes zhuanPan
             * @property {number|null} [leftPoint] ZhuangPanLevelRes leftPoint
             * @property {number|null} [leftCoin] ZhuangPanLevelRes leftCoin
             * @property {number|null} [currentTimes] ZhuangPanLevelRes currentTimes
             * @property {number|null} [nextTimes] ZhuangPanLevelRes nextTimes
             * @property {number|null} [code] ZhuangPanLevelRes code
             */
    
            /**
             * Constructs a new ZhuangPanLevelRes.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevelRes.
             * @implements IZhuangPanLevelRes
             * @constructor
             * @param {pb.IZhuangPanLevelRes=} [properties] Properties to set
             */
            function ZhuangPanLevelRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuangPanLevelRes userCoin.
             * @member {boolean} userCoin
             * @memberof pb.ZhuangPanLevelRes
             * @instance
             */
            ZhuangPanLevelRes.prototype.userCoin = false;
    
            /**
             * ZhuangPanLevelRes zhuanPan.
             * @member {pb.IZhuanpanLevelMessage|null|undefined} zhuanPan
             * @memberof pb.ZhuangPanLevelRes
             * @instance
             */
            ZhuangPanLevelRes.prototype.zhuanPan = null;
    
            /**
             * ZhuangPanLevelRes leftPoint.
             * @member {number} leftPoint
             * @memberof pb.ZhuangPanLevelRes
             * @instance
             */
            ZhuangPanLevelRes.prototype.leftPoint = 0;
    
            /**
             * ZhuangPanLevelRes leftCoin.
             * @member {number} leftCoin
             * @memberof pb.ZhuangPanLevelRes
             * @instance
             */
            ZhuangPanLevelRes.prototype.leftCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ZhuangPanLevelRes currentTimes.
             * @member {number} currentTimes
             * @memberof pb.ZhuangPanLevelRes
             * @instance
             */
            ZhuangPanLevelRes.prototype.currentTimes = 0;
    
            /**
             * ZhuangPanLevelRes nextTimes.
             * @member {number} nextTimes
             * @memberof pb.ZhuangPanLevelRes
             * @instance
             */
            ZhuangPanLevelRes.prototype.nextTimes = 0;
    
            /**
             * ZhuangPanLevelRes code.
             * @member {number} code
             * @memberof pb.ZhuangPanLevelRes
             * @instance
             */
            ZhuangPanLevelRes.prototype.code = 0;
    
            /**
             * Creates a new ZhuangPanLevelRes instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevelRes
             * @static
             * @param {pb.IZhuangPanLevelRes=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevelRes} ZhuangPanLevelRes instance
             */
            ZhuangPanLevelRes.create = function create(properties) {
                return new ZhuangPanLevelRes(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevelRes message. Does not implicitly {@link pb.ZhuangPanLevelRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevelRes
             * @static
             * @param {pb.IZhuangPanLevelRes} message ZhuangPanLevelRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevelRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userCoin != null && Object.hasOwnProperty.call(message, "userCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.userCoin);
                if (message.zhuanPan != null && Object.hasOwnProperty.call(message, "zhuanPan"))
                    $root.pb.ZhuanpanLevelMessage.encode(message.zhuanPan, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.leftPoint != null && Object.hasOwnProperty.call(message, "leftPoint"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.leftPoint);
                if (message.leftCoin != null && Object.hasOwnProperty.call(message, "leftCoin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.leftCoin);
                if (message.currentTimes != null && Object.hasOwnProperty.call(message, "currentTimes"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.currentTimes);
                if (message.nextTimes != null && Object.hasOwnProperty.call(message, "nextTimes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.nextTimes);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevelRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevelRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevelRes} ZhuangPanLevelRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevelRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevelRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.userCoin = reader.bool();
                        break;
                    case 2:
                        message.zhuanPan = $root.pb.ZhuanpanLevelMessage.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.leftPoint = reader.int32();
                        break;
                    case 4:
                        message.leftCoin = reader.int64();
                        break;
                    case 5:
                        message.currentTimes = reader.int32();
                        break;
                    case 6:
                        message.nextTimes = reader.int32();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevelRes;
        })();
    
        pb.ZhuangPanLevelUpTipReq = (function() {
    
            /**
             * Properties of a ZhuangPanLevelUpTipReq.
             * @memberof pb
             * @interface IZhuangPanLevelUpTipReq
             */
    
            /**
             * Constructs a new ZhuangPanLevelUpTipReq.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevelUpTipReq.
             * @implements IZhuangPanLevelUpTipReq
             * @constructor
             * @param {pb.IZhuangPanLevelUpTipReq=} [properties] Properties to set
             */
            function ZhuangPanLevelUpTipReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ZhuangPanLevelUpTipReq instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevelUpTipReq
             * @static
             * @param {pb.IZhuangPanLevelUpTipReq=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevelUpTipReq} ZhuangPanLevelUpTipReq instance
             */
            ZhuangPanLevelUpTipReq.create = function create(properties) {
                return new ZhuangPanLevelUpTipReq(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevelUpTipReq message. Does not implicitly {@link pb.ZhuangPanLevelUpTipReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevelUpTipReq
             * @static
             * @param {pb.IZhuangPanLevelUpTipReq} message ZhuangPanLevelUpTipReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevelUpTipReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevelUpTipReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevelUpTipReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevelUpTipReq} ZhuangPanLevelUpTipReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevelUpTipReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevelUpTipReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevelUpTipReq;
        })();
    
        pb.ZhuangPanLevelUpTipRes = (function() {
    
            /**
             * Properties of a ZhuangPanLevelUpTipRes.
             * @memberof pb
             * @interface IZhuangPanLevelUpTipRes
             * @property {number|null} [code] ZhuangPanLevelUpTipRes code
             */
    
            /**
             * Constructs a new ZhuangPanLevelUpTipRes.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevelUpTipRes.
             * @implements IZhuangPanLevelUpTipRes
             * @constructor
             * @param {pb.IZhuangPanLevelUpTipRes=} [properties] Properties to set
             */
            function ZhuangPanLevelUpTipRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuangPanLevelUpTipRes code.
             * @member {number} code
             * @memberof pb.ZhuangPanLevelUpTipRes
             * @instance
             */
            ZhuangPanLevelUpTipRes.prototype.code = 0;
    
            /**
             * Creates a new ZhuangPanLevelUpTipRes instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevelUpTipRes
             * @static
             * @param {pb.IZhuangPanLevelUpTipRes=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevelUpTipRes} ZhuangPanLevelUpTipRes instance
             */
            ZhuangPanLevelUpTipRes.create = function create(properties) {
                return new ZhuangPanLevelUpTipRes(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevelUpTipRes message. Does not implicitly {@link pb.ZhuangPanLevelUpTipRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevelUpTipRes
             * @static
             * @param {pb.IZhuangPanLevelUpTipRes} message ZhuangPanLevelUpTipRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevelUpTipRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevelUpTipRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevelUpTipRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevelUpTipRes} ZhuangPanLevelUpTipRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevelUpTipRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevelUpTipRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevelUpTipRes;
        })();
    
        pb.CheckIfNeedAiInvoiteReq = (function() {
    
            /**
             * Properties of a CheckIfNeedAiInvoiteReq.
             * @memberof pb
             * @interface ICheckIfNeedAiInvoiteReq
             * @property {string|null} [opponentUid] CheckIfNeedAiInvoiteReq opponentUid
             */
    
            /**
             * Constructs a new CheckIfNeedAiInvoiteReq.
             * @memberof pb
             * @classdesc Represents a CheckIfNeedAiInvoiteReq.
             * @implements ICheckIfNeedAiInvoiteReq
             * @constructor
             * @param {pb.ICheckIfNeedAiInvoiteReq=} [properties] Properties to set
             */
            function CheckIfNeedAiInvoiteReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CheckIfNeedAiInvoiteReq opponentUid.
             * @member {string} opponentUid
             * @memberof pb.CheckIfNeedAiInvoiteReq
             * @instance
             */
            CheckIfNeedAiInvoiteReq.prototype.opponentUid = "";
    
            /**
             * Creates a new CheckIfNeedAiInvoiteReq instance using the specified properties.
             * @function create
             * @memberof pb.CheckIfNeedAiInvoiteReq
             * @static
             * @param {pb.ICheckIfNeedAiInvoiteReq=} [properties] Properties to set
             * @returns {pb.CheckIfNeedAiInvoiteReq} CheckIfNeedAiInvoiteReq instance
             */
            CheckIfNeedAiInvoiteReq.create = function create(properties) {
                return new CheckIfNeedAiInvoiteReq(properties);
            };
    
            /**
             * Encodes the specified CheckIfNeedAiInvoiteReq message. Does not implicitly {@link pb.CheckIfNeedAiInvoiteReq.verify|verify} messages.
             * @function encode
             * @memberof pb.CheckIfNeedAiInvoiteReq
             * @static
             * @param {pb.ICheckIfNeedAiInvoiteReq} message CheckIfNeedAiInvoiteReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckIfNeedAiInvoiteReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.opponentUid != null && Object.hasOwnProperty.call(message, "opponentUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.opponentUid);
                return writer;
            };
    
            /**
             * Decodes a CheckIfNeedAiInvoiteReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CheckIfNeedAiInvoiteReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CheckIfNeedAiInvoiteReq} CheckIfNeedAiInvoiteReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckIfNeedAiInvoiteReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CheckIfNeedAiInvoiteReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.opponentUid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CheckIfNeedAiInvoiteReq;
        })();
    
        pb.CheckIfNeedAiInvoiteRes = (function() {
    
            /**
             * Properties of a CheckIfNeedAiInvoiteRes.
             * @memberof pb
             * @interface ICheckIfNeedAiInvoiteRes
             * @property {string|null} [opponentUid] CheckIfNeedAiInvoiteRes opponentUid
             * @property {boolean|null} [needInvited] CheckIfNeedAiInvoiteRes needInvited
             */
    
            /**
             * Constructs a new CheckIfNeedAiInvoiteRes.
             * @memberof pb
             * @classdesc Represents a CheckIfNeedAiInvoiteRes.
             * @implements ICheckIfNeedAiInvoiteRes
             * @constructor
             * @param {pb.ICheckIfNeedAiInvoiteRes=} [properties] Properties to set
             */
            function CheckIfNeedAiInvoiteRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * CheckIfNeedAiInvoiteRes opponentUid.
             * @member {string} opponentUid
             * @memberof pb.CheckIfNeedAiInvoiteRes
             * @instance
             */
            CheckIfNeedAiInvoiteRes.prototype.opponentUid = "";
    
            /**
             * CheckIfNeedAiInvoiteRes needInvited.
             * @member {boolean} needInvited
             * @memberof pb.CheckIfNeedAiInvoiteRes
             * @instance
             */
            CheckIfNeedAiInvoiteRes.prototype.needInvited = false;
    
            /**
             * Creates a new CheckIfNeedAiInvoiteRes instance using the specified properties.
             * @function create
             * @memberof pb.CheckIfNeedAiInvoiteRes
             * @static
             * @param {pb.ICheckIfNeedAiInvoiteRes=} [properties] Properties to set
             * @returns {pb.CheckIfNeedAiInvoiteRes} CheckIfNeedAiInvoiteRes instance
             */
            CheckIfNeedAiInvoiteRes.create = function create(properties) {
                return new CheckIfNeedAiInvoiteRes(properties);
            };
    
            /**
             * Encodes the specified CheckIfNeedAiInvoiteRes message. Does not implicitly {@link pb.CheckIfNeedAiInvoiteRes.verify|verify} messages.
             * @function encode
             * @memberof pb.CheckIfNeedAiInvoiteRes
             * @static
             * @param {pb.ICheckIfNeedAiInvoiteRes} message CheckIfNeedAiInvoiteRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckIfNeedAiInvoiteRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.opponentUid != null && Object.hasOwnProperty.call(message, "opponentUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.opponentUid);
                if (message.needInvited != null && Object.hasOwnProperty.call(message, "needInvited"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.needInvited);
                return writer;
            };
    
            /**
             * Decodes a CheckIfNeedAiInvoiteRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CheckIfNeedAiInvoiteRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CheckIfNeedAiInvoiteRes} CheckIfNeedAiInvoiteRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckIfNeedAiInvoiteRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CheckIfNeedAiInvoiteRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.opponentUid = reader.string();
                        break;
                    case 2:
                        message.needInvited = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return CheckIfNeedAiInvoiteRes;
        })();
    
        pb.SecUnvarnishedReq = (function() {
    
            /**
             * Properties of a SecUnvarnishedReq.
             * @memberof pb
             * @interface ISecUnvarnishedReq
             * @property {Uint8Array|null} [data] SecUnvarnishedReq data
             */
    
            /**
             * Constructs a new SecUnvarnishedReq.
             * @memberof pb
             * @classdesc Represents a SecUnvarnishedReq.
             * @implements ISecUnvarnishedReq
             * @constructor
             * @param {pb.ISecUnvarnishedReq=} [properties] Properties to set
             */
            function SecUnvarnishedReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SecUnvarnishedReq data.
             * @member {Uint8Array} data
             * @memberof pb.SecUnvarnishedReq
             * @instance
             */
            SecUnvarnishedReq.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new SecUnvarnishedReq instance using the specified properties.
             * @function create
             * @memberof pb.SecUnvarnishedReq
             * @static
             * @param {pb.ISecUnvarnishedReq=} [properties] Properties to set
             * @returns {pb.SecUnvarnishedReq} SecUnvarnishedReq instance
             */
            SecUnvarnishedReq.create = function create(properties) {
                return new SecUnvarnishedReq(properties);
            };
    
            /**
             * Encodes the specified SecUnvarnishedReq message. Does not implicitly {@link pb.SecUnvarnishedReq.verify|verify} messages.
             * @function encode
             * @memberof pb.SecUnvarnishedReq
             * @static
             * @param {pb.ISecUnvarnishedReq} message SecUnvarnishedReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecUnvarnishedReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                return writer;
            };
    
            /**
             * Decodes a SecUnvarnishedReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SecUnvarnishedReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SecUnvarnishedReq} SecUnvarnishedReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecUnvarnishedReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SecUnvarnishedReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SecUnvarnishedReq;
        })();
    
        pb.SecUnvarnishedRes = (function() {
    
            /**
             * Properties of a SecUnvarnishedRes.
             * @memberof pb
             * @interface ISecUnvarnishedRes
             * @property {number|null} [code] SecUnvarnishedRes code
             * @property {string|null} [msg] SecUnvarnishedRes msg
             * @property {Uint8Array|null} [data] SecUnvarnishedRes data
             */
    
            /**
             * Constructs a new SecUnvarnishedRes.
             * @memberof pb
             * @classdesc Represents a SecUnvarnishedRes.
             * @implements ISecUnvarnishedRes
             * @constructor
             * @param {pb.ISecUnvarnishedRes=} [properties] Properties to set
             */
            function SecUnvarnishedRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SecUnvarnishedRes code.
             * @member {number} code
             * @memberof pb.SecUnvarnishedRes
             * @instance
             */
            SecUnvarnishedRes.prototype.code = 0;
    
            /**
             * SecUnvarnishedRes msg.
             * @member {string} msg
             * @memberof pb.SecUnvarnishedRes
             * @instance
             */
            SecUnvarnishedRes.prototype.msg = "";
    
            /**
             * SecUnvarnishedRes data.
             * @member {Uint8Array} data
             * @memberof pb.SecUnvarnishedRes
             * @instance
             */
            SecUnvarnishedRes.prototype.data = $util.newBuffer([]);
    
            /**
             * Creates a new SecUnvarnishedRes instance using the specified properties.
             * @function create
             * @memberof pb.SecUnvarnishedRes
             * @static
             * @param {pb.ISecUnvarnishedRes=} [properties] Properties to set
             * @returns {pb.SecUnvarnishedRes} SecUnvarnishedRes instance
             */
            SecUnvarnishedRes.create = function create(properties) {
                return new SecUnvarnishedRes(properties);
            };
    
            /**
             * Encodes the specified SecUnvarnishedRes message. Does not implicitly {@link pb.SecUnvarnishedRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SecUnvarnishedRes
             * @static
             * @param {pb.ISecUnvarnishedRes} message SecUnvarnishedRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SecUnvarnishedRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);
                return writer;
            };
    
            /**
             * Decodes a SecUnvarnishedRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SecUnvarnishedRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SecUnvarnishedRes} SecUnvarnishedRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SecUnvarnishedRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SecUnvarnishedRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SecUnvarnishedRes;
        })();
    
        pb.WinOrLoseRightNowReq = (function() {
    
            /**
             * Properties of a WinOrLoseRightNowReq.
             * @memberof pb
             * @interface IWinOrLoseRightNowReq
             * @property {boolean|null} [win] WinOrLoseRightNowReq win
             */
    
            /**
             * Constructs a new WinOrLoseRightNowReq.
             * @memberof pb
             * @classdesc Represents a WinOrLoseRightNowReq.
             * @implements IWinOrLoseRightNowReq
             * @constructor
             * @param {pb.IWinOrLoseRightNowReq=} [properties] Properties to set
             */
            function WinOrLoseRightNowReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * WinOrLoseRightNowReq win.
             * @member {boolean} win
             * @memberof pb.WinOrLoseRightNowReq
             * @instance
             */
            WinOrLoseRightNowReq.prototype.win = false;
    
            /**
             * Creates a new WinOrLoseRightNowReq instance using the specified properties.
             * @function create
             * @memberof pb.WinOrLoseRightNowReq
             * @static
             * @param {pb.IWinOrLoseRightNowReq=} [properties] Properties to set
             * @returns {pb.WinOrLoseRightNowReq} WinOrLoseRightNowReq instance
             */
            WinOrLoseRightNowReq.create = function create(properties) {
                return new WinOrLoseRightNowReq(properties);
            };
    
            /**
             * Encodes the specified WinOrLoseRightNowReq message. Does not implicitly {@link pb.WinOrLoseRightNowReq.verify|verify} messages.
             * @function encode
             * @memberof pb.WinOrLoseRightNowReq
             * @static
             * @param {pb.IWinOrLoseRightNowReq} message WinOrLoseRightNowReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WinOrLoseRightNowReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.win != null && Object.hasOwnProperty.call(message, "win"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.win);
                return writer;
            };
    
            /**
             * Decodes a WinOrLoseRightNowReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.WinOrLoseRightNowReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.WinOrLoseRightNowReq} WinOrLoseRightNowReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WinOrLoseRightNowReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WinOrLoseRightNowReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.win = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return WinOrLoseRightNowReq;
        })();
    
        pb.AddCrystalCoinReq = (function() {
    
            /**
             * Properties of an AddCrystalCoinReq.
             * @memberof pb
             * @interface IAddCrystalCoinReq
             * @property {number|null} [crystalNum] AddCrystalCoinReq crystalNum
             */
    
            /**
             * Constructs a new AddCrystalCoinReq.
             * @memberof pb
             * @classdesc Represents an AddCrystalCoinReq.
             * @implements IAddCrystalCoinReq
             * @constructor
             * @param {pb.IAddCrystalCoinReq=} [properties] Properties to set
             */
            function AddCrystalCoinReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AddCrystalCoinReq crystalNum.
             * @member {number} crystalNum
             * @memberof pb.AddCrystalCoinReq
             * @instance
             */
            AddCrystalCoinReq.prototype.crystalNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new AddCrystalCoinReq instance using the specified properties.
             * @function create
             * @memberof pb.AddCrystalCoinReq
             * @static
             * @param {pb.IAddCrystalCoinReq=} [properties] Properties to set
             * @returns {pb.AddCrystalCoinReq} AddCrystalCoinReq instance
             */
            AddCrystalCoinReq.create = function create(properties) {
                return new AddCrystalCoinReq(properties);
            };
    
            /**
             * Encodes the specified AddCrystalCoinReq message. Does not implicitly {@link pb.AddCrystalCoinReq.verify|verify} messages.
             * @function encode
             * @memberof pb.AddCrystalCoinReq
             * @static
             * @param {pb.IAddCrystalCoinReq} message AddCrystalCoinReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddCrystalCoinReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.crystalNum != null && Object.hasOwnProperty.call(message, "crystalNum"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.crystalNum);
                return writer;
            };
    
            /**
             * Decodes an AddCrystalCoinReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AddCrystalCoinReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AddCrystalCoinReq} AddCrystalCoinReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddCrystalCoinReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AddCrystalCoinReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.crystalNum = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AddCrystalCoinReq;
        })();
    
        pb.AddCrystalCoinRes = (function() {
    
            /**
             * Properties of an AddCrystalCoinRes.
             * @memberof pb
             * @interface IAddCrystalCoinRes
             * @property {number|null} [crystalCoin] AddCrystalCoinRes crystalCoin
             */
    
            /**
             * Constructs a new AddCrystalCoinRes.
             * @memberof pb
             * @classdesc Represents an AddCrystalCoinRes.
             * @implements IAddCrystalCoinRes
             * @constructor
             * @param {pb.IAddCrystalCoinRes=} [properties] Properties to set
             */
            function AddCrystalCoinRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AddCrystalCoinRes crystalCoin.
             * @member {number} crystalCoin
             * @memberof pb.AddCrystalCoinRes
             * @instance
             */
            AddCrystalCoinRes.prototype.crystalCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new AddCrystalCoinRes instance using the specified properties.
             * @function create
             * @memberof pb.AddCrystalCoinRes
             * @static
             * @param {pb.IAddCrystalCoinRes=} [properties] Properties to set
             * @returns {pb.AddCrystalCoinRes} AddCrystalCoinRes instance
             */
            AddCrystalCoinRes.create = function create(properties) {
                return new AddCrystalCoinRes(properties);
            };
    
            /**
             * Encodes the specified AddCrystalCoinRes message. Does not implicitly {@link pb.AddCrystalCoinRes.verify|verify} messages.
             * @function encode
             * @memberof pb.AddCrystalCoinRes
             * @static
             * @param {pb.IAddCrystalCoinRes} message AddCrystalCoinRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddCrystalCoinRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.crystalCoin != null && Object.hasOwnProperty.call(message, "crystalCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.crystalCoin);
                return writer;
            };
    
            /**
             * Decodes an AddCrystalCoinRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AddCrystalCoinRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AddCrystalCoinRes} AddCrystalCoinRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddCrystalCoinRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AddCrystalCoinRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.crystalCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AddCrystalCoinRes;
        })();
    
        pb.AddCoinReq = (function() {
    
            /**
             * Properties of an AddCoinReq.
             * @memberof pb
             * @interface IAddCoinReq
             * @property {number|null} [crystalNum] AddCoinReq crystalNum
             */
    
            /**
             * Constructs a new AddCoinReq.
             * @memberof pb
             * @classdesc Represents an AddCoinReq.
             * @implements IAddCoinReq
             * @constructor
             * @param {pb.IAddCoinReq=} [properties] Properties to set
             */
            function AddCoinReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AddCoinReq crystalNum.
             * @member {number} crystalNum
             * @memberof pb.AddCoinReq
             * @instance
             */
            AddCoinReq.prototype.crystalNum = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new AddCoinReq instance using the specified properties.
             * @function create
             * @memberof pb.AddCoinReq
             * @static
             * @param {pb.IAddCoinReq=} [properties] Properties to set
             * @returns {pb.AddCoinReq} AddCoinReq instance
             */
            AddCoinReq.create = function create(properties) {
                return new AddCoinReq(properties);
            };
    
            /**
             * Encodes the specified AddCoinReq message. Does not implicitly {@link pb.AddCoinReq.verify|verify} messages.
             * @function encode
             * @memberof pb.AddCoinReq
             * @static
             * @param {pb.IAddCoinReq} message AddCoinReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddCoinReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.crystalNum != null && Object.hasOwnProperty.call(message, "crystalNum"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.crystalNum);
                return writer;
            };
    
            /**
             * Decodes an AddCoinReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AddCoinReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AddCoinReq} AddCoinReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddCoinReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AddCoinReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.crystalNum = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AddCoinReq;
        })();
    
        pb.AddCoinRes = (function() {
    
            /**
             * Properties of an AddCoinRes.
             * @memberof pb
             * @interface IAddCoinRes
             * @property {number|null} [crystalCoin] AddCoinRes crystalCoin
             */
    
            /**
             * Constructs a new AddCoinRes.
             * @memberof pb
             * @classdesc Represents an AddCoinRes.
             * @implements IAddCoinRes
             * @constructor
             * @param {pb.IAddCoinRes=} [properties] Properties to set
             */
            function AddCoinRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AddCoinRes crystalCoin.
             * @member {number} crystalCoin
             * @memberof pb.AddCoinRes
             * @instance
             */
            AddCoinRes.prototype.crystalCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new AddCoinRes instance using the specified properties.
             * @function create
             * @memberof pb.AddCoinRes
             * @static
             * @param {pb.IAddCoinRes=} [properties] Properties to set
             * @returns {pb.AddCoinRes} AddCoinRes instance
             */
            AddCoinRes.create = function create(properties) {
                return new AddCoinRes(properties);
            };
    
            /**
             * Encodes the specified AddCoinRes message. Does not implicitly {@link pb.AddCoinRes.verify|verify} messages.
             * @function encode
             * @memberof pb.AddCoinRes
             * @static
             * @param {pb.IAddCoinRes} message AddCoinRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddCoinRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.crystalCoin != null && Object.hasOwnProperty.call(message, "crystalCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.crystalCoin);
                return writer;
            };
    
            /**
             * Decodes an AddCoinRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AddCoinRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AddCoinRes} AddCoinRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddCoinRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AddCoinRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.crystalCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AddCoinRes;
        })();
    
        pb.TaskInfoReq = (function() {
    
            /**
             * Properties of a TaskInfoReq.
             * @memberof pb
             * @interface ITaskInfoReq
             */
    
            /**
             * Constructs a new TaskInfoReq.
             * @memberof pb
             * @classdesc Represents a TaskInfoReq.
             * @implements ITaskInfoReq
             * @constructor
             * @param {pb.ITaskInfoReq=} [properties] Properties to set
             */
            function TaskInfoReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new TaskInfoReq instance using the specified properties.
             * @function create
             * @memberof pb.TaskInfoReq
             * @static
             * @param {pb.ITaskInfoReq=} [properties] Properties to set
             * @returns {pb.TaskInfoReq} TaskInfoReq instance
             */
            TaskInfoReq.create = function create(properties) {
                return new TaskInfoReq(properties);
            };
    
            /**
             * Encodes the specified TaskInfoReq message. Does not implicitly {@link pb.TaskInfoReq.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskInfoReq
             * @static
             * @param {pb.ITaskInfoReq} message TaskInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskInfoReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a TaskInfoReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskInfoReq} TaskInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskInfoReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskInfoReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskInfoReq;
        })();
    
        pb.TaskInfoRes = (function() {
    
            /**
             * Properties of a TaskInfoRes.
             * @memberof pb
             * @interface ITaskInfoRes
             * @property {pb.IModuleTask|null} [task] TaskInfoRes task
             */
    
            /**
             * Constructs a new TaskInfoRes.
             * @memberof pb
             * @classdesc Represents a TaskInfoRes.
             * @implements ITaskInfoRes
             * @constructor
             * @param {pb.ITaskInfoRes=} [properties] Properties to set
             */
            function TaskInfoRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskInfoRes task.
             * @member {pb.IModuleTask|null|undefined} task
             * @memberof pb.TaskInfoRes
             * @instance
             */
            TaskInfoRes.prototype.task = null;
    
            /**
             * Creates a new TaskInfoRes instance using the specified properties.
             * @function create
             * @memberof pb.TaskInfoRes
             * @static
             * @param {pb.ITaskInfoRes=} [properties] Properties to set
             * @returns {pb.TaskInfoRes} TaskInfoRes instance
             */
            TaskInfoRes.create = function create(properties) {
                return new TaskInfoRes(properties);
            };
    
            /**
             * Encodes the specified TaskInfoRes message. Does not implicitly {@link pb.TaskInfoRes.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskInfoRes
             * @static
             * @param {pb.ITaskInfoRes} message TaskInfoRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskInfoRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.task != null && Object.hasOwnProperty.call(message, "task"))
                    $root.pb.ModuleTask.encode(message.task, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a TaskInfoRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskInfoRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskInfoRes} TaskInfoRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskInfoRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskInfoRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.task = $root.pb.ModuleTask.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskInfoRes;
        })();
    
        pb.TaskRewardReq = (function() {
    
            /**
             * Properties of a TaskRewardReq.
             * @memberof pb
             * @interface ITaskRewardReq
             * @property {number|null} [taskId] TaskRewardReq taskId
             */
    
            /**
             * Constructs a new TaskRewardReq.
             * @memberof pb
             * @classdesc Represents a TaskRewardReq.
             * @implements ITaskRewardReq
             * @constructor
             * @param {pb.ITaskRewardReq=} [properties] Properties to set
             */
            function TaskRewardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskRewardReq taskId.
             * @member {number} taskId
             * @memberof pb.TaskRewardReq
             * @instance
             */
            TaskRewardReq.prototype.taskId = 0;
    
            /**
             * Creates a new TaskRewardReq instance using the specified properties.
             * @function create
             * @memberof pb.TaskRewardReq
             * @static
             * @param {pb.ITaskRewardReq=} [properties] Properties to set
             * @returns {pb.TaskRewardReq} TaskRewardReq instance
             */
            TaskRewardReq.create = function create(properties) {
                return new TaskRewardReq(properties);
            };
    
            /**
             * Encodes the specified TaskRewardReq message. Does not implicitly {@link pb.TaskRewardReq.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskRewardReq
             * @static
             * @param {pb.ITaskRewardReq} message TaskRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskRewardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
                return writer;
            };
    
            /**
             * Decodes a TaskRewardReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskRewardReq} TaskRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskRewardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskRewardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskRewardReq;
        })();
    
        pb.TaskRewardRes = (function() {
    
            /**
             * Properties of a TaskRewardRes.
             * @memberof pb
             * @interface ITaskRewardRes
             * @property {number|null} [code] TaskRewardRes code
             * @property {string|null} [msg] TaskRewardRes msg
             * @property {number|null} [taskId] TaskRewardRes taskId
             * @property {Array.<pb.IRewardItem>|null} [itemList] TaskRewardRes itemList
             */
    
            /**
             * Constructs a new TaskRewardRes.
             * @memberof pb
             * @classdesc Represents a TaskRewardRes.
             * @implements ITaskRewardRes
             * @constructor
             * @param {pb.ITaskRewardRes=} [properties] Properties to set
             */
            function TaskRewardRes(properties) {
                this.itemList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskRewardRes code.
             * @member {number} code
             * @memberof pb.TaskRewardRes
             * @instance
             */
            TaskRewardRes.prototype.code = 0;
    
            /**
             * TaskRewardRes msg.
             * @member {string} msg
             * @memberof pb.TaskRewardRes
             * @instance
             */
            TaskRewardRes.prototype.msg = "";
    
            /**
             * TaskRewardRes taskId.
             * @member {number} taskId
             * @memberof pb.TaskRewardRes
             * @instance
             */
            TaskRewardRes.prototype.taskId = 0;
    
            /**
             * TaskRewardRes itemList.
             * @member {Array.<pb.IRewardItem>} itemList
             * @memberof pb.TaskRewardRes
             * @instance
             */
            TaskRewardRes.prototype.itemList = $util.emptyArray;
    
            /**
             * Creates a new TaskRewardRes instance using the specified properties.
             * @function create
             * @memberof pb.TaskRewardRes
             * @static
             * @param {pb.ITaskRewardRes=} [properties] Properties to set
             * @returns {pb.TaskRewardRes} TaskRewardRes instance
             */
            TaskRewardRes.create = function create(properties) {
                return new TaskRewardRes(properties);
            };
    
            /**
             * Encodes the specified TaskRewardRes message. Does not implicitly {@link pb.TaskRewardRes.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskRewardRes
             * @static
             * @param {pb.ITaskRewardRes} message TaskRewardRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskRewardRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.itemList != null && message.itemList.length)
                    for (var i = 0; i < message.itemList.length; ++i)
                        $root.pb.RewardItem.encode(message.itemList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.taskId);
                return writer;
            };
    
            /**
             * Decodes a TaskRewardRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskRewardRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskRewardRes} TaskRewardRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskRewardRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskRewardRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 4:
                        message.taskId = reader.int32();
                        break;
                    case 3:
                        if (!(message.itemList && message.itemList.length))
                            message.itemList = [];
                        message.itemList.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskRewardRes;
        })();
    
        pb.EnterYuYinFanReq = (function() {
    
            /**
             * Properties of an EnterYuYinFanReq.
             * @memberof pb
             * @interface IEnterYuYinFanReq
             */
    
            /**
             * Constructs a new EnterYuYinFanReq.
             * @memberof pb
             * @classdesc Represents an EnterYuYinFanReq.
             * @implements IEnterYuYinFanReq
             * @constructor
             * @param {pb.IEnterYuYinFanReq=} [properties] Properties to set
             */
            function EnterYuYinFanReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new EnterYuYinFanReq instance using the specified properties.
             * @function create
             * @memberof pb.EnterYuYinFanReq
             * @static
             * @param {pb.IEnterYuYinFanReq=} [properties] Properties to set
             * @returns {pb.EnterYuYinFanReq} EnterYuYinFanReq instance
             */
            EnterYuYinFanReq.create = function create(properties) {
                return new EnterYuYinFanReq(properties);
            };
    
            /**
             * Encodes the specified EnterYuYinFanReq message. Does not implicitly {@link pb.EnterYuYinFanReq.verify|verify} messages.
             * @function encode
             * @memberof pb.EnterYuYinFanReq
             * @static
             * @param {pb.IEnterYuYinFanReq} message EnterYuYinFanReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnterYuYinFanReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes an EnterYuYinFanReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.EnterYuYinFanReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.EnterYuYinFanReq} EnterYuYinFanReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnterYuYinFanReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EnterYuYinFanReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return EnterYuYinFanReq;
        })();
    
        pb.EnterYuYinFanRes = (function() {
    
            /**
             * Properties of an EnterYuYinFanRes.
             * @memberof pb
             * @interface IEnterYuYinFanRes
             */
    
            /**
             * Constructs a new EnterYuYinFanRes.
             * @memberof pb
             * @classdesc Represents an EnterYuYinFanRes.
             * @implements IEnterYuYinFanRes
             * @constructor
             * @param {pb.IEnterYuYinFanRes=} [properties] Properties to set
             */
            function EnterYuYinFanRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new EnterYuYinFanRes instance using the specified properties.
             * @function create
             * @memberof pb.EnterYuYinFanRes
             * @static
             * @param {pb.IEnterYuYinFanRes=} [properties] Properties to set
             * @returns {pb.EnterYuYinFanRes} EnterYuYinFanRes instance
             */
            EnterYuYinFanRes.create = function create(properties) {
                return new EnterYuYinFanRes(properties);
            };
    
            /**
             * Encodes the specified EnterYuYinFanRes message. Does not implicitly {@link pb.EnterYuYinFanRes.verify|verify} messages.
             * @function encode
             * @memberof pb.EnterYuYinFanRes
             * @static
             * @param {pb.IEnterYuYinFanRes} message EnterYuYinFanRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnterYuYinFanRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes an EnterYuYinFanRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.EnterYuYinFanRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.EnterYuYinFanRes} EnterYuYinFanRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnterYuYinFanRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EnterYuYinFanRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return EnterYuYinFanRes;
        })();
    
        pb.TaskInfo1Req = (function() {
    
            /**
             * Properties of a TaskInfo1Req.
             * @memberof pb
             * @interface ITaskInfo1Req
             */
    
            /**
             * Constructs a new TaskInfo1Req.
             * @memberof pb
             * @classdesc Represents a TaskInfo1Req.
             * @implements ITaskInfo1Req
             * @constructor
             * @param {pb.ITaskInfo1Req=} [properties] Properties to set
             */
            function TaskInfo1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new TaskInfo1Req instance using the specified properties.
             * @function create
             * @memberof pb.TaskInfo1Req
             * @static
             * @param {pb.ITaskInfo1Req=} [properties] Properties to set
             * @returns {pb.TaskInfo1Req} TaskInfo1Req instance
             */
            TaskInfo1Req.create = function create(properties) {
                return new TaskInfo1Req(properties);
            };
    
            /**
             * Encodes the specified TaskInfo1Req message. Does not implicitly {@link pb.TaskInfo1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskInfo1Req
             * @static
             * @param {pb.ITaskInfo1Req} message TaskInfo1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskInfo1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a TaskInfo1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskInfo1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskInfo1Req} TaskInfo1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskInfo1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskInfo1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskInfo1Req;
        })();
    
        pb.TaskInfo1Res = (function() {
    
            /**
             * Properties of a TaskInfo1Res.
             * @memberof pb
             * @interface ITaskInfo1Res
             * @property {pb.IModuleTask|null} [task] TaskInfo1Res task
             * @property {number|null} [curPoint] TaskInfo1Res curPoint
             */
    
            /**
             * Constructs a new TaskInfo1Res.
             * @memberof pb
             * @classdesc Represents a TaskInfo1Res.
             * @implements ITaskInfo1Res
             * @constructor
             * @param {pb.ITaskInfo1Res=} [properties] Properties to set
             */
            function TaskInfo1Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskInfo1Res task.
             * @member {pb.IModuleTask|null|undefined} task
             * @memberof pb.TaskInfo1Res
             * @instance
             */
            TaskInfo1Res.prototype.task = null;
    
            /**
             * TaskInfo1Res curPoint.
             * @member {number} curPoint
             * @memberof pb.TaskInfo1Res
             * @instance
             */
            TaskInfo1Res.prototype.curPoint = 0;
    
            /**
             * Creates a new TaskInfo1Res instance using the specified properties.
             * @function create
             * @memberof pb.TaskInfo1Res
             * @static
             * @param {pb.ITaskInfo1Res=} [properties] Properties to set
             * @returns {pb.TaskInfo1Res} TaskInfo1Res instance
             */
            TaskInfo1Res.create = function create(properties) {
                return new TaskInfo1Res(properties);
            };
    
            /**
             * Encodes the specified TaskInfo1Res message. Does not implicitly {@link pb.TaskInfo1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskInfo1Res
             * @static
             * @param {pb.ITaskInfo1Res} message TaskInfo1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskInfo1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.task != null && Object.hasOwnProperty.call(message, "task"))
                    $root.pb.ModuleTask.encode(message.task, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.curPoint != null && Object.hasOwnProperty.call(message, "curPoint"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.curPoint);
                return writer;
            };
    
            /**
             * Decodes a TaskInfo1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskInfo1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskInfo1Res} TaskInfo1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskInfo1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskInfo1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.task = $root.pb.ModuleTask.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.curPoint = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskInfo1Res;
        })();
    
        pb.TaskReward1Req = (function() {
    
            /**
             * Properties of a TaskReward1Req.
             * @memberof pb
             * @interface ITaskReward1Req
             * @property {number|null} [taskId] TaskReward1Req taskId
             */
    
            /**
             * Constructs a new TaskReward1Req.
             * @memberof pb
             * @classdesc Represents a TaskReward1Req.
             * @implements ITaskReward1Req
             * @constructor
             * @param {pb.ITaskReward1Req=} [properties] Properties to set
             */
            function TaskReward1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskReward1Req taskId.
             * @member {number} taskId
             * @memberof pb.TaskReward1Req
             * @instance
             */
            TaskReward1Req.prototype.taskId = 0;
    
            /**
             * Creates a new TaskReward1Req instance using the specified properties.
             * @function create
             * @memberof pb.TaskReward1Req
             * @static
             * @param {pb.ITaskReward1Req=} [properties] Properties to set
             * @returns {pb.TaskReward1Req} TaskReward1Req instance
             */
            TaskReward1Req.create = function create(properties) {
                return new TaskReward1Req(properties);
            };
    
            /**
             * Encodes the specified TaskReward1Req message. Does not implicitly {@link pb.TaskReward1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskReward1Req
             * @static
             * @param {pb.ITaskReward1Req} message TaskReward1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskReward1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
                return writer;
            };
    
            /**
             * Decodes a TaskReward1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskReward1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskReward1Req} TaskReward1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskReward1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskReward1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.taskId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskReward1Req;
        })();
    
        pb.TaskReward1Res = (function() {
    
            /**
             * Properties of a TaskReward1Res.
             * @memberof pb
             * @interface ITaskReward1Res
             * @property {number|null} [code] TaskReward1Res code
             * @property {string|null} [msg] TaskReward1Res msg
             * @property {number|null} [taskId] TaskReward1Res taskId
             * @property {Array.<pb.IRewardItem>|null} [itemList] TaskReward1Res itemList
             */
    
            /**
             * Constructs a new TaskReward1Res.
             * @memberof pb
             * @classdesc Represents a TaskReward1Res.
             * @implements ITaskReward1Res
             * @constructor
             * @param {pb.ITaskReward1Res=} [properties] Properties to set
             */
            function TaskReward1Res(properties) {
                this.itemList = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskReward1Res code.
             * @member {number} code
             * @memberof pb.TaskReward1Res
             * @instance
             */
            TaskReward1Res.prototype.code = 0;
    
            /**
             * TaskReward1Res msg.
             * @member {string} msg
             * @memberof pb.TaskReward1Res
             * @instance
             */
            TaskReward1Res.prototype.msg = "";
    
            /**
             * TaskReward1Res taskId.
             * @member {number} taskId
             * @memberof pb.TaskReward1Res
             * @instance
             */
            TaskReward1Res.prototype.taskId = 0;
    
            /**
             * TaskReward1Res itemList.
             * @member {Array.<pb.IRewardItem>} itemList
             * @memberof pb.TaskReward1Res
             * @instance
             */
            TaskReward1Res.prototype.itemList = $util.emptyArray;
    
            /**
             * Creates a new TaskReward1Res instance using the specified properties.
             * @function create
             * @memberof pb.TaskReward1Res
             * @static
             * @param {pb.ITaskReward1Res=} [properties] Properties to set
             * @returns {pb.TaskReward1Res} TaskReward1Res instance
             */
            TaskReward1Res.create = function create(properties) {
                return new TaskReward1Res(properties);
            };
    
            /**
             * Encodes the specified TaskReward1Res message. Does not implicitly {@link pb.TaskReward1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskReward1Res
             * @static
             * @param {pb.ITaskReward1Res} message TaskReward1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskReward1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.itemList != null && message.itemList.length)
                    for (var i = 0; i < message.itemList.length; ++i)
                        $root.pb.RewardItem.encode(message.itemList[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.taskId != null && Object.hasOwnProperty.call(message, "taskId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.taskId);
                return writer;
            };
    
            /**
             * Decodes a TaskReward1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskReward1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskReward1Res} TaskReward1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskReward1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskReward1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 4:
                        message.taskId = reader.int32();
                        break;
                    case 3:
                        if (!(message.itemList && message.itemList.length))
                            message.itemList = [];
                        message.itemList.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskReward1Res;
        })();
    
        pb.ZhuanpanLevel1Message = (function() {
    
            /**
             * Properties of a ZhuanpanLevel1Message.
             * @memberof pb
             * @interface IZhuanpanLevel1Message
             * @property {number|null} [id] ZhuanpanLevel1Message id
             * @property {number|null} [money] ZhuanpanLevel1Message money
             * @property {number|null} [preMoney] ZhuanpanLevel1Message preMoney
             * @property {number|null} [updateCount] ZhuanpanLevel1Message updateCount
             * @property {number|null} [type] ZhuanpanLevel1Message type
             */
    
            /**
             * Constructs a new ZhuanpanLevel1Message.
             * @memberof pb
             * @classdesc Represents a ZhuanpanLevel1Message.
             * @implements IZhuanpanLevel1Message
             * @constructor
             * @param {pb.IZhuanpanLevel1Message=} [properties] Properties to set
             */
            function ZhuanpanLevel1Message(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuanpanLevel1Message id.
             * @member {number} id
             * @memberof pb.ZhuanpanLevel1Message
             * @instance
             */
            ZhuanpanLevel1Message.prototype.id = 0;
    
            /**
             * ZhuanpanLevel1Message money.
             * @member {number} money
             * @memberof pb.ZhuanpanLevel1Message
             * @instance
             */
            ZhuanpanLevel1Message.prototype.money = 0;
    
            /**
             * ZhuanpanLevel1Message preMoney.
             * @member {number} preMoney
             * @memberof pb.ZhuanpanLevel1Message
             * @instance
             */
            ZhuanpanLevel1Message.prototype.preMoney = 0;
    
            /**
             * ZhuanpanLevel1Message updateCount.
             * @member {number} updateCount
             * @memberof pb.ZhuanpanLevel1Message
             * @instance
             */
            ZhuanpanLevel1Message.prototype.updateCount = 0;
    
            /**
             * ZhuanpanLevel1Message type.
             * @member {number} type
             * @memberof pb.ZhuanpanLevel1Message
             * @instance
             */
            ZhuanpanLevel1Message.prototype.type = 0;
    
            /**
             * Creates a new ZhuanpanLevel1Message instance using the specified properties.
             * @function create
             * @memberof pb.ZhuanpanLevel1Message
             * @static
             * @param {pb.IZhuanpanLevel1Message=} [properties] Properties to set
             * @returns {pb.ZhuanpanLevel1Message} ZhuanpanLevel1Message instance
             */
            ZhuanpanLevel1Message.create = function create(properties) {
                return new ZhuanpanLevel1Message(properties);
            };
    
            /**
             * Encodes the specified ZhuanpanLevel1Message message. Does not implicitly {@link pb.ZhuanpanLevel1Message.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuanpanLevel1Message
             * @static
             * @param {pb.IZhuanpanLevel1Message} message ZhuanpanLevel1Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuanpanLevel1Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.money != null && Object.hasOwnProperty.call(message, "money"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.money);
                if (message.preMoney != null && Object.hasOwnProperty.call(message, "preMoney"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.preMoney);
                if (message.updateCount != null && Object.hasOwnProperty.call(message, "updateCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.updateCount);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                return writer;
            };
    
            /**
             * Decodes a ZhuanpanLevel1Message message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuanpanLevel1Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuanpanLevel1Message} ZhuanpanLevel1Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuanpanLevel1Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuanpanLevel1Message();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.money = reader.int32();
                        break;
                    case 3:
                        message.preMoney = reader.int32();
                        break;
                    case 4:
                        message.updateCount = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuanpanLevel1Message;
        })();
    
        pb.ZhuangPanLevel1MessageReq = (function() {
    
            /**
             * Properties of a ZhuangPanLevel1MessageReq.
             * @memberof pb
             * @interface IZhuangPanLevel1MessageReq
             */
    
            /**
             * Constructs a new ZhuangPanLevel1MessageReq.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevel1MessageReq.
             * @implements IZhuangPanLevel1MessageReq
             * @constructor
             * @param {pb.IZhuangPanLevel1MessageReq=} [properties] Properties to set
             */
            function ZhuangPanLevel1MessageReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ZhuangPanLevel1MessageReq instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevel1MessageReq
             * @static
             * @param {pb.IZhuangPanLevel1MessageReq=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevel1MessageReq} ZhuangPanLevel1MessageReq instance
             */
            ZhuangPanLevel1MessageReq.create = function create(properties) {
                return new ZhuangPanLevel1MessageReq(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevel1MessageReq message. Does not implicitly {@link pb.ZhuangPanLevel1MessageReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevel1MessageReq
             * @static
             * @param {pb.IZhuangPanLevel1MessageReq} message ZhuangPanLevel1MessageReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevel1MessageReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevel1MessageReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevel1MessageReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevel1MessageReq} ZhuangPanLevel1MessageReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevel1MessageReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevel1MessageReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevel1MessageReq;
        })();
    
        pb.ZhuangPanLevel1MessageRes = (function() {
    
            /**
             * Properties of a ZhuangPanLevel1MessageRes.
             * @memberof pb
             * @interface IZhuangPanLevel1MessageRes
             * @property {number|null} [point] ZhuangPanLevel1MessageRes point
             * @property {number|null} [zhuanPanTime] ZhuangPanLevel1MessageRes zhuanPanTime
             * @property {number|null} [serverTime] ZhuangPanLevel1MessageRes serverTime
             * @property {Array.<pb.IZhuanpanLevel1Message>|null} [zhuanPans] ZhuangPanLevel1MessageRes zhuanPans
             * @property {number|null} [emptyCoin] ZhuangPanLevel1MessageRes emptyCoin
             * @property {boolean|null} [watchLevelUp] ZhuangPanLevel1MessageRes watchLevelUp
             * @property {number|null} [maxPoint] ZhuangPanLevel1MessageRes maxPoint
             * @property {number|null} [currentTimes] ZhuangPanLevel1MessageRes currentTimes
             */
    
            /**
             * Constructs a new ZhuangPanLevel1MessageRes.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevel1MessageRes.
             * @implements IZhuangPanLevel1MessageRes
             * @constructor
             * @param {pb.IZhuangPanLevel1MessageRes=} [properties] Properties to set
             */
            function ZhuangPanLevel1MessageRes(properties) {
                this.zhuanPans = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuangPanLevel1MessageRes point.
             * @member {number} point
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.point = 0;
    
            /**
             * ZhuangPanLevel1MessageRes zhuanPanTime.
             * @member {number} zhuanPanTime
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.zhuanPanTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ZhuangPanLevel1MessageRes serverTime.
             * @member {number} serverTime
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.serverTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ZhuangPanLevel1MessageRes zhuanPans.
             * @member {Array.<pb.IZhuanpanLevel1Message>} zhuanPans
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.zhuanPans = $util.emptyArray;
    
            /**
             * ZhuangPanLevel1MessageRes emptyCoin.
             * @member {number} emptyCoin
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.emptyCoin = 0;
    
            /**
             * ZhuangPanLevel1MessageRes watchLevelUp.
             * @member {boolean} watchLevelUp
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.watchLevelUp = false;
    
            /**
             * ZhuangPanLevel1MessageRes maxPoint.
             * @member {number} maxPoint
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.maxPoint = 0;
    
            /**
             * ZhuangPanLevel1MessageRes currentTimes.
             * @member {number} currentTimes
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @instance
             */
            ZhuangPanLevel1MessageRes.prototype.currentTimes = 0;
    
            /**
             * Creates a new ZhuangPanLevel1MessageRes instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @static
             * @param {pb.IZhuangPanLevel1MessageRes=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevel1MessageRes} ZhuangPanLevel1MessageRes instance
             */
            ZhuangPanLevel1MessageRes.create = function create(properties) {
                return new ZhuangPanLevel1MessageRes(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevel1MessageRes message. Does not implicitly {@link pb.ZhuangPanLevel1MessageRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @static
             * @param {pb.IZhuangPanLevel1MessageRes} message ZhuangPanLevel1MessageRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevel1MessageRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.point);
                if (message.zhuanPanTime != null && Object.hasOwnProperty.call(message, "zhuanPanTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.zhuanPanTime);
                if (message.serverTime != null && Object.hasOwnProperty.call(message, "serverTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.serverTime);
                if (message.zhuanPans != null && message.zhuanPans.length)
                    for (var i = 0; i < message.zhuanPans.length; ++i)
                        $root.pb.ZhuanpanLevel1Message.encode(message.zhuanPans[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.emptyCoin != null && Object.hasOwnProperty.call(message, "emptyCoin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.emptyCoin);
                if (message.watchLevelUp != null && Object.hasOwnProperty.call(message, "watchLevelUp"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.watchLevelUp);
                if (message.maxPoint != null && Object.hasOwnProperty.call(message, "maxPoint"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.maxPoint);
                if (message.currentTimes != null && Object.hasOwnProperty.call(message, "currentTimes"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.currentTimes);
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevel1MessageRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevel1MessageRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevel1MessageRes} ZhuangPanLevel1MessageRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevel1MessageRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevel1MessageRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.point = reader.int32();
                        break;
                    case 2:
                        message.zhuanPanTime = reader.int64();
                        break;
                    case 3:
                        message.serverTime = reader.int64();
                        break;
                    case 4:
                        if (!(message.zhuanPans && message.zhuanPans.length))
                            message.zhuanPans = [];
                        message.zhuanPans.push($root.pb.ZhuanpanLevel1Message.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.emptyCoin = reader.int32();
                        break;
                    case 6:
                        message.watchLevelUp = reader.bool();
                        break;
                    case 7:
                        message.maxPoint = reader.int32();
                        break;
                    case 8:
                        message.currentTimes = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevel1MessageRes;
        })();
    
        pb.ZhuangPanLevel1Req = (function() {
    
            /**
             * Properties of a ZhuangPanLevel1Req.
             * @memberof pb
             * @interface IZhuangPanLevel1Req
             * @property {boolean|null} [userCoin] ZhuangPanLevel1Req userCoin
             */
    
            /**
             * Constructs a new ZhuangPanLevel1Req.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevel1Req.
             * @implements IZhuangPanLevel1Req
             * @constructor
             * @param {pb.IZhuangPanLevel1Req=} [properties] Properties to set
             */
            function ZhuangPanLevel1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuangPanLevel1Req userCoin.
             * @member {boolean} userCoin
             * @memberof pb.ZhuangPanLevel1Req
             * @instance
             */
            ZhuangPanLevel1Req.prototype.userCoin = false;
    
            /**
             * Creates a new ZhuangPanLevel1Req instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevel1Req
             * @static
             * @param {pb.IZhuangPanLevel1Req=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevel1Req} ZhuangPanLevel1Req instance
             */
            ZhuangPanLevel1Req.create = function create(properties) {
                return new ZhuangPanLevel1Req(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevel1Req message. Does not implicitly {@link pb.ZhuangPanLevel1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevel1Req
             * @static
             * @param {pb.IZhuangPanLevel1Req} message ZhuangPanLevel1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevel1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userCoin != null && Object.hasOwnProperty.call(message, "userCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.userCoin);
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevel1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevel1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevel1Req} ZhuangPanLevel1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevel1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevel1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.userCoin = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevel1Req;
        })();
    
        pb.ZhuangPanLevel1Res = (function() {
    
            /**
             * Properties of a ZhuangPanLevel1Res.
             * @memberof pb
             * @interface IZhuangPanLevel1Res
             * @property {boolean|null} [userCoin] ZhuangPanLevel1Res userCoin
             * @property {pb.IZhuanpanLevel1Message|null} [zhuanPan] ZhuangPanLevel1Res zhuanPan
             * @property {number|null} [leftPoint] ZhuangPanLevel1Res leftPoint
             * @property {number|null} [leftCoin] ZhuangPanLevel1Res leftCoin
             * @property {number|null} [currentTimes] ZhuangPanLevel1Res currentTimes
             * @property {number|null} [nextTimes] ZhuangPanLevel1Res nextTimes
             * @property {number|null} [leftCrystalCoin] ZhuangPanLevel1Res leftCrystalCoin
             * @property {number|null} [videoMuti] ZhuangPanLevel1Res videoMuti
             * @property {string|null} [videoId] ZhuangPanLevel1Res videoId
             * @property {number|null} [code] ZhuangPanLevel1Res code
             */
    
            /**
             * Constructs a new ZhuangPanLevel1Res.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevel1Res.
             * @implements IZhuangPanLevel1Res
             * @constructor
             * @param {pb.IZhuangPanLevel1Res=} [properties] Properties to set
             */
            function ZhuangPanLevel1Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuangPanLevel1Res userCoin.
             * @member {boolean} userCoin
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.userCoin = false;
    
            /**
             * ZhuangPanLevel1Res zhuanPan.
             * @member {pb.IZhuanpanLevel1Message|null|undefined} zhuanPan
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.zhuanPan = null;
    
            /**
             * ZhuangPanLevel1Res leftPoint.
             * @member {number} leftPoint
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.leftPoint = 0;
    
            /**
             * ZhuangPanLevel1Res leftCoin.
             * @member {number} leftCoin
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.leftCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ZhuangPanLevel1Res currentTimes.
             * @member {number} currentTimes
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.currentTimes = 0;
    
            /**
             * ZhuangPanLevel1Res nextTimes.
             * @member {number} nextTimes
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.nextTimes = 0;
    
            /**
             * ZhuangPanLevel1Res leftCrystalCoin.
             * @member {number} leftCrystalCoin
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.leftCrystalCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ZhuangPanLevel1Res videoMuti.
             * @member {number} videoMuti
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.videoMuti = 0;
    
            /**
             * ZhuangPanLevel1Res videoId.
             * @member {string} videoId
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.videoId = "";
    
            /**
             * ZhuangPanLevel1Res code.
             * @member {number} code
             * @memberof pb.ZhuangPanLevel1Res
             * @instance
             */
            ZhuangPanLevel1Res.prototype.code = 0;
    
            /**
             * Creates a new ZhuangPanLevel1Res instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevel1Res
             * @static
             * @param {pb.IZhuangPanLevel1Res=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevel1Res} ZhuangPanLevel1Res instance
             */
            ZhuangPanLevel1Res.create = function create(properties) {
                return new ZhuangPanLevel1Res(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevel1Res message. Does not implicitly {@link pb.ZhuangPanLevel1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevel1Res
             * @static
             * @param {pb.IZhuangPanLevel1Res} message ZhuangPanLevel1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevel1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userCoin != null && Object.hasOwnProperty.call(message, "userCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.userCoin);
                if (message.zhuanPan != null && Object.hasOwnProperty.call(message, "zhuanPan"))
                    $root.pb.ZhuanpanLevel1Message.encode(message.zhuanPan, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.leftPoint != null && Object.hasOwnProperty.call(message, "leftPoint"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.leftPoint);
                if (message.leftCoin != null && Object.hasOwnProperty.call(message, "leftCoin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.leftCoin);
                if (message.currentTimes != null && Object.hasOwnProperty.call(message, "currentTimes"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.currentTimes);
                if (message.nextTimes != null && Object.hasOwnProperty.call(message, "nextTimes"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.nextTimes);
                if (message.leftCrystalCoin != null && Object.hasOwnProperty.call(message, "leftCrystalCoin"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.leftCrystalCoin);
                if (message.videoMuti != null && Object.hasOwnProperty.call(message, "videoMuti"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.videoMuti);
                if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
                    writer.uint32(/* id 9, wireType 2 =*/74).string(message.videoId);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevel1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevel1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevel1Res} ZhuangPanLevel1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevel1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevel1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.userCoin = reader.bool();
                        break;
                    case 2:
                        message.zhuanPan = $root.pb.ZhuanpanLevel1Message.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.leftPoint = reader.int32();
                        break;
                    case 4:
                        message.leftCoin = reader.int64();
                        break;
                    case 5:
                        message.currentTimes = reader.int32();
                        break;
                    case 6:
                        message.nextTimes = reader.int32();
                        break;
                    case 7:
                        message.leftCrystalCoin = reader.int64();
                        break;
                    case 8:
                        message.videoMuti = reader.int32();
                        break;
                    case 9:
                        message.videoId = reader.string();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevel1Res;
        })();
    
        pb.ZhuangPanLevel1UpTipReq = (function() {
    
            /**
             * Properties of a ZhuangPanLevel1UpTipReq.
             * @memberof pb
             * @interface IZhuangPanLevel1UpTipReq
             */
    
            /**
             * Constructs a new ZhuangPanLevel1UpTipReq.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevel1UpTipReq.
             * @implements IZhuangPanLevel1UpTipReq
             * @constructor
             * @param {pb.IZhuangPanLevel1UpTipReq=} [properties] Properties to set
             */
            function ZhuangPanLevel1UpTipReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new ZhuangPanLevel1UpTipReq instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevel1UpTipReq
             * @static
             * @param {pb.IZhuangPanLevel1UpTipReq=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevel1UpTipReq} ZhuangPanLevel1UpTipReq instance
             */
            ZhuangPanLevel1UpTipReq.create = function create(properties) {
                return new ZhuangPanLevel1UpTipReq(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevel1UpTipReq message. Does not implicitly {@link pb.ZhuangPanLevel1UpTipReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevel1UpTipReq
             * @static
             * @param {pb.IZhuangPanLevel1UpTipReq} message ZhuangPanLevel1UpTipReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevel1UpTipReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevel1UpTipReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevel1UpTipReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevel1UpTipReq} ZhuangPanLevel1UpTipReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevel1UpTipReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevel1UpTipReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevel1UpTipReq;
        })();
    
        pb.ZhuangPanLevel1UpTipRes = (function() {
    
            /**
             * Properties of a ZhuangPanLevel1UpTipRes.
             * @memberof pb
             * @interface IZhuangPanLevel1UpTipRes
             * @property {number|null} [code] ZhuangPanLevel1UpTipRes code
             */
    
            /**
             * Constructs a new ZhuangPanLevel1UpTipRes.
             * @memberof pb
             * @classdesc Represents a ZhuangPanLevel1UpTipRes.
             * @implements IZhuangPanLevel1UpTipRes
             * @constructor
             * @param {pb.IZhuangPanLevel1UpTipRes=} [properties] Properties to set
             */
            function ZhuangPanLevel1UpTipRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ZhuangPanLevel1UpTipRes code.
             * @member {number} code
             * @memberof pb.ZhuangPanLevel1UpTipRes
             * @instance
             */
            ZhuangPanLevel1UpTipRes.prototype.code = 0;
    
            /**
             * Creates a new ZhuangPanLevel1UpTipRes instance using the specified properties.
             * @function create
             * @memberof pb.ZhuangPanLevel1UpTipRes
             * @static
             * @param {pb.IZhuangPanLevel1UpTipRes=} [properties] Properties to set
             * @returns {pb.ZhuangPanLevel1UpTipRes} ZhuangPanLevel1UpTipRes instance
             */
            ZhuangPanLevel1UpTipRes.create = function create(properties) {
                return new ZhuangPanLevel1UpTipRes(properties);
            };
    
            /**
             * Encodes the specified ZhuangPanLevel1UpTipRes message. Does not implicitly {@link pb.ZhuangPanLevel1UpTipRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ZhuangPanLevel1UpTipRes
             * @static
             * @param {pb.IZhuangPanLevel1UpTipRes} message ZhuangPanLevel1UpTipRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ZhuangPanLevel1UpTipRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a ZhuangPanLevel1UpTipRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ZhuangPanLevel1UpTipRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ZhuangPanLevel1UpTipRes} ZhuangPanLevel1UpTipRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ZhuangPanLevel1UpTipRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ZhuangPanLevel1UpTipRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ZhuangPanLevel1UpTipRes;
        })();
    
        pb.GetAllSkin1Req = (function() {
    
            /**
             * Properties of a GetAllSkin1Req.
             * @memberof pb
             * @interface IGetAllSkin1Req
             */
    
            /**
             * Constructs a new GetAllSkin1Req.
             * @memberof pb
             * @classdesc Represents a GetAllSkin1Req.
             * @implements IGetAllSkin1Req
             * @constructor
             * @param {pb.IGetAllSkin1Req=} [properties] Properties to set
             */
            function GetAllSkin1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetAllSkin1Req instance using the specified properties.
             * @function create
             * @memberof pb.GetAllSkin1Req
             * @static
             * @param {pb.IGetAllSkin1Req=} [properties] Properties to set
             * @returns {pb.GetAllSkin1Req} GetAllSkin1Req instance
             */
            GetAllSkin1Req.create = function create(properties) {
                return new GetAllSkin1Req(properties);
            };
    
            /**
             * Encodes the specified GetAllSkin1Req message. Does not implicitly {@link pb.GetAllSkin1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAllSkin1Req
             * @static
             * @param {pb.IGetAllSkin1Req} message GetAllSkin1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllSkin1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetAllSkin1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAllSkin1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAllSkin1Req} GetAllSkin1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllSkin1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAllSkin1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAllSkin1Req;
        })();
    
        pb.GetAllSkin1Res = (function() {
    
            /**
             * Properties of a GetAllSkin1Res.
             * @memberof pb
             * @interface IGetAllSkin1Res
             * @property {pb.IUserSkin1Message|null} [skin] GetAllSkin1Res skin
             * @property {string|null} [uid] GetAllSkin1Res uid
             * @property {number|null} [code] GetAllSkin1Res code
             */
    
            /**
             * Constructs a new GetAllSkin1Res.
             * @memberof pb
             * @classdesc Represents a GetAllSkin1Res.
             * @implements IGetAllSkin1Res
             * @constructor
             * @param {pb.IGetAllSkin1Res=} [properties] Properties to set
             */
            function GetAllSkin1Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetAllSkin1Res skin.
             * @member {pb.IUserSkin1Message|null|undefined} skin
             * @memberof pb.GetAllSkin1Res
             * @instance
             */
            GetAllSkin1Res.prototype.skin = null;
    
            /**
             * GetAllSkin1Res uid.
             * @member {string} uid
             * @memberof pb.GetAllSkin1Res
             * @instance
             */
            GetAllSkin1Res.prototype.uid = "";
    
            /**
             * GetAllSkin1Res code.
             * @member {number} code
             * @memberof pb.GetAllSkin1Res
             * @instance
             */
            GetAllSkin1Res.prototype.code = 0;
    
            /**
             * Creates a new GetAllSkin1Res instance using the specified properties.
             * @function create
             * @memberof pb.GetAllSkin1Res
             * @static
             * @param {pb.IGetAllSkin1Res=} [properties] Properties to set
             * @returns {pb.GetAllSkin1Res} GetAllSkin1Res instance
             */
            GetAllSkin1Res.create = function create(properties) {
                return new GetAllSkin1Res(properties);
            };
    
            /**
             * Encodes the specified GetAllSkin1Res message. Does not implicitly {@link pb.GetAllSkin1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAllSkin1Res
             * @static
             * @param {pb.IGetAllSkin1Res} message GetAllSkin1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllSkin1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.skin != null && Object.hasOwnProperty.call(message, "skin"))
                    $root.pb.UserSkin1Message.encode(message.skin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uid);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetAllSkin1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAllSkin1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAllSkin1Res} GetAllSkin1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllSkin1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAllSkin1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.skin = $root.pb.UserSkin1Message.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.uid = reader.string();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAllSkin1Res;
        })();
    
        pb.SkinSetting1Msg = (function() {
    
            /**
             * Properties of a SkinSetting1Msg.
             * @memberof pb
             * @interface ISkinSetting1Msg
             * @property {number|null} [type] SkinSetting1Msg type
             * @property {number|null} [id] SkinSetting1Msg id
             * @property {number|null} [defSkin] SkinSetting1Msg defSkin
             * @property {number|null} [minLevel] SkinSetting1Msg minLevel
             * @property {number|null} [minScene] SkinSetting1Msg minScene
             * @property {number|null} [skinCoin] SkinSetting1Msg skinCoin
             * @property {number|null} [order] SkinSetting1Msg order
             * @property {number|null} [quality] SkinSetting1Msg quality
             */
    
            /**
             * Constructs a new SkinSetting1Msg.
             * @memberof pb
             * @classdesc Represents a SkinSetting1Msg.
             * @implements ISkinSetting1Msg
             * @constructor
             * @param {pb.ISkinSetting1Msg=} [properties] Properties to set
             */
            function SkinSetting1Msg(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SkinSetting1Msg type.
             * @member {number} type
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.type = 0;
    
            /**
             * SkinSetting1Msg id.
             * @member {number} id
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.id = 0;
    
            /**
             * SkinSetting1Msg defSkin.
             * @member {number} defSkin
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.defSkin = 0;
    
            /**
             * SkinSetting1Msg minLevel.
             * @member {number} minLevel
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.minLevel = 0;
    
            /**
             * SkinSetting1Msg minScene.
             * @member {number} minScene
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.minScene = 0;
    
            /**
             * SkinSetting1Msg skinCoin.
             * @member {number} skinCoin
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.skinCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SkinSetting1Msg order.
             * @member {number} order
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.order = 0;
    
            /**
             * SkinSetting1Msg quality.
             * @member {number} quality
             * @memberof pb.SkinSetting1Msg
             * @instance
             */
            SkinSetting1Msg.prototype.quality = 0;
    
            /**
             * Creates a new SkinSetting1Msg instance using the specified properties.
             * @function create
             * @memberof pb.SkinSetting1Msg
             * @static
             * @param {pb.ISkinSetting1Msg=} [properties] Properties to set
             * @returns {pb.SkinSetting1Msg} SkinSetting1Msg instance
             */
            SkinSetting1Msg.create = function create(properties) {
                return new SkinSetting1Msg(properties);
            };
    
            /**
             * Encodes the specified SkinSetting1Msg message. Does not implicitly {@link pb.SkinSetting1Msg.verify|verify} messages.
             * @function encode
             * @memberof pb.SkinSetting1Msg
             * @static
             * @param {pb.ISkinSetting1Msg} message SkinSetting1Msg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SkinSetting1Msg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                if (message.defSkin != null && Object.hasOwnProperty.call(message, "defSkin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.defSkin);
                if (message.minLevel != null && Object.hasOwnProperty.call(message, "minLevel"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minLevel);
                if (message.minScene != null && Object.hasOwnProperty.call(message, "minScene"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.minScene);
                if (message.skinCoin != null && Object.hasOwnProperty.call(message, "skinCoin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.skinCoin);
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.order);
                if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.quality);
                return writer;
            };
    
            /**
             * Decodes a SkinSetting1Msg message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SkinSetting1Msg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SkinSetting1Msg} SkinSetting1Msg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SkinSetting1Msg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SkinSetting1Msg();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.defSkin = reader.int32();
                        break;
                    case 4:
                        message.minLevel = reader.int32();
                        break;
                    case 5:
                        message.minScene = reader.int32();
                        break;
                    case 6:
                        message.skinCoin = reader.int64();
                        break;
                    case 7:
                        message.order = reader.int32();
                        break;
                    case 8:
                        message.quality = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SkinSetting1Msg;
        })();
    
        pb.GetSkinSetting1Req = (function() {
    
            /**
             * Properties of a GetSkinSetting1Req.
             * @memberof pb
             * @interface IGetSkinSetting1Req
             */
    
            /**
             * Constructs a new GetSkinSetting1Req.
             * @memberof pb
             * @classdesc Represents a GetSkinSetting1Req.
             * @implements IGetSkinSetting1Req
             * @constructor
             * @param {pb.IGetSkinSetting1Req=} [properties] Properties to set
             */
            function GetSkinSetting1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetSkinSetting1Req instance using the specified properties.
             * @function create
             * @memberof pb.GetSkinSetting1Req
             * @static
             * @param {pb.IGetSkinSetting1Req=} [properties] Properties to set
             * @returns {pb.GetSkinSetting1Req} GetSkinSetting1Req instance
             */
            GetSkinSetting1Req.create = function create(properties) {
                return new GetSkinSetting1Req(properties);
            };
    
            /**
             * Encodes the specified GetSkinSetting1Req message. Does not implicitly {@link pb.GetSkinSetting1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.GetSkinSetting1Req
             * @static
             * @param {pb.IGetSkinSetting1Req} message GetSkinSetting1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSkinSetting1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetSkinSetting1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetSkinSetting1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetSkinSetting1Req} GetSkinSetting1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSkinSetting1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetSkinSetting1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetSkinSetting1Req;
        })();
    
        pb.GetSkinSetting1Res = (function() {
    
            /**
             * Properties of a GetSkinSetting1Res.
             * @memberof pb
             * @interface IGetSkinSetting1Res
             * @property {Array.<pb.ISkinSetting1Msg>|null} [skins] GetSkinSetting1Res skins
             */
    
            /**
             * Constructs a new GetSkinSetting1Res.
             * @memberof pb
             * @classdesc Represents a GetSkinSetting1Res.
             * @implements IGetSkinSetting1Res
             * @constructor
             * @param {pb.IGetSkinSetting1Res=} [properties] Properties to set
             */
            function GetSkinSetting1Res(properties) {
                this.skins = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetSkinSetting1Res skins.
             * @member {Array.<pb.ISkinSetting1Msg>} skins
             * @memberof pb.GetSkinSetting1Res
             * @instance
             */
            GetSkinSetting1Res.prototype.skins = $util.emptyArray;
    
            /**
             * Creates a new GetSkinSetting1Res instance using the specified properties.
             * @function create
             * @memberof pb.GetSkinSetting1Res
             * @static
             * @param {pb.IGetSkinSetting1Res=} [properties] Properties to set
             * @returns {pb.GetSkinSetting1Res} GetSkinSetting1Res instance
             */
            GetSkinSetting1Res.create = function create(properties) {
                return new GetSkinSetting1Res(properties);
            };
    
            /**
             * Encodes the specified GetSkinSetting1Res message. Does not implicitly {@link pb.GetSkinSetting1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.GetSkinSetting1Res
             * @static
             * @param {pb.IGetSkinSetting1Res} message GetSkinSetting1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSkinSetting1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.skins != null && message.skins.length)
                    for (var i = 0; i < message.skins.length; ++i)
                        $root.pb.SkinSetting1Msg.encode(message.skins[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GetSkinSetting1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetSkinSetting1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetSkinSetting1Res} GetSkinSetting1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSkinSetting1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetSkinSetting1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.skins && message.skins.length))
                            message.skins = [];
                        message.skins.push($root.pb.SkinSetting1Msg.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetSkinSetting1Res;
        })();
    
        pb.BuySkin1Req = (function() {
    
            /**
             * Properties of a BuySkin1Req.
             * @memberof pb
             * @interface IBuySkin1Req
             * @property {number|null} [type] BuySkin1Req type
             * @property {number|null} [id] BuySkin1Req id
             */
    
            /**
             * Constructs a new BuySkin1Req.
             * @memberof pb
             * @classdesc Represents a BuySkin1Req.
             * @implements IBuySkin1Req
             * @constructor
             * @param {pb.IBuySkin1Req=} [properties] Properties to set
             */
            function BuySkin1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BuySkin1Req type.
             * @member {number} type
             * @memberof pb.BuySkin1Req
             * @instance
             */
            BuySkin1Req.prototype.type = 0;
    
            /**
             * BuySkin1Req id.
             * @member {number} id
             * @memberof pb.BuySkin1Req
             * @instance
             */
            BuySkin1Req.prototype.id = 0;
    
            /**
             * Creates a new BuySkin1Req instance using the specified properties.
             * @function create
             * @memberof pb.BuySkin1Req
             * @static
             * @param {pb.IBuySkin1Req=} [properties] Properties to set
             * @returns {pb.BuySkin1Req} BuySkin1Req instance
             */
            BuySkin1Req.create = function create(properties) {
                return new BuySkin1Req(properties);
            };
    
            /**
             * Encodes the specified BuySkin1Req message. Does not implicitly {@link pb.BuySkin1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.BuySkin1Req
             * @static
             * @param {pb.IBuySkin1Req} message BuySkin1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuySkin1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                return writer;
            };
    
            /**
             * Decodes a BuySkin1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.BuySkin1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.BuySkin1Req} BuySkin1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuySkin1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuySkin1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return BuySkin1Req;
        })();
    
        pb.BuySkin1Res = (function() {
    
            /**
             * Properties of a BuySkin1Res.
             * @memberof pb
             * @interface IBuySkin1Res
             * @property {number|null} [type] BuySkin1Res type
             * @property {number|null} [id] BuySkin1Res id
             * @property {number|null} [crystalCoin] BuySkin1Res crystalCoin
             * @property {number|null} [code] BuySkin1Res code
             */
    
            /**
             * Constructs a new BuySkin1Res.
             * @memberof pb
             * @classdesc Represents a BuySkin1Res.
             * @implements IBuySkin1Res
             * @constructor
             * @param {pb.IBuySkin1Res=} [properties] Properties to set
             */
            function BuySkin1Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BuySkin1Res type.
             * @member {number} type
             * @memberof pb.BuySkin1Res
             * @instance
             */
            BuySkin1Res.prototype.type = 0;
    
            /**
             * BuySkin1Res id.
             * @member {number} id
             * @memberof pb.BuySkin1Res
             * @instance
             */
            BuySkin1Res.prototype.id = 0;
    
            /**
             * BuySkin1Res crystalCoin.
             * @member {number} crystalCoin
             * @memberof pb.BuySkin1Res
             * @instance
             */
            BuySkin1Res.prototype.crystalCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * BuySkin1Res code.
             * @member {number} code
             * @memberof pb.BuySkin1Res
             * @instance
             */
            BuySkin1Res.prototype.code = 0;
    
            /**
             * Creates a new BuySkin1Res instance using the specified properties.
             * @function create
             * @memberof pb.BuySkin1Res
             * @static
             * @param {pb.IBuySkin1Res=} [properties] Properties to set
             * @returns {pb.BuySkin1Res} BuySkin1Res instance
             */
            BuySkin1Res.create = function create(properties) {
                return new BuySkin1Res(properties);
            };
    
            /**
             * Encodes the specified BuySkin1Res message. Does not implicitly {@link pb.BuySkin1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.BuySkin1Res
             * @static
             * @param {pb.IBuySkin1Res} message BuySkin1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuySkin1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                if (message.crystalCoin != null && Object.hasOwnProperty.call(message, "crystalCoin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.crystalCoin);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a BuySkin1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.BuySkin1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.BuySkin1Res} BuySkin1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuySkin1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuySkin1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.crystalCoin = reader.int64();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return BuySkin1Res;
        })();
    
        pb.DecorateSkin1Req = (function() {
    
            /**
             * Properties of a DecorateSkin1Req.
             * @memberof pb
             * @interface IDecorateSkin1Req
             * @property {number|null} [type] DecorateSkin1Req type
             * @property {number|null} [id] DecorateSkin1Req id
             */
    
            /**
             * Constructs a new DecorateSkin1Req.
             * @memberof pb
             * @classdesc Represents a DecorateSkin1Req.
             * @implements IDecorateSkin1Req
             * @constructor
             * @param {pb.IDecorateSkin1Req=} [properties] Properties to set
             */
            function DecorateSkin1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DecorateSkin1Req type.
             * @member {number} type
             * @memberof pb.DecorateSkin1Req
             * @instance
             */
            DecorateSkin1Req.prototype.type = 0;
    
            /**
             * DecorateSkin1Req id.
             * @member {number} id
             * @memberof pb.DecorateSkin1Req
             * @instance
             */
            DecorateSkin1Req.prototype.id = 0;
    
            /**
             * Creates a new DecorateSkin1Req instance using the specified properties.
             * @function create
             * @memberof pb.DecorateSkin1Req
             * @static
             * @param {pb.IDecorateSkin1Req=} [properties] Properties to set
             * @returns {pb.DecorateSkin1Req} DecorateSkin1Req instance
             */
            DecorateSkin1Req.create = function create(properties) {
                return new DecorateSkin1Req(properties);
            };
    
            /**
             * Encodes the specified DecorateSkin1Req message. Does not implicitly {@link pb.DecorateSkin1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.DecorateSkin1Req
             * @static
             * @param {pb.IDecorateSkin1Req} message DecorateSkin1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecorateSkin1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                return writer;
            };
    
            /**
             * Decodes a DecorateSkin1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DecorateSkin1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DecorateSkin1Req} DecorateSkin1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecorateSkin1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DecorateSkin1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DecorateSkin1Req;
        })();
    
        pb.DecorateSkin1Res = (function() {
    
            /**
             * Properties of a DecorateSkin1Res.
             * @memberof pb
             * @interface IDecorateSkin1Res
             * @property {number|null} [type] DecorateSkin1Res type
             * @property {number|null} [id] DecorateSkin1Res id
             * @property {number|null} [code] DecorateSkin1Res code
             */
    
            /**
             * Constructs a new DecorateSkin1Res.
             * @memberof pb
             * @classdesc Represents a DecorateSkin1Res.
             * @implements IDecorateSkin1Res
             * @constructor
             * @param {pb.IDecorateSkin1Res=} [properties] Properties to set
             */
            function DecorateSkin1Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DecorateSkin1Res type.
             * @member {number} type
             * @memberof pb.DecorateSkin1Res
             * @instance
             */
            DecorateSkin1Res.prototype.type = 0;
    
            /**
             * DecorateSkin1Res id.
             * @member {number} id
             * @memberof pb.DecorateSkin1Res
             * @instance
             */
            DecorateSkin1Res.prototype.id = 0;
    
            /**
             * DecorateSkin1Res code.
             * @member {number} code
             * @memberof pb.DecorateSkin1Res
             * @instance
             */
            DecorateSkin1Res.prototype.code = 0;
    
            /**
             * Creates a new DecorateSkin1Res instance using the specified properties.
             * @function create
             * @memberof pb.DecorateSkin1Res
             * @static
             * @param {pb.IDecorateSkin1Res=} [properties] Properties to set
             * @returns {pb.DecorateSkin1Res} DecorateSkin1Res instance
             */
            DecorateSkin1Res.create = function create(properties) {
                return new DecorateSkin1Res(properties);
            };
    
            /**
             * Encodes the specified DecorateSkin1Res message. Does not implicitly {@link pb.DecorateSkin1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.DecorateSkin1Res
             * @static
             * @param {pb.IDecorateSkin1Res} message DecorateSkin1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecorateSkin1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a DecorateSkin1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DecorateSkin1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DecorateSkin1Res} DecorateSkin1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecorateSkin1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DecorateSkin1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DecorateSkin1Res;
        })();
    
        pb.SceneChange1Res = (function() {
    
            /**
             * Properties of a SceneChange1Res.
             * @memberof pb
             * @interface ISceneChange1Res
             * @property {number|null} [sceneId] SceneChange1Res sceneId
             */
    
            /**
             * Constructs a new SceneChange1Res.
             * @memberof pb
             * @classdesc Represents a SceneChange1Res.
             * @implements ISceneChange1Res
             * @constructor
             * @param {pb.ISceneChange1Res=} [properties] Properties to set
             */
            function SceneChange1Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SceneChange1Res sceneId.
             * @member {number} sceneId
             * @memberof pb.SceneChange1Res
             * @instance
             */
            SceneChange1Res.prototype.sceneId = 0;
    
            /**
             * Creates a new SceneChange1Res instance using the specified properties.
             * @function create
             * @memberof pb.SceneChange1Res
             * @static
             * @param {pb.ISceneChange1Res=} [properties] Properties to set
             * @returns {pb.SceneChange1Res} SceneChange1Res instance
             */
            SceneChange1Res.create = function create(properties) {
                return new SceneChange1Res(properties);
            };
    
            /**
             * Encodes the specified SceneChange1Res message. Does not implicitly {@link pb.SceneChange1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.SceneChange1Res
             * @static
             * @param {pb.ISceneChange1Res} message SceneChange1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SceneChange1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sceneId != null && Object.hasOwnProperty.call(message, "sceneId"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.sceneId);
                return writer;
            };
    
            /**
             * Decodes a SceneChange1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SceneChange1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SceneChange1Res} SceneChange1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SceneChange1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SceneChange1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 15:
                        message.sceneId = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SceneChange1Res;
        })();
    
        pb.PlaySceneAnimation1Req = (function() {
    
            /**
             * Properties of a PlaySceneAnimation1Req.
             * @memberof pb
             * @interface IPlaySceneAnimation1Req
             */
    
            /**
             * Constructs a new PlaySceneAnimation1Req.
             * @memberof pb
             * @classdesc Represents a PlaySceneAnimation1Req.
             * @implements IPlaySceneAnimation1Req
             * @constructor
             * @param {pb.IPlaySceneAnimation1Req=} [properties] Properties to set
             */
            function PlaySceneAnimation1Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PlaySceneAnimation1Req instance using the specified properties.
             * @function create
             * @memberof pb.PlaySceneAnimation1Req
             * @static
             * @param {pb.IPlaySceneAnimation1Req=} [properties] Properties to set
             * @returns {pb.PlaySceneAnimation1Req} PlaySceneAnimation1Req instance
             */
            PlaySceneAnimation1Req.create = function create(properties) {
                return new PlaySceneAnimation1Req(properties);
            };
    
            /**
             * Encodes the specified PlaySceneAnimation1Req message. Does not implicitly {@link pb.PlaySceneAnimation1Req.verify|verify} messages.
             * @function encode
             * @memberof pb.PlaySceneAnimation1Req
             * @static
             * @param {pb.IPlaySceneAnimation1Req} message PlaySceneAnimation1Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlaySceneAnimation1Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a PlaySceneAnimation1Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlaySceneAnimation1Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlaySceneAnimation1Req} PlaySceneAnimation1Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlaySceneAnimation1Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlaySceneAnimation1Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlaySceneAnimation1Req;
        })();
    
        pb.PlaySceneAnimation1Res = (function() {
    
            /**
             * Properties of a PlaySceneAnimation1Res.
             * @memberof pb
             * @interface IPlaySceneAnimation1Res
             * @property {number|null} [code] PlaySceneAnimation1Res code
             */
    
            /**
             * Constructs a new PlaySceneAnimation1Res.
             * @memberof pb
             * @classdesc Represents a PlaySceneAnimation1Res.
             * @implements IPlaySceneAnimation1Res
             * @constructor
             * @param {pb.IPlaySceneAnimation1Res=} [properties] Properties to set
             */
            function PlaySceneAnimation1Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * PlaySceneAnimation1Res code.
             * @member {number} code
             * @memberof pb.PlaySceneAnimation1Res
             * @instance
             */
            PlaySceneAnimation1Res.prototype.code = 0;
    
            /**
             * Creates a new PlaySceneAnimation1Res instance using the specified properties.
             * @function create
             * @memberof pb.PlaySceneAnimation1Res
             * @static
             * @param {pb.IPlaySceneAnimation1Res=} [properties] Properties to set
             * @returns {pb.PlaySceneAnimation1Res} PlaySceneAnimation1Res instance
             */
            PlaySceneAnimation1Res.create = function create(properties) {
                return new PlaySceneAnimation1Res(properties);
            };
    
            /**
             * Encodes the specified PlaySceneAnimation1Res message. Does not implicitly {@link pb.PlaySceneAnimation1Res.verify|verify} messages.
             * @function encode
             * @memberof pb.PlaySceneAnimation1Res
             * @static
             * @param {pb.IPlaySceneAnimation1Res} message PlaySceneAnimation1Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PlaySceneAnimation1Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a PlaySceneAnimation1Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PlaySceneAnimation1Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PlaySceneAnimation1Res} PlaySceneAnimation1Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PlaySceneAnimation1Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlaySceneAnimation1Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PlaySceneAnimation1Res;
        })();
    
        /**
         * RedPointType enum.
         * @name pb.RedPointType
         * @enum {number}
         * @property {number} SKINLEVELUP=0 SKINLEVELUP value
         */
        pb.RedPointType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "SKINLEVELUP"] = 0;
            return values;
        })();
    
        pb.RedPoint = (function() {
    
            /**
             * Properties of a RedPoint.
             * @memberof pb
             * @interface IRedPoint
             * @property {pb.RedPointType|null} [type] RedPoint type
             * @property {boolean|null} [value] RedPoint value
             */
    
            /**
             * Constructs a new RedPoint.
             * @memberof pb
             * @classdesc Represents a RedPoint.
             * @implements IRedPoint
             * @constructor
             * @param {pb.IRedPoint=} [properties] Properties to set
             */
            function RedPoint(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RedPoint type.
             * @member {pb.RedPointType} type
             * @memberof pb.RedPoint
             * @instance
             */
            RedPoint.prototype.type = 0;
    
            /**
             * RedPoint value.
             * @member {boolean} value
             * @memberof pb.RedPoint
             * @instance
             */
            RedPoint.prototype.value = false;
    
            /**
             * Creates a new RedPoint instance using the specified properties.
             * @function create
             * @memberof pb.RedPoint
             * @static
             * @param {pb.IRedPoint=} [properties] Properties to set
             * @returns {pb.RedPoint} RedPoint instance
             */
            RedPoint.create = function create(properties) {
                return new RedPoint(properties);
            };
    
            /**
             * Encodes the specified RedPoint message. Does not implicitly {@link pb.RedPoint.verify|verify} messages.
             * @function encode
             * @memberof pb.RedPoint
             * @static
             * @param {pb.IRedPoint} message RedPoint message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedPoint.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.value);
                return writer;
            };
    
            /**
             * Decodes a RedPoint message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RedPoint
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RedPoint} RedPoint
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedPoint.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RedPoint();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.value = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RedPoint;
        })();
    
        pb.RedPointGetReq = (function() {
    
            /**
             * Properties of a RedPointGetReq.
             * @memberof pb
             * @interface IRedPointGetReq
             */
    
            /**
             * Constructs a new RedPointGetReq.
             * @memberof pb
             * @classdesc Represents a RedPointGetReq.
             * @implements IRedPointGetReq
             * @constructor
             * @param {pb.IRedPointGetReq=} [properties] Properties to set
             */
            function RedPointGetReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new RedPointGetReq instance using the specified properties.
             * @function create
             * @memberof pb.RedPointGetReq
             * @static
             * @param {pb.IRedPointGetReq=} [properties] Properties to set
             * @returns {pb.RedPointGetReq} RedPointGetReq instance
             */
            RedPointGetReq.create = function create(properties) {
                return new RedPointGetReq(properties);
            };
    
            /**
             * Encodes the specified RedPointGetReq message. Does not implicitly {@link pb.RedPointGetReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RedPointGetReq
             * @static
             * @param {pb.IRedPointGetReq} message RedPointGetReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedPointGetReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a RedPointGetReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RedPointGetReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RedPointGetReq} RedPointGetReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedPointGetReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RedPointGetReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RedPointGetReq;
        })();
    
        pb.RedPointGetRes = (function() {
    
            /**
             * Properties of a RedPointGetRes.
             * @memberof pb
             * @interface IRedPointGetRes
             * @property {Array.<pb.IRedPoint>|null} [redPoints] RedPointGetRes redPoints
             * @property {number|null} [code] RedPointGetRes code
             */
    
            /**
             * Constructs a new RedPointGetRes.
             * @memberof pb
             * @classdesc Represents a RedPointGetRes.
             * @implements IRedPointGetRes
             * @constructor
             * @param {pb.IRedPointGetRes=} [properties] Properties to set
             */
            function RedPointGetRes(properties) {
                this.redPoints = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RedPointGetRes redPoints.
             * @member {Array.<pb.IRedPoint>} redPoints
             * @memberof pb.RedPointGetRes
             * @instance
             */
            RedPointGetRes.prototype.redPoints = $util.emptyArray;
    
            /**
             * RedPointGetRes code.
             * @member {number} code
             * @memberof pb.RedPointGetRes
             * @instance
             */
            RedPointGetRes.prototype.code = 0;
    
            /**
             * Creates a new RedPointGetRes instance using the specified properties.
             * @function create
             * @memberof pb.RedPointGetRes
             * @static
             * @param {pb.IRedPointGetRes=} [properties] Properties to set
             * @returns {pb.RedPointGetRes} RedPointGetRes instance
             */
            RedPointGetRes.create = function create(properties) {
                return new RedPointGetRes(properties);
            };
    
            /**
             * Encodes the specified RedPointGetRes message. Does not implicitly {@link pb.RedPointGetRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RedPointGetRes
             * @static
             * @param {pb.IRedPointGetRes} message RedPointGetRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedPointGetRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.redPoints != null && message.redPoints.length)
                    for (var i = 0; i < message.redPoints.length; ++i)
                        $root.pb.RedPoint.encode(message.redPoints[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RedPointGetRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RedPointGetRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RedPointGetRes} RedPointGetRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedPointGetRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RedPointGetRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.redPoints && message.redPoints.length))
                            message.redPoints = [];
                        message.redPoints.push($root.pb.RedPoint.decode(reader, reader.uint32()));
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RedPointGetRes;
        })();
    
        pb.RedPointSetReq = (function() {
    
            /**
             * Properties of a RedPointSetReq.
             * @memberof pb
             * @interface IRedPointSetReq
             * @property {Array.<pb.RedPointType>|null} [types] RedPointSetReq types
             */
    
            /**
             * Constructs a new RedPointSetReq.
             * @memberof pb
             * @classdesc Represents a RedPointSetReq.
             * @implements IRedPointSetReq
             * @constructor
             * @param {pb.IRedPointSetReq=} [properties] Properties to set
             */
            function RedPointSetReq(properties) {
                this.types = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RedPointSetReq types.
             * @member {Array.<pb.RedPointType>} types
             * @memberof pb.RedPointSetReq
             * @instance
             */
            RedPointSetReq.prototype.types = $util.emptyArray;
    
            /**
             * Creates a new RedPointSetReq instance using the specified properties.
             * @function create
             * @memberof pb.RedPointSetReq
             * @static
             * @param {pb.IRedPointSetReq=} [properties] Properties to set
             * @returns {pb.RedPointSetReq} RedPointSetReq instance
             */
            RedPointSetReq.create = function create(properties) {
                return new RedPointSetReq(properties);
            };
    
            /**
             * Encodes the specified RedPointSetReq message. Does not implicitly {@link pb.RedPointSetReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RedPointSetReq
             * @static
             * @param {pb.IRedPointSetReq} message RedPointSetReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedPointSetReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.types != null && message.types.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.types.length; ++i)
                        writer.int32(message.types[i]);
                    writer.ldelim();
                }
                return writer;
            };
    
            /**
             * Decodes a RedPointSetReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RedPointSetReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RedPointSetReq} RedPointSetReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedPointSetReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RedPointSetReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.types && message.types.length))
                            message.types = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.types.push(reader.int32());
                        } else
                            message.types.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RedPointSetReq;
        })();
    
        pb.RedPointSetRes = (function() {
    
            /**
             * Properties of a RedPointSetRes.
             * @memberof pb
             * @interface IRedPointSetRes
             * @property {Array.<pb.RedPointType>|null} [types] RedPointSetRes types
             * @property {number|null} [code] RedPointSetRes code
             */
    
            /**
             * Constructs a new RedPointSetRes.
             * @memberof pb
             * @classdesc Represents a RedPointSetRes.
             * @implements IRedPointSetRes
             * @constructor
             * @param {pb.IRedPointSetRes=} [properties] Properties to set
             */
            function RedPointSetRes(properties) {
                this.types = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RedPointSetRes types.
             * @member {Array.<pb.RedPointType>} types
             * @memberof pb.RedPointSetRes
             * @instance
             */
            RedPointSetRes.prototype.types = $util.emptyArray;
    
            /**
             * RedPointSetRes code.
             * @member {number} code
             * @memberof pb.RedPointSetRes
             * @instance
             */
            RedPointSetRes.prototype.code = 0;
    
            /**
             * Creates a new RedPointSetRes instance using the specified properties.
             * @function create
             * @memberof pb.RedPointSetRes
             * @static
             * @param {pb.IRedPointSetRes=} [properties] Properties to set
             * @returns {pb.RedPointSetRes} RedPointSetRes instance
             */
            RedPointSetRes.create = function create(properties) {
                return new RedPointSetRes(properties);
            };
    
            /**
             * Encodes the specified RedPointSetRes message. Does not implicitly {@link pb.RedPointSetRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RedPointSetRes
             * @static
             * @param {pb.IRedPointSetRes} message RedPointSetRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RedPointSetRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.types != null && message.types.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (var i = 0; i < message.types.length; ++i)
                        writer.int32(message.types[i]);
                    writer.ldelim();
                }
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RedPointSetRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RedPointSetRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RedPointSetRes} RedPointSetRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RedPointSetRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RedPointSetRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.types && message.types.length))
                            message.types = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.types.push(reader.int32());
                        } else
                            message.types.push(reader.int32());
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RedPointSetRes;
        })();
    
        pb.GetCoinWhenNoMoneyReq = (function() {
    
            /**
             * Properties of a GetCoinWhenNoMoneyReq.
             * @memberof pb
             * @interface IGetCoinWhenNoMoneyReq
             */
    
            /**
             * Constructs a new GetCoinWhenNoMoneyReq.
             * @memberof pb
             * @classdesc Represents a GetCoinWhenNoMoneyReq.
             * @implements IGetCoinWhenNoMoneyReq
             * @constructor
             * @param {pb.IGetCoinWhenNoMoneyReq=} [properties] Properties to set
             */
            function GetCoinWhenNoMoneyReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetCoinWhenNoMoneyReq instance using the specified properties.
             * @function create
             * @memberof pb.GetCoinWhenNoMoneyReq
             * @static
             * @param {pb.IGetCoinWhenNoMoneyReq=} [properties] Properties to set
             * @returns {pb.GetCoinWhenNoMoneyReq} GetCoinWhenNoMoneyReq instance
             */
            GetCoinWhenNoMoneyReq.create = function create(properties) {
                return new GetCoinWhenNoMoneyReq(properties);
            };
    
            /**
             * Encodes the specified GetCoinWhenNoMoneyReq message. Does not implicitly {@link pb.GetCoinWhenNoMoneyReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GetCoinWhenNoMoneyReq
             * @static
             * @param {pb.IGetCoinWhenNoMoneyReq} message GetCoinWhenNoMoneyReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoinWhenNoMoneyReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetCoinWhenNoMoneyReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetCoinWhenNoMoneyReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetCoinWhenNoMoneyReq} GetCoinWhenNoMoneyReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoinWhenNoMoneyReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCoinWhenNoMoneyReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetCoinWhenNoMoneyReq;
        })();
    
        pb.GetCoinWhenNoMoneyRes = (function() {
    
            /**
             * Properties of a GetCoinWhenNoMoneyRes.
             * @memberof pb
             * @interface IGetCoinWhenNoMoneyRes
             * @property {number|null} [coin] GetCoinWhenNoMoneyRes coin
             * @property {number|null} [code] GetCoinWhenNoMoneyRes code
             */
    
            /**
             * Constructs a new GetCoinWhenNoMoneyRes.
             * @memberof pb
             * @classdesc Represents a GetCoinWhenNoMoneyRes.
             * @implements IGetCoinWhenNoMoneyRes
             * @constructor
             * @param {pb.IGetCoinWhenNoMoneyRes=} [properties] Properties to set
             */
            function GetCoinWhenNoMoneyRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetCoinWhenNoMoneyRes coin.
             * @member {number} coin
             * @memberof pb.GetCoinWhenNoMoneyRes
             * @instance
             */
            GetCoinWhenNoMoneyRes.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GetCoinWhenNoMoneyRes code.
             * @member {number} code
             * @memberof pb.GetCoinWhenNoMoneyRes
             * @instance
             */
            GetCoinWhenNoMoneyRes.prototype.code = 0;
    
            /**
             * Creates a new GetCoinWhenNoMoneyRes instance using the specified properties.
             * @function create
             * @memberof pb.GetCoinWhenNoMoneyRes
             * @static
             * @param {pb.IGetCoinWhenNoMoneyRes=} [properties] Properties to set
             * @returns {pb.GetCoinWhenNoMoneyRes} GetCoinWhenNoMoneyRes instance
             */
            GetCoinWhenNoMoneyRes.create = function create(properties) {
                return new GetCoinWhenNoMoneyRes(properties);
            };
    
            /**
             * Encodes the specified GetCoinWhenNoMoneyRes message. Does not implicitly {@link pb.GetCoinWhenNoMoneyRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GetCoinWhenNoMoneyRes
             * @static
             * @param {pb.IGetCoinWhenNoMoneyRes} message GetCoinWhenNoMoneyRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCoinWhenNoMoneyRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.coin);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetCoinWhenNoMoneyRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetCoinWhenNoMoneyRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetCoinWhenNoMoneyRes} GetCoinWhenNoMoneyRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCoinWhenNoMoneyRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCoinWhenNoMoneyRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.coin = reader.int64();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetCoinWhenNoMoneyRes;
        })();
    
        pb.GetVedioAwardReq = (function() {
    
            /**
             * Properties of a GetVedioAwardReq.
             * @memberof pb
             * @interface IGetVedioAwardReq
             * @property {string|null} [videoId] GetVedioAwardReq videoId
             * @property {boolean|null} [watch] GetVedioAwardReq watch
             */
    
            /**
             * Constructs a new GetVedioAwardReq.
             * @memberof pb
             * @classdesc Represents a GetVedioAwardReq.
             * @implements IGetVedioAwardReq
             * @constructor
             * @param {pb.IGetVedioAwardReq=} [properties] Properties to set
             */
            function GetVedioAwardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetVedioAwardReq videoId.
             * @member {string} videoId
             * @memberof pb.GetVedioAwardReq
             * @instance
             */
            GetVedioAwardReq.prototype.videoId = "";
    
            /**
             * GetVedioAwardReq watch.
             * @member {boolean} watch
             * @memberof pb.GetVedioAwardReq
             * @instance
             */
            GetVedioAwardReq.prototype.watch = false;
    
            /**
             * Creates a new GetVedioAwardReq instance using the specified properties.
             * @function create
             * @memberof pb.GetVedioAwardReq
             * @static
             * @param {pb.IGetVedioAwardReq=} [properties] Properties to set
             * @returns {pb.GetVedioAwardReq} GetVedioAwardReq instance
             */
            GetVedioAwardReq.create = function create(properties) {
                return new GetVedioAwardReq(properties);
            };
    
            /**
             * Encodes the specified GetVedioAwardReq message. Does not implicitly {@link pb.GetVedioAwardReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GetVedioAwardReq
             * @static
             * @param {pb.IGetVedioAwardReq} message GetVedioAwardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVedioAwardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.videoId);
                if (message.watch != null && Object.hasOwnProperty.call(message, "watch"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.watch);
                return writer;
            };
    
            /**
             * Decodes a GetVedioAwardReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetVedioAwardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetVedioAwardReq} GetVedioAwardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVedioAwardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetVedioAwardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.videoId = reader.string();
                        break;
                    case 2:
                        message.watch = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetVedioAwardReq;
        })();
    
        pb.GetVedioAwardRes = (function() {
    
            /**
             * Properties of a GetVedioAwardRes.
             * @memberof pb
             * @interface IGetVedioAwardRes
             * @property {string|null} [videoId] GetVedioAwardRes videoId
             * @property {boolean|null} [watch] GetVedioAwardRes watch
             * @property {Array.<pb.IRewardItem>|null} [award] GetVedioAwardRes award
             * @property {Array.<pb.IRewardItem>|null} [cur] GetVedioAwardRes cur
             * @property {number|null} [code] GetVedioAwardRes code
             */
    
            /**
             * Constructs a new GetVedioAwardRes.
             * @memberof pb
             * @classdesc Represents a GetVedioAwardRes.
             * @implements IGetVedioAwardRes
             * @constructor
             * @param {pb.IGetVedioAwardRes=} [properties] Properties to set
             */
            function GetVedioAwardRes(properties) {
                this.award = [];
                this.cur = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetVedioAwardRes videoId.
             * @member {string} videoId
             * @memberof pb.GetVedioAwardRes
             * @instance
             */
            GetVedioAwardRes.prototype.videoId = "";
    
            /**
             * GetVedioAwardRes watch.
             * @member {boolean} watch
             * @memberof pb.GetVedioAwardRes
             * @instance
             */
            GetVedioAwardRes.prototype.watch = false;
    
            /**
             * GetVedioAwardRes award.
             * @member {Array.<pb.IRewardItem>} award
             * @memberof pb.GetVedioAwardRes
             * @instance
             */
            GetVedioAwardRes.prototype.award = $util.emptyArray;
    
            /**
             * GetVedioAwardRes cur.
             * @member {Array.<pb.IRewardItem>} cur
             * @memberof pb.GetVedioAwardRes
             * @instance
             */
            GetVedioAwardRes.prototype.cur = $util.emptyArray;
    
            /**
             * GetVedioAwardRes code.
             * @member {number} code
             * @memberof pb.GetVedioAwardRes
             * @instance
             */
            GetVedioAwardRes.prototype.code = 0;
    
            /**
             * Creates a new GetVedioAwardRes instance using the specified properties.
             * @function create
             * @memberof pb.GetVedioAwardRes
             * @static
             * @param {pb.IGetVedioAwardRes=} [properties] Properties to set
             * @returns {pb.GetVedioAwardRes} GetVedioAwardRes instance
             */
            GetVedioAwardRes.create = function create(properties) {
                return new GetVedioAwardRes(properties);
            };
    
            /**
             * Encodes the specified GetVedioAwardRes message. Does not implicitly {@link pb.GetVedioAwardRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GetVedioAwardRes
             * @static
             * @param {pb.IGetVedioAwardRes} message GetVedioAwardRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVedioAwardRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.videoId);
                if (message.award != null && message.award.length)
                    for (var i = 0; i < message.award.length; ++i)
                        $root.pb.RewardItem.encode(message.award[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.cur != null && message.cur.length)
                    for (var i = 0; i < message.cur.length; ++i)
                        $root.pb.RewardItem.encode(message.cur[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.watch != null && Object.hasOwnProperty.call(message, "watch"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.watch);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetVedioAwardRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetVedioAwardRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetVedioAwardRes} GetVedioAwardRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVedioAwardRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetVedioAwardRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.videoId = reader.string();
                        break;
                    case 4:
                        message.watch = reader.bool();
                        break;
                    case 2:
                        if (!(message.award && message.award.length))
                            message.award = [];
                        message.award.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.cur && message.cur.length))
                            message.cur = [];
                        message.cur.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetVedioAwardRes;
        })();
    
        pb.GetSceneVideoReq = (function() {
    
            /**
             * Properties of a GetSceneVideoReq.
             * @memberof pb
             * @interface IGetSceneVideoReq
             */
    
            /**
             * Constructs a new GetSceneVideoReq.
             * @memberof pb
             * @classdesc Represents a GetSceneVideoReq.
             * @implements IGetSceneVideoReq
             * @constructor
             * @param {pb.IGetSceneVideoReq=} [properties] Properties to set
             */
            function GetSceneVideoReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetSceneVideoReq instance using the specified properties.
             * @function create
             * @memberof pb.GetSceneVideoReq
             * @static
             * @param {pb.IGetSceneVideoReq=} [properties] Properties to set
             * @returns {pb.GetSceneVideoReq} GetSceneVideoReq instance
             */
            GetSceneVideoReq.create = function create(properties) {
                return new GetSceneVideoReq(properties);
            };
    
            /**
             * Encodes the specified GetSceneVideoReq message. Does not implicitly {@link pb.GetSceneVideoReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GetSceneVideoReq
             * @static
             * @param {pb.IGetSceneVideoReq} message GetSceneVideoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSceneVideoReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetSceneVideoReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetSceneVideoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetSceneVideoReq} GetSceneVideoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSceneVideoReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetSceneVideoReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetSceneVideoReq;
        })();
    
        pb.GetSceneVideoRes = (function() {
    
            /**
             * Properties of a GetSceneVideoRes.
             * @memberof pb
             * @interface IGetSceneVideoRes
             * @property {string|null} [videoId] GetSceneVideoRes videoId
             * @property {number|null} [num] GetSceneVideoRes num
             * @property {number|null} [code] GetSceneVideoRes code
             */
    
            /**
             * Constructs a new GetSceneVideoRes.
             * @memberof pb
             * @classdesc Represents a GetSceneVideoRes.
             * @implements IGetSceneVideoRes
             * @constructor
             * @param {pb.IGetSceneVideoRes=} [properties] Properties to set
             */
            function GetSceneVideoRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetSceneVideoRes videoId.
             * @member {string} videoId
             * @memberof pb.GetSceneVideoRes
             * @instance
             */
            GetSceneVideoRes.prototype.videoId = "";
    
            /**
             * GetSceneVideoRes num.
             * @member {number} num
             * @memberof pb.GetSceneVideoRes
             * @instance
             */
            GetSceneVideoRes.prototype.num = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GetSceneVideoRes code.
             * @member {number} code
             * @memberof pb.GetSceneVideoRes
             * @instance
             */
            GetSceneVideoRes.prototype.code = 0;
    
            /**
             * Creates a new GetSceneVideoRes instance using the specified properties.
             * @function create
             * @memberof pb.GetSceneVideoRes
             * @static
             * @param {pb.IGetSceneVideoRes=} [properties] Properties to set
             * @returns {pb.GetSceneVideoRes} GetSceneVideoRes instance
             */
            GetSceneVideoRes.create = function create(properties) {
                return new GetSceneVideoRes(properties);
            };
    
            /**
             * Encodes the specified GetSceneVideoRes message. Does not implicitly {@link pb.GetSceneVideoRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GetSceneVideoRes
             * @static
             * @param {pb.IGetSceneVideoRes} message GetSceneVideoRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSceneVideoRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.videoId != null && Object.hasOwnProperty.call(message, "videoId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.videoId);
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.num);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetSceneVideoRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetSceneVideoRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetSceneVideoRes} GetSceneVideoRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSceneVideoRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetSceneVideoRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.videoId = reader.string();
                        break;
                    case 2:
                        message.num = reader.int64();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetSceneVideoRes;
        })();
    
        pb.PushMsgReq = (function() {
    
            /**
             * Properties of a PushMsgReq.
             * @memberof pb
             * @interface IPushMsgReq
             */
    
            /**
             * Constructs a new PushMsgReq.
             * @memberof pb
             * @classdesc Represents a PushMsgReq.
             * @implements IPushMsgReq
             * @constructor
             * @param {pb.IPushMsgReq=} [properties] Properties to set
             */
            function PushMsgReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PushMsgReq instance using the specified properties.
             * @function create
             * @memberof pb.PushMsgReq
             * @static
             * @param {pb.IPushMsgReq=} [properties] Properties to set
             * @returns {pb.PushMsgReq} PushMsgReq instance
             */
            PushMsgReq.create = function create(properties) {
                return new PushMsgReq(properties);
            };
    
            /**
             * Encodes the specified PushMsgReq message. Does not implicitly {@link pb.PushMsgReq.verify|verify} messages.
             * @function encode
             * @memberof pb.PushMsgReq
             * @static
             * @param {pb.IPushMsgReq} message PushMsgReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushMsgReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a PushMsgReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PushMsgReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PushMsgReq} PushMsgReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushMsgReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PushMsgReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PushMsgReq;
        })();
    
        pb.PushMsgRes = (function() {
    
            /**
             * Properties of a PushMsgRes.
             * @memberof pb
             * @interface IPushMsgRes
             */
    
            /**
             * Constructs a new PushMsgRes.
             * @memberof pb
             * @classdesc Represents a PushMsgRes.
             * @implements IPushMsgRes
             * @constructor
             * @param {pb.IPushMsgRes=} [properties] Properties to set
             */
            function PushMsgRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new PushMsgRes instance using the specified properties.
             * @function create
             * @memberof pb.PushMsgRes
             * @static
             * @param {pb.IPushMsgRes=} [properties] Properties to set
             * @returns {pb.PushMsgRes} PushMsgRes instance
             */
            PushMsgRes.create = function create(properties) {
                return new PushMsgRes(properties);
            };
    
            /**
             * Encodes the specified PushMsgRes message. Does not implicitly {@link pb.PushMsgRes.verify|verify} messages.
             * @function encode
             * @memberof pb.PushMsgRes
             * @static
             * @param {pb.IPushMsgRes} message PushMsgRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushMsgRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a PushMsgRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.PushMsgRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.PushMsgRes} PushMsgRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushMsgRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PushMsgRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return PushMsgRes;
        })();
    
        pb.GetAppCoinReq = (function() {
    
            /**
             * Properties of a GetAppCoinReq.
             * @memberof pb
             * @interface IGetAppCoinReq
             */
    
            /**
             * Constructs a new GetAppCoinReq.
             * @memberof pb
             * @classdesc Represents a GetAppCoinReq.
             * @implements IGetAppCoinReq
             * @constructor
             * @param {pb.IGetAppCoinReq=} [properties] Properties to set
             */
            function GetAppCoinReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetAppCoinReq instance using the specified properties.
             * @function create
             * @memberof pb.GetAppCoinReq
             * @static
             * @param {pb.IGetAppCoinReq=} [properties] Properties to set
             * @returns {pb.GetAppCoinReq} GetAppCoinReq instance
             */
            GetAppCoinReq.create = function create(properties) {
                return new GetAppCoinReq(properties);
            };
    
            /**
             * Encodes the specified GetAppCoinReq message. Does not implicitly {@link pb.GetAppCoinReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAppCoinReq
             * @static
             * @param {pb.IGetAppCoinReq} message GetAppCoinReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAppCoinReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetAppCoinReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAppCoinReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAppCoinReq} GetAppCoinReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAppCoinReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAppCoinReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAppCoinReq;
        })();
    
        pb.GetAppCoinRes = (function() {
    
            /**
             * Properties of a GetAppCoinRes.
             * @memberof pb
             * @interface IGetAppCoinRes
             * @property {number|null} [appCoin] GetAppCoinRes appCoin
             * @property {number|null} [maxExchangeCount] GetAppCoinRes maxExchangeCount
             * @property {number|null} [rate] GetAppCoinRes rate
             * @property {number|null} [levelExternCoin] GetAppCoinRes levelExternCoin
             * @property {number|null} [baseCoin] GetAppCoinRes baseCoin
             * @property {number|null} [code] GetAppCoinRes code
             */
    
            /**
             * Constructs a new GetAppCoinRes.
             * @memberof pb
             * @classdesc Represents a GetAppCoinRes.
             * @implements IGetAppCoinRes
             * @constructor
             * @param {pb.IGetAppCoinRes=} [properties] Properties to set
             */
            function GetAppCoinRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetAppCoinRes appCoin.
             * @member {number} appCoin
             * @memberof pb.GetAppCoinRes
             * @instance
             */
            GetAppCoinRes.prototype.appCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GetAppCoinRes maxExchangeCount.
             * @member {number} maxExchangeCount
             * @memberof pb.GetAppCoinRes
             * @instance
             */
            GetAppCoinRes.prototype.maxExchangeCount = 0;
    
            /**
             * GetAppCoinRes rate.
             * @member {number} rate
             * @memberof pb.GetAppCoinRes
             * @instance
             */
            GetAppCoinRes.prototype.rate = 0;
    
            /**
             * GetAppCoinRes levelExternCoin.
             * @member {number} levelExternCoin
             * @memberof pb.GetAppCoinRes
             * @instance
             */
            GetAppCoinRes.prototype.levelExternCoin = 0;
    
            /**
             * GetAppCoinRes baseCoin.
             * @member {number} baseCoin
             * @memberof pb.GetAppCoinRes
             * @instance
             */
            GetAppCoinRes.prototype.baseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GetAppCoinRes code.
             * @member {number} code
             * @memberof pb.GetAppCoinRes
             * @instance
             */
            GetAppCoinRes.prototype.code = 0;
    
            /**
             * Creates a new GetAppCoinRes instance using the specified properties.
             * @function create
             * @memberof pb.GetAppCoinRes
             * @static
             * @param {pb.IGetAppCoinRes=} [properties] Properties to set
             * @returns {pb.GetAppCoinRes} GetAppCoinRes instance
             */
            GetAppCoinRes.create = function create(properties) {
                return new GetAppCoinRes(properties);
            };
    
            /**
             * Encodes the specified GetAppCoinRes message. Does not implicitly {@link pb.GetAppCoinRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAppCoinRes
             * @static
             * @param {pb.IGetAppCoinRes} message GetAppCoinRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAppCoinRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appCoin != null && Object.hasOwnProperty.call(message, "appCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.appCoin);
                if (message.maxExchangeCount != null && Object.hasOwnProperty.call(message, "maxExchangeCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxExchangeCount);
                if (message.rate != null && Object.hasOwnProperty.call(message, "rate"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rate);
                if (message.levelExternCoin != null && Object.hasOwnProperty.call(message, "levelExternCoin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.levelExternCoin);
                if (message.baseCoin != null && Object.hasOwnProperty.call(message, "baseCoin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.baseCoin);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetAppCoinRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAppCoinRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAppCoinRes} GetAppCoinRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAppCoinRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAppCoinRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.appCoin = reader.int64();
                        break;
                    case 2:
                        message.maxExchangeCount = reader.int32();
                        break;
                    case 3:
                        message.rate = reader.int32();
                        break;
                    case 4:
                        message.levelExternCoin = reader.int32();
                        break;
                    case 5:
                        message.baseCoin = reader.int64();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAppCoinRes;
        })();
    
        pb.ExchangeAppCoinReq = (function() {
    
            /**
             * Properties of an ExchangeAppCoinReq.
             * @memberof pb
             * @interface IExchangeAppCoinReq
             * @property {number|null} [num] ExchangeAppCoinReq num
             */
    
            /**
             * Constructs a new ExchangeAppCoinReq.
             * @memberof pb
             * @classdesc Represents an ExchangeAppCoinReq.
             * @implements IExchangeAppCoinReq
             * @constructor
             * @param {pb.IExchangeAppCoinReq=} [properties] Properties to set
             */
            function ExchangeAppCoinReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ExchangeAppCoinReq num.
             * @member {number} num
             * @memberof pb.ExchangeAppCoinReq
             * @instance
             */
            ExchangeAppCoinReq.prototype.num = 0;
    
            /**
             * Creates a new ExchangeAppCoinReq instance using the specified properties.
             * @function create
             * @memberof pb.ExchangeAppCoinReq
             * @static
             * @param {pb.IExchangeAppCoinReq=} [properties] Properties to set
             * @returns {pb.ExchangeAppCoinReq} ExchangeAppCoinReq instance
             */
            ExchangeAppCoinReq.create = function create(properties) {
                return new ExchangeAppCoinReq(properties);
            };
    
            /**
             * Encodes the specified ExchangeAppCoinReq message. Does not implicitly {@link pb.ExchangeAppCoinReq.verify|verify} messages.
             * @function encode
             * @memberof pb.ExchangeAppCoinReq
             * @static
             * @param {pb.IExchangeAppCoinReq} message ExchangeAppCoinReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExchangeAppCoinReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                return writer;
            };
    
            /**
             * Decodes an ExchangeAppCoinReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ExchangeAppCoinReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ExchangeAppCoinReq} ExchangeAppCoinReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExchangeAppCoinReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ExchangeAppCoinReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ExchangeAppCoinReq;
        })();
    
        pb.ExchangeAppCoinRes = (function() {
    
            /**
             * Properties of an ExchangeAppCoinRes.
             * @memberof pb
             * @interface IExchangeAppCoinRes
             * @property {number|null} [num] ExchangeAppCoinRes num
             * @property {number|null} [newCoin] ExchangeAppCoinRes newCoin
             * @property {number|null} [addCoin] ExchangeAppCoinRes addCoin
             * @property {number|null} [code] ExchangeAppCoinRes code
             */
    
            /**
             * Constructs a new ExchangeAppCoinRes.
             * @memberof pb
             * @classdesc Represents an ExchangeAppCoinRes.
             * @implements IExchangeAppCoinRes
             * @constructor
             * @param {pb.IExchangeAppCoinRes=} [properties] Properties to set
             */
            function ExchangeAppCoinRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ExchangeAppCoinRes num.
             * @member {number} num
             * @memberof pb.ExchangeAppCoinRes
             * @instance
             */
            ExchangeAppCoinRes.prototype.num = 0;
    
            /**
             * ExchangeAppCoinRes newCoin.
             * @member {number} newCoin
             * @memberof pb.ExchangeAppCoinRes
             * @instance
             */
            ExchangeAppCoinRes.prototype.newCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ExchangeAppCoinRes addCoin.
             * @member {number} addCoin
             * @memberof pb.ExchangeAppCoinRes
             * @instance
             */
            ExchangeAppCoinRes.prototype.addCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * ExchangeAppCoinRes code.
             * @member {number} code
             * @memberof pb.ExchangeAppCoinRes
             * @instance
             */
            ExchangeAppCoinRes.prototype.code = 0;
    
            /**
             * Creates a new ExchangeAppCoinRes instance using the specified properties.
             * @function create
             * @memberof pb.ExchangeAppCoinRes
             * @static
             * @param {pb.IExchangeAppCoinRes=} [properties] Properties to set
             * @returns {pb.ExchangeAppCoinRes} ExchangeAppCoinRes instance
             */
            ExchangeAppCoinRes.create = function create(properties) {
                return new ExchangeAppCoinRes(properties);
            };
    
            /**
             * Encodes the specified ExchangeAppCoinRes message. Does not implicitly {@link pb.ExchangeAppCoinRes.verify|verify} messages.
             * @function encode
             * @memberof pb.ExchangeAppCoinRes
             * @static
             * @param {pb.IExchangeAppCoinRes} message ExchangeAppCoinRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExchangeAppCoinRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                if (message.newCoin != null && Object.hasOwnProperty.call(message, "newCoin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.newCoin);
                if (message.addCoin != null && Object.hasOwnProperty.call(message, "addCoin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.addCoin);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes an ExchangeAppCoinRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ExchangeAppCoinRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ExchangeAppCoinRes} ExchangeAppCoinRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExchangeAppCoinRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ExchangeAppCoinRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.newCoin = reader.int64();
                        break;
                    case 3:
                        message.addCoin = reader.int64();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ExchangeAppCoinRes;
        })();
    
        pb.RaceGetReq = (function() {
    
            /**
             * Properties of a RaceGetReq.
             * @memberof pb
             * @interface IRaceGetReq
             */
    
            /**
             * Constructs a new RaceGetReq.
             * @memberof pb
             * @classdesc Represents a RaceGetReq.
             * @implements IRaceGetReq
             * @constructor
             * @param {pb.IRaceGetReq=} [properties] Properties to set
             */
            function RaceGetReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new RaceGetReq instance using the specified properties.
             * @function create
             * @memberof pb.RaceGetReq
             * @static
             * @param {pb.IRaceGetReq=} [properties] Properties to set
             * @returns {pb.RaceGetReq} RaceGetReq instance
             */
            RaceGetReq.create = function create(properties) {
                return new RaceGetReq(properties);
            };
    
            /**
             * Encodes the specified RaceGetReq message. Does not implicitly {@link pb.RaceGetReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceGetReq
             * @static
             * @param {pb.IRaceGetReq} message RaceGetReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceGetReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a RaceGetReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceGetReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceGetReq} RaceGetReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceGetReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceGetReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceGetReq;
        })();
    
        pb.RaceGetRes = (function() {
    
            /**
             * Properties of a RaceGetRes.
             * @memberof pb
             * @interface IRaceGetRes
             * @property {number|null} [leftFreeTicket] RaceGetRes leftFreeTicket
             * @property {number|null} [ticketRefreshTime] RaceGetRes ticketRefreshTime
             * @property {number|null} [leftBuyTicket] RaceGetRes leftBuyTicket
             * @property {number|null} [rateStatus] RaceGetRes rateStatus
             * @property {number|null} [winCount] RaceGetRes winCount
             * @property {number|null} [bestWinCount] RaceGetRes bestWinCount
             * @property {number|null} [leftShareCount] RaceGetRes leftShareCount
             * @property {string|null} [shareId] RaceGetRes shareId
             * @property {number|null} [ticketCoin] RaceGetRes ticketCoin
             * @property {number|null} [code] RaceGetRes code
             * @property {boolean|null} [playRaceFlag] RaceGetRes playRaceFlag
             * @property {number|null} [hagoCoin] RaceGetRes hagoCoin
             */
    
            /**
             * Constructs a new RaceGetRes.
             * @memberof pb
             * @classdesc Represents a RaceGetRes.
             * @implements IRaceGetRes
             * @constructor
             * @param {pb.IRaceGetRes=} [properties] Properties to set
             */
            function RaceGetRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceGetRes leftFreeTicket.
             * @member {number} leftFreeTicket
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.leftFreeTicket = 0;
    
            /**
             * RaceGetRes ticketRefreshTime.
             * @member {number} ticketRefreshTime
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.ticketRefreshTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * RaceGetRes leftBuyTicket.
             * @member {number} leftBuyTicket
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.leftBuyTicket = 0;
    
            /**
             * RaceGetRes rateStatus.
             * @member {number} rateStatus
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.rateStatus = 0;
    
            /**
             * RaceGetRes winCount.
             * @member {number} winCount
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.winCount = 0;
    
            /**
             * RaceGetRes bestWinCount.
             * @member {number} bestWinCount
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.bestWinCount = 0;
    
            /**
             * RaceGetRes leftShareCount.
             * @member {number} leftShareCount
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.leftShareCount = 0;
    
            /**
             * RaceGetRes shareId.
             * @member {string} shareId
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.shareId = "";
    
            /**
             * RaceGetRes ticketCoin.
             * @member {number} ticketCoin
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.ticketCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * RaceGetRes code.
             * @member {number} code
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.code = 0;
    
            /**
             * RaceGetRes playRaceFlag.
             * @member {boolean} playRaceFlag
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.playRaceFlag = false;
    
            /**
             * RaceGetRes hagoCoin.
             * @member {number} hagoCoin
             * @memberof pb.RaceGetRes
             * @instance
             */
            RaceGetRes.prototype.hagoCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new RaceGetRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceGetRes
             * @static
             * @param {pb.IRaceGetRes=} [properties] Properties to set
             * @returns {pb.RaceGetRes} RaceGetRes instance
             */
            RaceGetRes.create = function create(properties) {
                return new RaceGetRes(properties);
            };
    
            /**
             * Encodes the specified RaceGetRes message. Does not implicitly {@link pb.RaceGetRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceGetRes
             * @static
             * @param {pb.IRaceGetRes} message RaceGetRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceGetRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftFreeTicket != null && Object.hasOwnProperty.call(message, "leftFreeTicket"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leftFreeTicket);
                if (message.ticketRefreshTime != null && Object.hasOwnProperty.call(message, "ticketRefreshTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ticketRefreshTime);
                if (message.rateStatus != null && Object.hasOwnProperty.call(message, "rateStatus"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rateStatus);
                if (message.winCount != null && Object.hasOwnProperty.call(message, "winCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.winCount);
                if (message.leftShareCount != null && Object.hasOwnProperty.call(message, "leftShareCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.leftShareCount);
                if (message.leftBuyTicket != null && Object.hasOwnProperty.call(message, "leftBuyTicket"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.leftBuyTicket);
                if (message.bestWinCount != null && Object.hasOwnProperty.call(message, "bestWinCount"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.bestWinCount);
                if (message.shareId != null && Object.hasOwnProperty.call(message, "shareId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.shareId);
                if (message.ticketCoin != null && Object.hasOwnProperty.call(message, "ticketCoin"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int64(message.ticketCoin);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                if (message.playRaceFlag != null && Object.hasOwnProperty.call(message, "playRaceFlag"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.playRaceFlag);
                if (message.hagoCoin != null && Object.hasOwnProperty.call(message, "hagoCoin"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int64(message.hagoCoin);
                return writer;
            };
    
            /**
             * Decodes a RaceGetRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceGetRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceGetRes} RaceGetRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceGetRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceGetRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftFreeTicket = reader.int32();
                        break;
                    case 2:
                        message.ticketRefreshTime = reader.int64();
                        break;
                    case 8:
                        message.leftBuyTicket = reader.int32();
                        break;
                    case 3:
                        message.rateStatus = reader.int32();
                        break;
                    case 4:
                        message.winCount = reader.int32();
                        break;
                    case 9:
                        message.bestWinCount = reader.int32();
                        break;
                    case 5:
                        message.leftShareCount = reader.int32();
                        break;
                    case 10:
                        message.shareId = reader.string();
                        break;
                    case 13:
                        message.ticketCoin = reader.int64();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    case 16:
                        message.playRaceFlag = reader.bool();
                        break;
                    case 17:
                        message.hagoCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceGetRes;
        })();
    
        pb.RaceAwardMessage = (function() {
    
            /**
             * Properties of a RaceAwardMessage.
             * @memberof pb
             * @interface IRaceAwardMessage
             * @property {number|null} [winCount] RaceAwardMessage winCount
             * @property {pb.IRewardItem|null} [items] RaceAwardMessage items
             */
    
            /**
             * Constructs a new RaceAwardMessage.
             * @memberof pb
             * @classdesc Represents a RaceAwardMessage.
             * @implements IRaceAwardMessage
             * @constructor
             * @param {pb.IRaceAwardMessage=} [properties] Properties to set
             */
            function RaceAwardMessage(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceAwardMessage winCount.
             * @member {number} winCount
             * @memberof pb.RaceAwardMessage
             * @instance
             */
            RaceAwardMessage.prototype.winCount = 0;
    
            /**
             * RaceAwardMessage items.
             * @member {pb.IRewardItem|null|undefined} items
             * @memberof pb.RaceAwardMessage
             * @instance
             */
            RaceAwardMessage.prototype.items = null;
    
            /**
             * Creates a new RaceAwardMessage instance using the specified properties.
             * @function create
             * @memberof pb.RaceAwardMessage
             * @static
             * @param {pb.IRaceAwardMessage=} [properties] Properties to set
             * @returns {pb.RaceAwardMessage} RaceAwardMessage instance
             */
            RaceAwardMessage.create = function create(properties) {
                return new RaceAwardMessage(properties);
            };
    
            /**
             * Encodes the specified RaceAwardMessage message. Does not implicitly {@link pb.RaceAwardMessage.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceAwardMessage
             * @static
             * @param {pb.IRaceAwardMessage} message RaceAwardMessage message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceAwardMessage.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.winCount != null && Object.hasOwnProperty.call(message, "winCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.winCount);
                if (message.items != null && Object.hasOwnProperty.call(message, "items"))
                    $root.pb.RewardItem.encode(message.items, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a RaceAwardMessage message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceAwardMessage
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceAwardMessage} RaceAwardMessage
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceAwardMessage.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceAwardMessage();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.winCount = reader.int32();
                        break;
                    case 2:
                        message.items = $root.pb.RewardItem.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceAwardMessage;
        })();
    
        pb.RaceStartAndMatchReq = (function() {
    
            /**
             * Properties of a RaceStartAndMatchReq.
             * @memberof pb
             * @interface IRaceStartAndMatchReq
             */
    
            /**
             * Constructs a new RaceStartAndMatchReq.
             * @memberof pb
             * @classdesc Represents a RaceStartAndMatchReq.
             * @implements IRaceStartAndMatchReq
             * @constructor
             * @param {pb.IRaceStartAndMatchReq=} [properties] Properties to set
             */
            function RaceStartAndMatchReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new RaceStartAndMatchReq instance using the specified properties.
             * @function create
             * @memberof pb.RaceStartAndMatchReq
             * @static
             * @param {pb.IRaceStartAndMatchReq=} [properties] Properties to set
             * @returns {pb.RaceStartAndMatchReq} RaceStartAndMatchReq instance
             */
            RaceStartAndMatchReq.create = function create(properties) {
                return new RaceStartAndMatchReq(properties);
            };
    
            /**
             * Encodes the specified RaceStartAndMatchReq message. Does not implicitly {@link pb.RaceStartAndMatchReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceStartAndMatchReq
             * @static
             * @param {pb.IRaceStartAndMatchReq} message RaceStartAndMatchReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceStartAndMatchReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a RaceStartAndMatchReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceStartAndMatchReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceStartAndMatchReq} RaceStartAndMatchReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceStartAndMatchReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceStartAndMatchReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceStartAndMatchReq;
        })();
    
        pb.RaceStartAndMatchRes = (function() {
    
            /**
             * Properties of a RaceStartAndMatchRes.
             * @memberof pb
             * @interface IRaceStartAndMatchRes
             * @property {number|null} [leftTicket] RaceStartAndMatchRes leftTicket
             * @property {number|null} [code] RaceStartAndMatchRes code
             */
    
            /**
             * Constructs a new RaceStartAndMatchRes.
             * @memberof pb
             * @classdesc Represents a RaceStartAndMatchRes.
             * @implements IRaceStartAndMatchRes
             * @constructor
             * @param {pb.IRaceStartAndMatchRes=} [properties] Properties to set
             */
            function RaceStartAndMatchRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceStartAndMatchRes leftTicket.
             * @member {number} leftTicket
             * @memberof pb.RaceStartAndMatchRes
             * @instance
             */
            RaceStartAndMatchRes.prototype.leftTicket = 0;
    
            /**
             * RaceStartAndMatchRes code.
             * @member {number} code
             * @memberof pb.RaceStartAndMatchRes
             * @instance
             */
            RaceStartAndMatchRes.prototype.code = 0;
    
            /**
             * Creates a new RaceStartAndMatchRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceStartAndMatchRes
             * @static
             * @param {pb.IRaceStartAndMatchRes=} [properties] Properties to set
             * @returns {pb.RaceStartAndMatchRes} RaceStartAndMatchRes instance
             */
            RaceStartAndMatchRes.create = function create(properties) {
                return new RaceStartAndMatchRes(properties);
            };
    
            /**
             * Encodes the specified RaceStartAndMatchRes message. Does not implicitly {@link pb.RaceStartAndMatchRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceStartAndMatchRes
             * @static
             * @param {pb.IRaceStartAndMatchRes} message RaceStartAndMatchRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceStartAndMatchRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftTicket != null && Object.hasOwnProperty.call(message, "leftTicket"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leftTicket);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RaceStartAndMatchRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceStartAndMatchRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceStartAndMatchRes} RaceStartAndMatchRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceStartAndMatchRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceStartAndMatchRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftTicket = reader.int32();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceStartAndMatchRes;
        })();
    
        pb.RaceMatchReq = (function() {
    
            /**
             * Properties of a RaceMatchReq.
             * @memberof pb
             * @interface IRaceMatchReq
             */
    
            /**
             * Constructs a new RaceMatchReq.
             * @memberof pb
             * @classdesc Represents a RaceMatchReq.
             * @implements IRaceMatchReq
             * @constructor
             * @param {pb.IRaceMatchReq=} [properties] Properties to set
             */
            function RaceMatchReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new RaceMatchReq instance using the specified properties.
             * @function create
             * @memberof pb.RaceMatchReq
             * @static
             * @param {pb.IRaceMatchReq=} [properties] Properties to set
             * @returns {pb.RaceMatchReq} RaceMatchReq instance
             */
            RaceMatchReq.create = function create(properties) {
                return new RaceMatchReq(properties);
            };
    
            /**
             * Encodes the specified RaceMatchReq message. Does not implicitly {@link pb.RaceMatchReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceMatchReq
             * @static
             * @param {pb.IRaceMatchReq} message RaceMatchReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceMatchReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a RaceMatchReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceMatchReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceMatchReq} RaceMatchReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceMatchReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceMatchReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceMatchReq;
        })();
    
        pb.RaceMatchRes = (function() {
    
            /**
             * Properties of a RaceMatchRes.
             * @memberof pb
             * @interface IRaceMatchRes
             * @property {number|null} [code] RaceMatchRes code
             */
    
            /**
             * Constructs a new RaceMatchRes.
             * @memberof pb
             * @classdesc Represents a RaceMatchRes.
             * @implements IRaceMatchRes
             * @constructor
             * @param {pb.IRaceMatchRes=} [properties] Properties to set
             */
            function RaceMatchRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceMatchRes code.
             * @member {number} code
             * @memberof pb.RaceMatchRes
             * @instance
             */
            RaceMatchRes.prototype.code = 0;
    
            /**
             * Creates a new RaceMatchRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceMatchRes
             * @static
             * @param {pb.IRaceMatchRes=} [properties] Properties to set
             * @returns {pb.RaceMatchRes} RaceMatchRes instance
             */
            RaceMatchRes.create = function create(properties) {
                return new RaceMatchRes(properties);
            };
    
            /**
             * Encodes the specified RaceMatchRes message. Does not implicitly {@link pb.RaceMatchRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceMatchRes
             * @static
             * @param {pb.IRaceMatchRes} message RaceMatchRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceMatchRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RaceMatchRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceMatchRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceMatchRes} RaceMatchRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceMatchRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceMatchRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceMatchRes;
        })();
    
        pb.RaceMatchSuccessRes = (function() {
    
            /**
             * Properties of a RaceMatchSuccessRes.
             * @memberof pb
             * @interface IRaceMatchSuccessRes
             * @property {number|null} [code] RaceMatchSuccessRes code
             * @property {string|null} [roomId] RaceMatchSuccessRes roomId
             * @property {number|null} [timestamp] RaceMatchSuccessRes timestamp
             * @property {string|null} [opt] RaceMatchSuccessRes opt
             * @property {string|null} [sign] RaceMatchSuccessRes sign
             * @property {string|null} [problemUid] RaceMatchSuccessRes problemUid
             * @property {number|null} [gameType] RaceMatchSuccessRes gameType
             * @property {number|null} [otherWinCount] RaceMatchSuccessRes otherWinCount
             * @property {string|null} [sn] RaceMatchSuccessRes sn
             */
    
            /**
             * Constructs a new RaceMatchSuccessRes.
             * @memberof pb
             * @classdesc Represents a RaceMatchSuccessRes.
             * @implements IRaceMatchSuccessRes
             * @constructor
             * @param {pb.IRaceMatchSuccessRes=} [properties] Properties to set
             */
            function RaceMatchSuccessRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceMatchSuccessRes code.
             * @member {number} code
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.code = 0;
    
            /**
             * RaceMatchSuccessRes roomId.
             * @member {string} roomId
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.roomId = "";
    
            /**
             * RaceMatchSuccessRes timestamp.
             * @member {number} timestamp
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * RaceMatchSuccessRes opt.
             * @member {string} opt
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.opt = "";
    
            /**
             * RaceMatchSuccessRes sign.
             * @member {string} sign
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.sign = "";
    
            /**
             * RaceMatchSuccessRes problemUid.
             * @member {string} problemUid
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.problemUid = "";
    
            /**
             * RaceMatchSuccessRes gameType.
             * @member {number} gameType
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.gameType = 0;
    
            /**
             * RaceMatchSuccessRes otherWinCount.
             * @member {number} otherWinCount
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.otherWinCount = 0;
    
            /**
             * RaceMatchSuccessRes sn.
             * @member {string} sn
             * @memberof pb.RaceMatchSuccessRes
             * @instance
             */
            RaceMatchSuccessRes.prototype.sn = "";
    
            /**
             * Creates a new RaceMatchSuccessRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceMatchSuccessRes
             * @static
             * @param {pb.IRaceMatchSuccessRes=} [properties] Properties to set
             * @returns {pb.RaceMatchSuccessRes} RaceMatchSuccessRes instance
             */
            RaceMatchSuccessRes.create = function create(properties) {
                return new RaceMatchSuccessRes(properties);
            };
    
            /**
             * Encodes the specified RaceMatchSuccessRes message. Does not implicitly {@link pb.RaceMatchSuccessRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceMatchSuccessRes
             * @static
             * @param {pb.IRaceMatchSuccessRes} message RaceMatchSuccessRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceMatchSuccessRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);
                if (message.problemUid != null && Object.hasOwnProperty.call(message, "problemUid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.problemUid);
                if (message.gameType != null && Object.hasOwnProperty.call(message, "gameType"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.gameType);
                if (message.otherWinCount != null && Object.hasOwnProperty.call(message, "otherWinCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.otherWinCount);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a RaceMatchSuccessRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceMatchSuccessRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceMatchSuccessRes} RaceMatchSuccessRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceMatchSuccessRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceMatchSuccessRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.roomId = reader.string();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.opt = reader.string();
                        break;
                    case 5:
                        message.sign = reader.string();
                        break;
                    case 6:
                        message.problemUid = reader.string();
                        break;
                    case 7:
                        message.gameType = reader.int32();
                        break;
                    case 8:
                        message.otherWinCount = reader.int32();
                        break;
                    case 15:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceMatchSuccessRes;
        })();
    
        pb.RaceShareAwaidTicketReq = (function() {
    
            /**
             * Properties of a RaceShareAwaidTicketReq.
             * @memberof pb
             * @interface IRaceShareAwaidTicketReq
             * @property {string|null} [shareId] RaceShareAwaidTicketReq shareId
             */
    
            /**
             * Constructs a new RaceShareAwaidTicketReq.
             * @memberof pb
             * @classdesc Represents a RaceShareAwaidTicketReq.
             * @implements IRaceShareAwaidTicketReq
             * @constructor
             * @param {pb.IRaceShareAwaidTicketReq=} [properties] Properties to set
             */
            function RaceShareAwaidTicketReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceShareAwaidTicketReq shareId.
             * @member {string} shareId
             * @memberof pb.RaceShareAwaidTicketReq
             * @instance
             */
            RaceShareAwaidTicketReq.prototype.shareId = "";
    
            /**
             * Creates a new RaceShareAwaidTicketReq instance using the specified properties.
             * @function create
             * @memberof pb.RaceShareAwaidTicketReq
             * @static
             * @param {pb.IRaceShareAwaidTicketReq=} [properties] Properties to set
             * @returns {pb.RaceShareAwaidTicketReq} RaceShareAwaidTicketReq instance
             */
            RaceShareAwaidTicketReq.create = function create(properties) {
                return new RaceShareAwaidTicketReq(properties);
            };
    
            /**
             * Encodes the specified RaceShareAwaidTicketReq message. Does not implicitly {@link pb.RaceShareAwaidTicketReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceShareAwaidTicketReq
             * @static
             * @param {pb.IRaceShareAwaidTicketReq} message RaceShareAwaidTicketReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceShareAwaidTicketReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.shareId != null && Object.hasOwnProperty.call(message, "shareId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.shareId);
                return writer;
            };
    
            /**
             * Decodes a RaceShareAwaidTicketReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceShareAwaidTicketReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceShareAwaidTicketReq} RaceShareAwaidTicketReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceShareAwaidTicketReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceShareAwaidTicketReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.shareId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceShareAwaidTicketReq;
        })();
    
        pb.RaceShareAwaidTicketRes = (function() {
    
            /**
             * Properties of a RaceShareAwaidTicketRes.
             * @memberof pb
             * @interface IRaceShareAwaidTicketRes
             * @property {number|null} [leftFreeTicket] RaceShareAwaidTicketRes leftFreeTicket
             * @property {number|null} [ticketRefreshTime] RaceShareAwaidTicketRes ticketRefreshTime
             * @property {number|null} [leftBuyTicket] RaceShareAwaidTicketRes leftBuyTicket
             * @property {number|null} [rateStatus] RaceShareAwaidTicketRes rateStatus
             * @property {number|null} [winCount] RaceShareAwaidTicketRes winCount
             * @property {number|null} [bestWinCount] RaceShareAwaidTicketRes bestWinCount
             * @property {number|null} [leftShareCount] RaceShareAwaidTicketRes leftShareCount
             * @property {string|null} [newShareId] RaceShareAwaidTicketRes newShareId
             * @property {string|null} [shareId] RaceShareAwaidTicketRes shareId
             * @property {number|null} [code] RaceShareAwaidTicketRes code
             */
    
            /**
             * Constructs a new RaceShareAwaidTicketRes.
             * @memberof pb
             * @classdesc Represents a RaceShareAwaidTicketRes.
             * @implements IRaceShareAwaidTicketRes
             * @constructor
             * @param {pb.IRaceShareAwaidTicketRes=} [properties] Properties to set
             */
            function RaceShareAwaidTicketRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceShareAwaidTicketRes leftFreeTicket.
             * @member {number} leftFreeTicket
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.leftFreeTicket = 0;
    
            /**
             * RaceShareAwaidTicketRes ticketRefreshTime.
             * @member {number} ticketRefreshTime
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.ticketRefreshTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * RaceShareAwaidTicketRes leftBuyTicket.
             * @member {number} leftBuyTicket
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.leftBuyTicket = 0;
    
            /**
             * RaceShareAwaidTicketRes rateStatus.
             * @member {number} rateStatus
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.rateStatus = 0;
    
            /**
             * RaceShareAwaidTicketRes winCount.
             * @member {number} winCount
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.winCount = 0;
    
            /**
             * RaceShareAwaidTicketRes bestWinCount.
             * @member {number} bestWinCount
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.bestWinCount = 0;
    
            /**
             * RaceShareAwaidTicketRes leftShareCount.
             * @member {number} leftShareCount
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.leftShareCount = 0;
    
            /**
             * RaceShareAwaidTicketRes newShareId.
             * @member {string} newShareId
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.newShareId = "";
    
            /**
             * RaceShareAwaidTicketRes shareId.
             * @member {string} shareId
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.shareId = "";
    
            /**
             * RaceShareAwaidTicketRes code.
             * @member {number} code
             * @memberof pb.RaceShareAwaidTicketRes
             * @instance
             */
            RaceShareAwaidTicketRes.prototype.code = 0;
    
            /**
             * Creates a new RaceShareAwaidTicketRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceShareAwaidTicketRes
             * @static
             * @param {pb.IRaceShareAwaidTicketRes=} [properties] Properties to set
             * @returns {pb.RaceShareAwaidTicketRes} RaceShareAwaidTicketRes instance
             */
            RaceShareAwaidTicketRes.create = function create(properties) {
                return new RaceShareAwaidTicketRes(properties);
            };
    
            /**
             * Encodes the specified RaceShareAwaidTicketRes message. Does not implicitly {@link pb.RaceShareAwaidTicketRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceShareAwaidTicketRes
             * @static
             * @param {pb.IRaceShareAwaidTicketRes} message RaceShareAwaidTicketRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceShareAwaidTicketRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftFreeTicket != null && Object.hasOwnProperty.call(message, "leftFreeTicket"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leftFreeTicket);
                if (message.ticketRefreshTime != null && Object.hasOwnProperty.call(message, "ticketRefreshTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ticketRefreshTime);
                if (message.rateStatus != null && Object.hasOwnProperty.call(message, "rateStatus"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rateStatus);
                if (message.winCount != null && Object.hasOwnProperty.call(message, "winCount"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.winCount);
                if (message.leftShareCount != null && Object.hasOwnProperty.call(message, "leftShareCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.leftShareCount);
                if (message.leftBuyTicket != null && Object.hasOwnProperty.call(message, "leftBuyTicket"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.leftBuyTicket);
                if (message.bestWinCount != null && Object.hasOwnProperty.call(message, "bestWinCount"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.bestWinCount);
                if (message.newShareId != null && Object.hasOwnProperty.call(message, "newShareId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.newShareId);
                if (message.shareId != null && Object.hasOwnProperty.call(message, "shareId"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.shareId);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RaceShareAwaidTicketRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceShareAwaidTicketRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceShareAwaidTicketRes} RaceShareAwaidTicketRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceShareAwaidTicketRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceShareAwaidTicketRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftFreeTicket = reader.int32();
                        break;
                    case 2:
                        message.ticketRefreshTime = reader.int64();
                        break;
                    case 8:
                        message.leftBuyTicket = reader.int32();
                        break;
                    case 3:
                        message.rateStatus = reader.int32();
                        break;
                    case 4:
                        message.winCount = reader.int32();
                        break;
                    case 9:
                        message.bestWinCount = reader.int32();
                        break;
                    case 5:
                        message.leftShareCount = reader.int32();
                        break;
                    case 10:
                        message.newShareId = reader.string();
                        break;
                    case 11:
                        message.shareId = reader.string();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceShareAwaidTicketRes;
        })();
    
        pb.RaceGetFreeTicketReq = (function() {
    
            /**
             * Properties of a RaceGetFreeTicketReq.
             * @memberof pb
             * @interface IRaceGetFreeTicketReq
             */
    
            /**
             * Constructs a new RaceGetFreeTicketReq.
             * @memberof pb
             * @classdesc Represents a RaceGetFreeTicketReq.
             * @implements IRaceGetFreeTicketReq
             * @constructor
             * @param {pb.IRaceGetFreeTicketReq=} [properties] Properties to set
             */
            function RaceGetFreeTicketReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new RaceGetFreeTicketReq instance using the specified properties.
             * @function create
             * @memberof pb.RaceGetFreeTicketReq
             * @static
             * @param {pb.IRaceGetFreeTicketReq=} [properties] Properties to set
             * @returns {pb.RaceGetFreeTicketReq} RaceGetFreeTicketReq instance
             */
            RaceGetFreeTicketReq.create = function create(properties) {
                return new RaceGetFreeTicketReq(properties);
            };
    
            /**
             * Encodes the specified RaceGetFreeTicketReq message. Does not implicitly {@link pb.RaceGetFreeTicketReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceGetFreeTicketReq
             * @static
             * @param {pb.IRaceGetFreeTicketReq} message RaceGetFreeTicketReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceGetFreeTicketReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a RaceGetFreeTicketReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceGetFreeTicketReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceGetFreeTicketReq} RaceGetFreeTicketReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceGetFreeTicketReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceGetFreeTicketReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceGetFreeTicketReq;
        })();
    
        pb.RaceGetFreeTicketRes = (function() {
    
            /**
             * Properties of a RaceGetFreeTicketRes.
             * @memberof pb
             * @interface IRaceGetFreeTicketRes
             * @property {number|null} [leftFreeTicket] RaceGetFreeTicketRes leftFreeTicket
             * @property {number|null} [ticketRefreshTime] RaceGetFreeTicketRes ticketRefreshTime
             * @property {number|null} [code] RaceGetFreeTicketRes code
             */
    
            /**
             * Constructs a new RaceGetFreeTicketRes.
             * @memberof pb
             * @classdesc Represents a RaceGetFreeTicketRes.
             * @implements IRaceGetFreeTicketRes
             * @constructor
             * @param {pb.IRaceGetFreeTicketRes=} [properties] Properties to set
             */
            function RaceGetFreeTicketRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceGetFreeTicketRes leftFreeTicket.
             * @member {number} leftFreeTicket
             * @memberof pb.RaceGetFreeTicketRes
             * @instance
             */
            RaceGetFreeTicketRes.prototype.leftFreeTicket = 0;
    
            /**
             * RaceGetFreeTicketRes ticketRefreshTime.
             * @member {number} ticketRefreshTime
             * @memberof pb.RaceGetFreeTicketRes
             * @instance
             */
            RaceGetFreeTicketRes.prototype.ticketRefreshTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * RaceGetFreeTicketRes code.
             * @member {number} code
             * @memberof pb.RaceGetFreeTicketRes
             * @instance
             */
            RaceGetFreeTicketRes.prototype.code = 0;
    
            /**
             * Creates a new RaceGetFreeTicketRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceGetFreeTicketRes
             * @static
             * @param {pb.IRaceGetFreeTicketRes=} [properties] Properties to set
             * @returns {pb.RaceGetFreeTicketRes} RaceGetFreeTicketRes instance
             */
            RaceGetFreeTicketRes.create = function create(properties) {
                return new RaceGetFreeTicketRes(properties);
            };
    
            /**
             * Encodes the specified RaceGetFreeTicketRes message. Does not implicitly {@link pb.RaceGetFreeTicketRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceGetFreeTicketRes
             * @static
             * @param {pb.IRaceGetFreeTicketRes} message RaceGetFreeTicketRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceGetFreeTicketRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.leftFreeTicket != null && Object.hasOwnProperty.call(message, "leftFreeTicket"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.leftFreeTicket);
                if (message.ticketRefreshTime != null && Object.hasOwnProperty.call(message, "ticketRefreshTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.ticketRefreshTime);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RaceGetFreeTicketRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceGetFreeTicketRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceGetFreeTicketRes} RaceGetFreeTicketRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceGetFreeTicketRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceGetFreeTicketRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.leftFreeTicket = reader.int32();
                        break;
                    case 2:
                        message.ticketRefreshTime = reader.int64();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceGetFreeTicketRes;
        })();
    
        pb.RaceShareRebornReq = (function() {
    
            /**
             * Properties of a RaceShareRebornReq.
             * @memberof pb
             * @interface IRaceShareRebornReq
             * @property {string|null} [shareId] RaceShareRebornReq shareId
             */
    
            /**
             * Constructs a new RaceShareRebornReq.
             * @memberof pb
             * @classdesc Represents a RaceShareRebornReq.
             * @implements IRaceShareRebornReq
             * @constructor
             * @param {pb.IRaceShareRebornReq=} [properties] Properties to set
             */
            function RaceShareRebornReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceShareRebornReq shareId.
             * @member {string} shareId
             * @memberof pb.RaceShareRebornReq
             * @instance
             */
            RaceShareRebornReq.prototype.shareId = "";
    
            /**
             * Creates a new RaceShareRebornReq instance using the specified properties.
             * @function create
             * @memberof pb.RaceShareRebornReq
             * @static
             * @param {pb.IRaceShareRebornReq=} [properties] Properties to set
             * @returns {pb.RaceShareRebornReq} RaceShareRebornReq instance
             */
            RaceShareRebornReq.create = function create(properties) {
                return new RaceShareRebornReq(properties);
            };
    
            /**
             * Encodes the specified RaceShareRebornReq message. Does not implicitly {@link pb.RaceShareRebornReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceShareRebornReq
             * @static
             * @param {pb.IRaceShareRebornReq} message RaceShareRebornReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceShareRebornReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.shareId != null && Object.hasOwnProperty.call(message, "shareId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.shareId);
                return writer;
            };
    
            /**
             * Decodes a RaceShareRebornReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceShareRebornReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceShareRebornReq} RaceShareRebornReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceShareRebornReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceShareRebornReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.shareId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceShareRebornReq;
        })();
    
        pb.RaceShareRebornRes = (function() {
    
            /**
             * Properties of a RaceShareRebornRes.
             * @memberof pb
             * @interface IRaceShareRebornRes
             * @property {string|null} [shareId] RaceShareRebornRes shareId
             * @property {number|null} [code] RaceShareRebornRes code
             */
    
            /**
             * Constructs a new RaceShareRebornRes.
             * @memberof pb
             * @classdesc Represents a RaceShareRebornRes.
             * @implements IRaceShareRebornRes
             * @constructor
             * @param {pb.IRaceShareRebornRes=} [properties] Properties to set
             */
            function RaceShareRebornRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceShareRebornRes shareId.
             * @member {string} shareId
             * @memberof pb.RaceShareRebornRes
             * @instance
             */
            RaceShareRebornRes.prototype.shareId = "";
    
            /**
             * RaceShareRebornRes code.
             * @member {number} code
             * @memberof pb.RaceShareRebornRes
             * @instance
             */
            RaceShareRebornRes.prototype.code = 0;
    
            /**
             * Creates a new RaceShareRebornRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceShareRebornRes
             * @static
             * @param {pb.IRaceShareRebornRes=} [properties] Properties to set
             * @returns {pb.RaceShareRebornRes} RaceShareRebornRes instance
             */
            RaceShareRebornRes.create = function create(properties) {
                return new RaceShareRebornRes(properties);
            };
    
            /**
             * Encodes the specified RaceShareRebornRes message. Does not implicitly {@link pb.RaceShareRebornRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceShareRebornRes
             * @static
             * @param {pb.IRaceShareRebornRes} message RaceShareRebornRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceShareRebornRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.shareId != null && Object.hasOwnProperty.call(message, "shareId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.shareId);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RaceShareRebornRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceShareRebornRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceShareRebornRes} RaceShareRebornRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceShareRebornRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceShareRebornRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.shareId = reader.string();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceShareRebornRes;
        })();
    
        pb.RaceBuyTicketReq = (function() {
    
            /**
             * Properties of a RaceBuyTicketReq.
             * @memberof pb
             * @interface IRaceBuyTicketReq
             * @property {number|null} [num] RaceBuyTicketReq num
             */
    
            /**
             * Constructs a new RaceBuyTicketReq.
             * @memberof pb
             * @classdesc Represents a RaceBuyTicketReq.
             * @implements IRaceBuyTicketReq
             * @constructor
             * @param {pb.IRaceBuyTicketReq=} [properties] Properties to set
             */
            function RaceBuyTicketReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceBuyTicketReq num.
             * @member {number} num
             * @memberof pb.RaceBuyTicketReq
             * @instance
             */
            RaceBuyTicketReq.prototype.num = 0;
    
            /**
             * Creates a new RaceBuyTicketReq instance using the specified properties.
             * @function create
             * @memberof pb.RaceBuyTicketReq
             * @static
             * @param {pb.IRaceBuyTicketReq=} [properties] Properties to set
             * @returns {pb.RaceBuyTicketReq} RaceBuyTicketReq instance
             */
            RaceBuyTicketReq.create = function create(properties) {
                return new RaceBuyTicketReq(properties);
            };
    
            /**
             * Encodes the specified RaceBuyTicketReq message. Does not implicitly {@link pb.RaceBuyTicketReq.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceBuyTicketReq
             * @static
             * @param {pb.IRaceBuyTicketReq} message RaceBuyTicketReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceBuyTicketReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                return writer;
            };
    
            /**
             * Decodes a RaceBuyTicketReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceBuyTicketReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceBuyTicketReq} RaceBuyTicketReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceBuyTicketReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceBuyTicketReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceBuyTicketReq;
        })();
    
        pb.RaceBuyTicketRes = (function() {
    
            /**
             * Properties of a RaceBuyTicketRes.
             * @memberof pb
             * @interface IRaceBuyTicketRes
             * @property {number|null} [num] RaceBuyTicketRes num
             * @property {number|null} [ticketNum] RaceBuyTicketRes ticketNum
             * @property {number|null} [code] RaceBuyTicketRes code
             */
    
            /**
             * Constructs a new RaceBuyTicketRes.
             * @memberof pb
             * @classdesc Represents a RaceBuyTicketRes.
             * @implements IRaceBuyTicketRes
             * @constructor
             * @param {pb.IRaceBuyTicketRes=} [properties] Properties to set
             */
            function RaceBuyTicketRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * RaceBuyTicketRes num.
             * @member {number} num
             * @memberof pb.RaceBuyTicketRes
             * @instance
             */
            RaceBuyTicketRes.prototype.num = 0;
    
            /**
             * RaceBuyTicketRes ticketNum.
             * @member {number} ticketNum
             * @memberof pb.RaceBuyTicketRes
             * @instance
             */
            RaceBuyTicketRes.prototype.ticketNum = 0;
    
            /**
             * RaceBuyTicketRes code.
             * @member {number} code
             * @memberof pb.RaceBuyTicketRes
             * @instance
             */
            RaceBuyTicketRes.prototype.code = 0;
    
            /**
             * Creates a new RaceBuyTicketRes instance using the specified properties.
             * @function create
             * @memberof pb.RaceBuyTicketRes
             * @static
             * @param {pb.IRaceBuyTicketRes=} [properties] Properties to set
             * @returns {pb.RaceBuyTicketRes} RaceBuyTicketRes instance
             */
            RaceBuyTicketRes.create = function create(properties) {
                return new RaceBuyTicketRes(properties);
            };
    
            /**
             * Encodes the specified RaceBuyTicketRes message. Does not implicitly {@link pb.RaceBuyTicketRes.verify|verify} messages.
             * @function encode
             * @memberof pb.RaceBuyTicketRes
             * @static
             * @param {pb.IRaceBuyTicketRes} message RaceBuyTicketRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RaceBuyTicketRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                if (message.ticketNum != null && Object.hasOwnProperty.call(message, "ticketNum"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ticketNum);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a RaceBuyTicketRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.RaceBuyTicketRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.RaceBuyTicketRes} RaceBuyTicketRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RaceBuyTicketRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RaceBuyTicketRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.ticketNum = reader.int32();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return RaceBuyTicketRes;
        })();
    
        pb.AiGetListReq = (function() {
    
            /**
             * Properties of an AiGetListReq.
             * @memberof pb
             * @interface IAiGetListReq
             */
    
            /**
             * Constructs a new AiGetListReq.
             * @memberof pb
             * @classdesc Represents an AiGetListReq.
             * @implements IAiGetListReq
             * @constructor
             * @param {pb.IAiGetListReq=} [properties] Properties to set
             */
            function AiGetListReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new AiGetListReq instance using the specified properties.
             * @function create
             * @memberof pb.AiGetListReq
             * @static
             * @param {pb.IAiGetListReq=} [properties] Properties to set
             * @returns {pb.AiGetListReq} AiGetListReq instance
             */
            AiGetListReq.create = function create(properties) {
                return new AiGetListReq(properties);
            };
    
            /**
             * Encodes the specified AiGetListReq message. Does not implicitly {@link pb.AiGetListReq.verify|verify} messages.
             * @function encode
             * @memberof pb.AiGetListReq
             * @static
             * @param {pb.IAiGetListReq} message AiGetListReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AiGetListReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes an AiGetListReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AiGetListReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AiGetListReq} AiGetListReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AiGetListReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AiGetListReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AiGetListReq;
        })();
    
        pb.AiGetListRes = (function() {
    
            /**
             * Properties of an AiGetListRes.
             * @memberof pb
             * @interface IAiGetListRes
             * @property {number|null} [max] AiGetListRes max
             * @property {number|null} [min] AiGetListRes min
             */
    
            /**
             * Constructs a new AiGetListRes.
             * @memberof pb
             * @classdesc Represents an AiGetListRes.
             * @implements IAiGetListRes
             * @constructor
             * @param {pb.IAiGetListRes=} [properties] Properties to set
             */
            function AiGetListRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * AiGetListRes max.
             * @member {number} max
             * @memberof pb.AiGetListRes
             * @instance
             */
            AiGetListRes.prototype.max = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * AiGetListRes min.
             * @member {number} min
             * @memberof pb.AiGetListRes
             * @instance
             */
            AiGetListRes.prototype.min = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new AiGetListRes instance using the specified properties.
             * @function create
             * @memberof pb.AiGetListRes
             * @static
             * @param {pb.IAiGetListRes=} [properties] Properties to set
             * @returns {pb.AiGetListRes} AiGetListRes instance
             */
            AiGetListRes.create = function create(properties) {
                return new AiGetListRes(properties);
            };
    
            /**
             * Encodes the specified AiGetListRes message. Does not implicitly {@link pb.AiGetListRes.verify|verify} messages.
             * @function encode
             * @memberof pb.AiGetListRes
             * @static
             * @param {pb.IAiGetListRes} message AiGetListRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AiGetListRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.max != null && Object.hasOwnProperty.call(message, "max"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.max);
                if (message.min != null && Object.hasOwnProperty.call(message, "min"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.min);
                return writer;
            };
    
            /**
             * Decodes an AiGetListRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.AiGetListRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.AiGetListRes} AiGetListRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AiGetListRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AiGetListRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.max = reader.int64();
                        break;
                    case 2:
                        message.min = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return AiGetListRes;
        })();
    
        pb.GetGlobalExchangeReq = (function() {
    
            /**
             * Properties of a GetGlobalExchangeReq.
             * @memberof pb
             * @interface IGetGlobalExchangeReq
             * @property {number|null} [limit] GetGlobalExchangeReq limit
             * @property {number|null} [offset] GetGlobalExchangeReq offset
             * @property {boolean|null} [is_ludo_challenge_open] GetGlobalExchangeReq is_ludo_challenge_open
             * @property {string|null} [x_lang] GetGlobalExchangeReq x_lang
             */
    
            /**
             * Constructs a new GetGlobalExchangeReq.
             * @memberof pb
             * @classdesc Represents a GetGlobalExchangeReq.
             * @implements IGetGlobalExchangeReq
             * @constructor
             * @param {pb.IGetGlobalExchangeReq=} [properties] Properties to set
             */
            function GetGlobalExchangeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetGlobalExchangeReq limit.
             * @member {number} limit
             * @memberof pb.GetGlobalExchangeReq
             * @instance
             */
            GetGlobalExchangeReq.prototype.limit = 0;
    
            /**
             * GetGlobalExchangeReq offset.
             * @member {number} offset
             * @memberof pb.GetGlobalExchangeReq
             * @instance
             */
            GetGlobalExchangeReq.prototype.offset = 0;
    
            /**
             * GetGlobalExchangeReq is_ludo_challenge_open.
             * @member {boolean} is_ludo_challenge_open
             * @memberof pb.GetGlobalExchangeReq
             * @instance
             */
            GetGlobalExchangeReq.prototype.is_ludo_challenge_open = false;
    
            /**
             * GetGlobalExchangeReq x_lang.
             * @member {string} x_lang
             * @memberof pb.GetGlobalExchangeReq
             * @instance
             */
            GetGlobalExchangeReq.prototype.x_lang = "";
    
            /**
             * Creates a new GetGlobalExchangeReq instance using the specified properties.
             * @function create
             * @memberof pb.GetGlobalExchangeReq
             * @static
             * @param {pb.IGetGlobalExchangeReq=} [properties] Properties to set
             * @returns {pb.GetGlobalExchangeReq} GetGlobalExchangeReq instance
             */
            GetGlobalExchangeReq.create = function create(properties) {
                return new GetGlobalExchangeReq(properties);
            };
    
            /**
             * Encodes the specified GetGlobalExchangeReq message. Does not implicitly {@link pb.GetGlobalExchangeReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GetGlobalExchangeReq
             * @static
             * @param {pb.IGetGlobalExchangeReq} message GetGlobalExchangeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGlobalExchangeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.limit);
                if (message.offset != null && Object.hasOwnProperty.call(message, "offset"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.offset);
                if (message.is_ludo_challenge_open != null && Object.hasOwnProperty.call(message, "is_ludo_challenge_open"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.is_ludo_challenge_open);
                if (message.x_lang != null && Object.hasOwnProperty.call(message, "x_lang"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.x_lang);
                return writer;
            };
    
            /**
             * Decodes a GetGlobalExchangeReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetGlobalExchangeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetGlobalExchangeReq} GetGlobalExchangeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGlobalExchangeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetGlobalExchangeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.limit = reader.int32();
                        break;
                    case 2:
                        message.offset = reader.int32();
                        break;
                    case 3:
                        message.is_ludo_challenge_open = reader.bool();
                        break;
                    case 4:
                        message.x_lang = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetGlobalExchangeReq;
        })();
    
        pb.GetGlobalExchangeRes = (function() {
    
            /**
             * Properties of a GetGlobalExchangeRes.
             * @memberof pb
             * @interface IGetGlobalExchangeRes
             * @property {number|null} [resCode] GetGlobalExchangeRes resCode
             * @property {string|null} [reMsg] GetGlobalExchangeRes reMsg
             * @property {Array.<pb.IExchangeLogPB>|null} [exchangeLogPB] GetGlobalExchangeRes exchangeLogPB
             */
    
            /**
             * Constructs a new GetGlobalExchangeRes.
             * @memberof pb
             * @classdesc Represents a GetGlobalExchangeRes.
             * @implements IGetGlobalExchangeRes
             * @constructor
             * @param {pb.IGetGlobalExchangeRes=} [properties] Properties to set
             */
            function GetGlobalExchangeRes(properties) {
                this.exchangeLogPB = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetGlobalExchangeRes resCode.
             * @member {number} resCode
             * @memberof pb.GetGlobalExchangeRes
             * @instance
             */
            GetGlobalExchangeRes.prototype.resCode = 0;
    
            /**
             * GetGlobalExchangeRes reMsg.
             * @member {string} reMsg
             * @memberof pb.GetGlobalExchangeRes
             * @instance
             */
            GetGlobalExchangeRes.prototype.reMsg = "";
    
            /**
             * GetGlobalExchangeRes exchangeLogPB.
             * @member {Array.<pb.IExchangeLogPB>} exchangeLogPB
             * @memberof pb.GetGlobalExchangeRes
             * @instance
             */
            GetGlobalExchangeRes.prototype.exchangeLogPB = $util.emptyArray;
    
            /**
             * Creates a new GetGlobalExchangeRes instance using the specified properties.
             * @function create
             * @memberof pb.GetGlobalExchangeRes
             * @static
             * @param {pb.IGetGlobalExchangeRes=} [properties] Properties to set
             * @returns {pb.GetGlobalExchangeRes} GetGlobalExchangeRes instance
             */
            GetGlobalExchangeRes.create = function create(properties) {
                return new GetGlobalExchangeRes(properties);
            };
    
            /**
             * Encodes the specified GetGlobalExchangeRes message. Does not implicitly {@link pb.GetGlobalExchangeRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GetGlobalExchangeRes
             * @static
             * @param {pb.IGetGlobalExchangeRes} message GetGlobalExchangeRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGlobalExchangeRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resCode != null && Object.hasOwnProperty.call(message, "resCode"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.resCode);
                if (message.reMsg != null && Object.hasOwnProperty.call(message, "reMsg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.reMsg);
                if (message.exchangeLogPB != null && message.exchangeLogPB.length)
                    for (var i = 0; i < message.exchangeLogPB.length; ++i)
                        $root.pb.ExchangeLogPB.encode(message.exchangeLogPB[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GetGlobalExchangeRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetGlobalExchangeRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetGlobalExchangeRes} GetGlobalExchangeRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGlobalExchangeRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetGlobalExchangeRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.resCode = reader.int32();
                        break;
                    case 2:
                        message.reMsg = reader.string();
                        break;
                    case 3:
                        if (!(message.exchangeLogPB && message.exchangeLogPB.length))
                            message.exchangeLogPB = [];
                        message.exchangeLogPB.push($root.pb.ExchangeLogPB.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetGlobalExchangeRes;
        })();
    
        pb.ExchangeLogPB = (function() {
    
            /**
             * Properties of an ExchangeLogPB.
             * @memberof pb
             * @interface IExchangeLogPB
             * @property {string|null} [nick] ExchangeLogPB nick
             * @property {string|null} [head_url] ExchangeLogPB head_url
             * @property {number|null} [cnt] ExchangeLogPB cnt
             * @property {number|null} [item_id] ExchangeLogPB item_id
             * @property {number|null} [type] ExchangeLogPB type
             * @property {string|null} [name] ExchangeLogPB name
             * @property {number|null} [mall_type] ExchangeLogPB mall_type
             * @property {string|null} [txt] ExchangeLogPB txt
             */
    
            /**
             * Constructs a new ExchangeLogPB.
             * @memberof pb
             * @classdesc Represents an ExchangeLogPB.
             * @implements IExchangeLogPB
             * @constructor
             * @param {pb.IExchangeLogPB=} [properties] Properties to set
             */
            function ExchangeLogPB(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * ExchangeLogPB nick.
             * @member {string} nick
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.nick = "";
    
            /**
             * ExchangeLogPB head_url.
             * @member {string} head_url
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.head_url = "";
    
            /**
             * ExchangeLogPB cnt.
             * @member {number} cnt
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.cnt = 0;
    
            /**
             * ExchangeLogPB item_id.
             * @member {number} item_id
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.item_id = 0;
    
            /**
             * ExchangeLogPB type.
             * @member {number} type
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.type = 0;
    
            /**
             * ExchangeLogPB name.
             * @member {string} name
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.name = "";
    
            /**
             * ExchangeLogPB mall_type.
             * @member {number} mall_type
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.mall_type = 0;
    
            /**
             * ExchangeLogPB txt.
             * @member {string} txt
             * @memberof pb.ExchangeLogPB
             * @instance
             */
            ExchangeLogPB.prototype.txt = "";
    
            /**
             * Creates a new ExchangeLogPB instance using the specified properties.
             * @function create
             * @memberof pb.ExchangeLogPB
             * @static
             * @param {pb.IExchangeLogPB=} [properties] Properties to set
             * @returns {pb.ExchangeLogPB} ExchangeLogPB instance
             */
            ExchangeLogPB.create = function create(properties) {
                return new ExchangeLogPB(properties);
            };
    
            /**
             * Encodes the specified ExchangeLogPB message. Does not implicitly {@link pb.ExchangeLogPB.verify|verify} messages.
             * @function encode
             * @memberof pb.ExchangeLogPB
             * @static
             * @param {pb.IExchangeLogPB} message ExchangeLogPB message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExchangeLogPB.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nick);
                if (message.head_url != null && Object.hasOwnProperty.call(message, "head_url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.head_url);
                if (message.cnt != null && Object.hasOwnProperty.call(message, "cnt"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.cnt);
                if (message.item_id != null && Object.hasOwnProperty.call(message, "item_id"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.item_id);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.name);
                if (message.mall_type != null && Object.hasOwnProperty.call(message, "mall_type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.mall_type);
                if (message.txt != null && Object.hasOwnProperty.call(message, "txt"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.txt);
                return writer;
            };
    
            /**
             * Decodes an ExchangeLogPB message from the specified reader or buffer.
             * @function decode
             * @memberof pb.ExchangeLogPB
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.ExchangeLogPB} ExchangeLogPB
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExchangeLogPB.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ExchangeLogPB();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.nick = reader.string();
                        break;
                    case 2:
                        message.head_url = reader.string();
                        break;
                    case 3:
                        message.cnt = reader.int32();
                        break;
                    case 4:
                        message.item_id = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.name = reader.string();
                        break;
                    case 7:
                        message.mall_type = reader.int32();
                        break;
                    case 8:
                        message.txt = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return ExchangeLogPB;
        })();
    
        pb.TaskBoxReq = (function() {
    
            /**
             * Properties of a TaskBoxReq.
             * @memberof pb
             * @interface ITaskBoxReq
             */
    
            /**
             * Constructs a new TaskBoxReq.
             * @memberof pb
             * @classdesc Represents a TaskBoxReq.
             * @implements ITaskBoxReq
             * @constructor
             * @param {pb.ITaskBoxReq=} [properties] Properties to set
             */
            function TaskBoxReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new TaskBoxReq instance using the specified properties.
             * @function create
             * @memberof pb.TaskBoxReq
             * @static
             * @param {pb.ITaskBoxReq=} [properties] Properties to set
             * @returns {pb.TaskBoxReq} TaskBoxReq instance
             */
            TaskBoxReq.create = function create(properties) {
                return new TaskBoxReq(properties);
            };
    
            /**
             * Encodes the specified TaskBoxReq message. Does not implicitly {@link pb.TaskBoxReq.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskBoxReq
             * @static
             * @param {pb.ITaskBoxReq} message TaskBoxReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskBoxReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a TaskBoxReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskBoxReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskBoxReq} TaskBoxReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskBoxReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskBoxReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskBoxReq;
        })();
    
        pb.TaskBoxRes = (function() {
    
            /**
             * Properties of a TaskBoxRes.
             * @memberof pb
             * @interface ITaskBoxRes
             * @property {number|null} [curPoint] TaskBoxRes curPoint
             * @property {Array.<number>|null} [recBoxes] TaskBoxRes recBoxes
             * @property {Array.<pb.ITaskBox>|null} [boxes] TaskBoxRes boxes
             */
    
            /**
             * Constructs a new TaskBoxRes.
             * @memberof pb
             * @classdesc Represents a TaskBoxRes.
             * @implements ITaskBoxRes
             * @constructor
             * @param {pb.ITaskBoxRes=} [properties] Properties to set
             */
            function TaskBoxRes(properties) {
                this.recBoxes = [];
                this.boxes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskBoxRes curPoint.
             * @member {number} curPoint
             * @memberof pb.TaskBoxRes
             * @instance
             */
            TaskBoxRes.prototype.curPoint = 0;
    
            /**
             * TaskBoxRes recBoxes.
             * @member {Array.<number>} recBoxes
             * @memberof pb.TaskBoxRes
             * @instance
             */
            TaskBoxRes.prototype.recBoxes = $util.emptyArray;
    
            /**
             * TaskBoxRes boxes.
             * @member {Array.<pb.ITaskBox>} boxes
             * @memberof pb.TaskBoxRes
             * @instance
             */
            TaskBoxRes.prototype.boxes = $util.emptyArray;
    
            /**
             * Creates a new TaskBoxRes instance using the specified properties.
             * @function create
             * @memberof pb.TaskBoxRes
             * @static
             * @param {pb.ITaskBoxRes=} [properties] Properties to set
             * @returns {pb.TaskBoxRes} TaskBoxRes instance
             */
            TaskBoxRes.create = function create(properties) {
                return new TaskBoxRes(properties);
            };
    
            /**
             * Encodes the specified TaskBoxRes message. Does not implicitly {@link pb.TaskBoxRes.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskBoxRes
             * @static
             * @param {pb.ITaskBoxRes} message TaskBoxRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskBoxRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.curPoint != null && Object.hasOwnProperty.call(message, "curPoint"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.curPoint);
                if (message.recBoxes != null && message.recBoxes.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (var i = 0; i < message.recBoxes.length; ++i)
                        writer.int32(message.recBoxes[i]);
                    writer.ldelim();
                }
                if (message.boxes != null && message.boxes.length)
                    for (var i = 0; i < message.boxes.length; ++i)
                        $root.pb.TaskBox.encode(message.boxes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a TaskBoxRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskBoxRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskBoxRes} TaskBoxRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskBoxRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskBoxRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.curPoint = reader.int32();
                        break;
                    case 2:
                        if (!(message.recBoxes && message.recBoxes.length))
                            message.recBoxes = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.recBoxes.push(reader.int32());
                        } else
                            message.recBoxes.push(reader.int32());
                        break;
                    case 3:
                        if (!(message.boxes && message.boxes.length))
                            message.boxes = [];
                        message.boxes.push($root.pb.TaskBox.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskBoxRes;
        })();
    
        pb.TaskBox = (function() {
    
            /**
             * Properties of a TaskBox.
             * @memberof pb
             * @interface ITaskBox
             * @property {number|null} [box] TaskBox box
             * @property {Array.<pb.IRewardItem>|null} [item] TaskBox item
             * @property {number|null} [point] TaskBox point
             */
    
            /**
             * Constructs a new TaskBox.
             * @memberof pb
             * @classdesc Represents a TaskBox.
             * @implements ITaskBox
             * @constructor
             * @param {pb.ITaskBox=} [properties] Properties to set
             */
            function TaskBox(properties) {
                this.item = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskBox box.
             * @member {number} box
             * @memberof pb.TaskBox
             * @instance
             */
            TaskBox.prototype.box = 0;
    
            /**
             * TaskBox item.
             * @member {Array.<pb.IRewardItem>} item
             * @memberof pb.TaskBox
             * @instance
             */
            TaskBox.prototype.item = $util.emptyArray;
    
            /**
             * TaskBox point.
             * @member {number} point
             * @memberof pb.TaskBox
             * @instance
             */
            TaskBox.prototype.point = 0;
    
            /**
             * Creates a new TaskBox instance using the specified properties.
             * @function create
             * @memberof pb.TaskBox
             * @static
             * @param {pb.ITaskBox=} [properties] Properties to set
             * @returns {pb.TaskBox} TaskBox instance
             */
            TaskBox.create = function create(properties) {
                return new TaskBox(properties);
            };
    
            /**
             * Encodes the specified TaskBox message. Does not implicitly {@link pb.TaskBox.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskBox
             * @static
             * @param {pb.ITaskBox} message TaskBox message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskBox.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.box != null && Object.hasOwnProperty.call(message, "box"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.box);
                if (message.item != null && message.item.length)
                    for (var i = 0; i < message.item.length; ++i)
                        $root.pb.RewardItem.encode(message.item[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.point);
                return writer;
            };
    
            /**
             * Decodes a TaskBox message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskBox
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskBox} TaskBox
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskBox.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskBox();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.box = reader.int32();
                        break;
                    case 2:
                        if (!(message.item && message.item.length))
                            message.item = [];
                        message.item.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.point = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskBox;
        })();
    
        pb.TaskBoxReceiveReq = (function() {
    
            /**
             * Properties of a TaskBoxReceiveReq.
             * @memberof pb
             * @interface ITaskBoxReceiveReq
             * @property {number|null} [box] TaskBoxReceiveReq box
             */
    
            /**
             * Constructs a new TaskBoxReceiveReq.
             * @memberof pb
             * @classdesc Represents a TaskBoxReceiveReq.
             * @implements ITaskBoxReceiveReq
             * @constructor
             * @param {pb.ITaskBoxReceiveReq=} [properties] Properties to set
             */
            function TaskBoxReceiveReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskBoxReceiveReq box.
             * @member {number} box
             * @memberof pb.TaskBoxReceiveReq
             * @instance
             */
            TaskBoxReceiveReq.prototype.box = 0;
    
            /**
             * Creates a new TaskBoxReceiveReq instance using the specified properties.
             * @function create
             * @memberof pb.TaskBoxReceiveReq
             * @static
             * @param {pb.ITaskBoxReceiveReq=} [properties] Properties to set
             * @returns {pb.TaskBoxReceiveReq} TaskBoxReceiveReq instance
             */
            TaskBoxReceiveReq.create = function create(properties) {
                return new TaskBoxReceiveReq(properties);
            };
    
            /**
             * Encodes the specified TaskBoxReceiveReq message. Does not implicitly {@link pb.TaskBoxReceiveReq.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskBoxReceiveReq
             * @static
             * @param {pb.ITaskBoxReceiveReq} message TaskBoxReceiveReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskBoxReceiveReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.box != null && Object.hasOwnProperty.call(message, "box"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.box);
                return writer;
            };
    
            /**
             * Decodes a TaskBoxReceiveReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskBoxReceiveReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskBoxReceiveReq} TaskBoxReceiveReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskBoxReceiveReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskBoxReceiveReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.box = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskBoxReceiveReq;
        })();
    
        pb.TaskBoxReceiveRes = (function() {
    
            /**
             * Properties of a TaskBoxReceiveRes.
             * @memberof pb
             * @interface ITaskBoxReceiveRes
             * @property {number|null} [box] TaskBoxReceiveRes box
             * @property {Array.<pb.IRewardItem>|null} [item] TaskBoxReceiveRes item
             * @property {number|null} [code] TaskBoxReceiveRes code
             */
    
            /**
             * Constructs a new TaskBoxReceiveRes.
             * @memberof pb
             * @classdesc Represents a TaskBoxReceiveRes.
             * @implements ITaskBoxReceiveRes
             * @constructor
             * @param {pb.ITaskBoxReceiveRes=} [properties] Properties to set
             */
            function TaskBoxReceiveRes(properties) {
                this.item = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * TaskBoxReceiveRes box.
             * @member {number} box
             * @memberof pb.TaskBoxReceiveRes
             * @instance
             */
            TaskBoxReceiveRes.prototype.box = 0;
    
            /**
             * TaskBoxReceiveRes item.
             * @member {Array.<pb.IRewardItem>} item
             * @memberof pb.TaskBoxReceiveRes
             * @instance
             */
            TaskBoxReceiveRes.prototype.item = $util.emptyArray;
    
            /**
             * TaskBoxReceiveRes code.
             * @member {number} code
             * @memberof pb.TaskBoxReceiveRes
             * @instance
             */
            TaskBoxReceiveRes.prototype.code = 0;
    
            /**
             * Creates a new TaskBoxReceiveRes instance using the specified properties.
             * @function create
             * @memberof pb.TaskBoxReceiveRes
             * @static
             * @param {pb.ITaskBoxReceiveRes=} [properties] Properties to set
             * @returns {pb.TaskBoxReceiveRes} TaskBoxReceiveRes instance
             */
            TaskBoxReceiveRes.create = function create(properties) {
                return new TaskBoxReceiveRes(properties);
            };
    
            /**
             * Encodes the specified TaskBoxReceiveRes message. Does not implicitly {@link pb.TaskBoxReceiveRes.verify|verify} messages.
             * @function encode
             * @memberof pb.TaskBoxReceiveRes
             * @static
             * @param {pb.ITaskBoxReceiveRes} message TaskBoxReceiveRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TaskBoxReceiveRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.box != null && Object.hasOwnProperty.call(message, "box"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.box);
                if (message.item != null && message.item.length)
                    for (var i = 0; i < message.item.length; ++i)
                        $root.pb.RewardItem.encode(message.item[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a TaskBoxReceiveRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.TaskBoxReceiveRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.TaskBoxReceiveRes} TaskBoxReceiveRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TaskBoxReceiveRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TaskBoxReceiveRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.box = reader.int32();
                        break;
                    case 2:
                        if (!(message.item && message.item.length))
                            message.item = [];
                        message.item.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return TaskBoxReceiveRes;
        })();
    
        pb.SevenDayConfig = (function() {
    
            /**
             * Properties of a SevenDayConfig.
             * @memberof pb
             * @interface ISevenDayConfig
             * @property {number|null} [id] SevenDayConfig id
             * @property {pb.INewReward|null} [reward] SevenDayConfig reward
             */
    
            /**
             * Constructs a new SevenDayConfig.
             * @memberof pb
             * @classdesc Represents a SevenDayConfig.
             * @implements ISevenDayConfig
             * @constructor
             * @param {pb.ISevenDayConfig=} [properties] Properties to set
             */
            function SevenDayConfig(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SevenDayConfig id.
             * @member {number} id
             * @memberof pb.SevenDayConfig
             * @instance
             */
            SevenDayConfig.prototype.id = 0;
    
            /**
             * SevenDayConfig reward.
             * @member {pb.INewReward|null|undefined} reward
             * @memberof pb.SevenDayConfig
             * @instance
             */
            SevenDayConfig.prototype.reward = null;
    
            /**
             * Creates a new SevenDayConfig instance using the specified properties.
             * @function create
             * @memberof pb.SevenDayConfig
             * @static
             * @param {pb.ISevenDayConfig=} [properties] Properties to set
             * @returns {pb.SevenDayConfig} SevenDayConfig instance
             */
            SevenDayConfig.create = function create(properties) {
                return new SevenDayConfig(properties);
            };
    
            /**
             * Encodes the specified SevenDayConfig message. Does not implicitly {@link pb.SevenDayConfig.verify|verify} messages.
             * @function encode
             * @memberof pb.SevenDayConfig
             * @static
             * @param {pb.ISevenDayConfig} message SevenDayConfig message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SevenDayConfig.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                    $root.pb.NewReward.encode(message.reward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a SevenDayConfig message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SevenDayConfig
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SevenDayConfig} SevenDayConfig
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SevenDayConfig.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SevenDayConfig();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.reward = $root.pb.NewReward.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SevenDayConfig;
        })();
    
        pb.NewReward = (function() {
    
            /**
             * Properties of a NewReward.
             * @memberof pb
             * @interface INewReward
             * @property {number|null} [itemId] NewReward itemId
             * @property {number|null} [type] 0 
             * 1 
             * @property {number|null} [itemType] int ITEM_TYPE_COIN = 0; //
             * int ITEM_TYPE_CRYSTAL = 1;//
             * int ITEM_TYPE_HAGO_COIN = 2;//hago
             * int ITEM_TYPE_DIAMOND = 3;//
             * int ITEM_TYPE_GHOST_TICKET = 4;//
             * 
             * int SKIN_TYPE_RICE = 1; // 
             * int SKIN_TYPE_CHESS = 0; // 
             * int SKIN_TYPE_HUAWEN = 2; // 
             * @property {number|null} [itemNum] NewReward itemNum
             */
    
            /**
             * Constructs a new NewReward.
             * @memberof pb
             * @classdesc Represents a NewReward.
             * @implements INewReward
             * @constructor
             * @param {pb.INewReward=} [properties] Properties to set
             */
            function NewReward(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * NewReward itemId.
             * @member {number} itemId
             * @memberof pb.NewReward
             * @instance
             */
            NewReward.prototype.itemId = 0;
    
            /**
             * 0 
             * 1 
             * @member {number} type
             * @memberof pb.NewReward
             * @instance
             */
            NewReward.prototype.type = 0;
    
            /**
             * int ITEM_TYPE_COIN = 0; //
             * int ITEM_TYPE_CRYSTAL = 1;//
             * int ITEM_TYPE_HAGO_COIN = 2;//hago
             * int ITEM_TYPE_DIAMOND = 3;//
             * int ITEM_TYPE_GHOST_TICKET = 4;//
             * 
             * int SKIN_TYPE_RICE = 1; // 
             * int SKIN_TYPE_CHESS = 0; // 
             * int SKIN_TYPE_HUAWEN = 2; // 
             * @member {number} itemType
             * @memberof pb.NewReward
             * @instance
             */
            NewReward.prototype.itemType = 0;
    
            /**
             * NewReward itemNum.
             * @member {number} itemNum
             * @memberof pb.NewReward
             * @instance
             */
            NewReward.prototype.itemNum = 0;
    
            /**
             * Creates a new NewReward instance using the specified properties.
             * @function create
             * @memberof pb.NewReward
             * @static
             * @param {pb.INewReward=} [properties] Properties to set
             * @returns {pb.NewReward} NewReward instance
             */
            NewReward.create = function create(properties) {
                return new NewReward(properties);
            };
    
            /**
             * Encodes the specified NewReward message. Does not implicitly {@link pb.NewReward.verify|verify} messages.
             * @function encode
             * @memberof pb.NewReward
             * @static
             * @param {pb.INewReward} message NewReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NewReward.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.itemId != null && Object.hasOwnProperty.call(message, "itemId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.itemId);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                if (message.itemType != null && Object.hasOwnProperty.call(message, "itemType"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.itemType);
                if (message.itemNum != null && Object.hasOwnProperty.call(message, "itemNum"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.itemNum);
                return writer;
            };
    
            /**
             * Decodes a NewReward message from the specified reader or buffer.
             * @function decode
             * @memberof pb.NewReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.NewReward} NewReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NewReward.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.NewReward();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.itemId = reader.int32();
                        break;
                    case 2:
                        message.type = reader.int32();
                        break;
                    case 3:
                        message.itemType = reader.int32();
                        break;
                    case 4:
                        message.itemNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return NewReward;
        })();
    
        pb.SevenDayInfo = (function() {
    
            /**
             * Properties of a SevenDayInfo.
             * @memberof pb
             * @interface ISevenDayInfo
             * @property {pb.ISevenDayConfig|null} [sevenDayInfo] SevenDayInfo sevenDayInfo
             * @property {boolean|null} [reward] SevenDayInfo reward
             */
    
            /**
             * Constructs a new SevenDayInfo.
             * @memberof pb
             * @classdesc Represents a SevenDayInfo.
             * @implements ISevenDayInfo
             * @constructor
             * @param {pb.ISevenDayInfo=} [properties] Properties to set
             */
            function SevenDayInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SevenDayInfo sevenDayInfo.
             * @member {pb.ISevenDayConfig|null|undefined} sevenDayInfo
             * @memberof pb.SevenDayInfo
             * @instance
             */
            SevenDayInfo.prototype.sevenDayInfo = null;
    
            /**
             * SevenDayInfo reward.
             * @member {boolean} reward
             * @memberof pb.SevenDayInfo
             * @instance
             */
            SevenDayInfo.prototype.reward = false;
    
            /**
             * Creates a new SevenDayInfo instance using the specified properties.
             * @function create
             * @memberof pb.SevenDayInfo
             * @static
             * @param {pb.ISevenDayInfo=} [properties] Properties to set
             * @returns {pb.SevenDayInfo} SevenDayInfo instance
             */
            SevenDayInfo.create = function create(properties) {
                return new SevenDayInfo(properties);
            };
    
            /**
             * Encodes the specified SevenDayInfo message. Does not implicitly {@link pb.SevenDayInfo.verify|verify} messages.
             * @function encode
             * @memberof pb.SevenDayInfo
             * @static
             * @param {pb.ISevenDayInfo} message SevenDayInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SevenDayInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sevenDayInfo != null && Object.hasOwnProperty.call(message, "sevenDayInfo"))
                    $root.pb.SevenDayConfig.encode(message.sevenDayInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.reward);
                return writer;
            };
    
            /**
             * Decodes a SevenDayInfo message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SevenDayInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SevenDayInfo} SevenDayInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SevenDayInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SevenDayInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.sevenDayInfo = $root.pb.SevenDayConfig.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.reward = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SevenDayInfo;
        })();
    
        pb.SevenDayInfoReq = (function() {
    
            /**
             * Properties of a SevenDayInfoReq.
             * @memberof pb
             * @interface ISevenDayInfoReq
             */
    
            /**
             * Constructs a new SevenDayInfoReq.
             * @memberof pb
             * @classdesc Represents a SevenDayInfoReq.
             * @implements ISevenDayInfoReq
             * @constructor
             * @param {pb.ISevenDayInfoReq=} [properties] Properties to set
             */
            function SevenDayInfoReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new SevenDayInfoReq instance using the specified properties.
             * @function create
             * @memberof pb.SevenDayInfoReq
             * @static
             * @param {pb.ISevenDayInfoReq=} [properties] Properties to set
             * @returns {pb.SevenDayInfoReq} SevenDayInfoReq instance
             */
            SevenDayInfoReq.create = function create(properties) {
                return new SevenDayInfoReq(properties);
            };
    
            /**
             * Encodes the specified SevenDayInfoReq message. Does not implicitly {@link pb.SevenDayInfoReq.verify|verify} messages.
             * @function encode
             * @memberof pb.SevenDayInfoReq
             * @static
             * @param {pb.ISevenDayInfoReq} message SevenDayInfoReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SevenDayInfoReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a SevenDayInfoReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SevenDayInfoReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SevenDayInfoReq} SevenDayInfoReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SevenDayInfoReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SevenDayInfoReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SevenDayInfoReq;
        })();
    
        pb.SevenDayInfoRes = (function() {
    
            /**
             * Properties of a SevenDayInfoRes.
             * @memberof pb
             * @interface ISevenDayInfoRes
             * @property {Array.<pb.ISevenDayInfo>|null} [info] SevenDayInfoRes info
             * @property {number|null} [freshTime] SevenDayInfoRes freshTime
             * @property {number|null} [lastDay] SevenDayInfoRes lastDay
             */
    
            /**
             * Constructs a new SevenDayInfoRes.
             * @memberof pb
             * @classdesc Represents a SevenDayInfoRes.
             * @implements ISevenDayInfoRes
             * @constructor
             * @param {pb.ISevenDayInfoRes=} [properties] Properties to set
             */
            function SevenDayInfoRes(properties) {
                this.info = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SevenDayInfoRes info.
             * @member {Array.<pb.ISevenDayInfo>} info
             * @memberof pb.SevenDayInfoRes
             * @instance
             */
            SevenDayInfoRes.prototype.info = $util.emptyArray;
    
            /**
             * SevenDayInfoRes freshTime.
             * @member {number} freshTime
             * @memberof pb.SevenDayInfoRes
             * @instance
             */
            SevenDayInfoRes.prototype.freshTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SevenDayInfoRes lastDay.
             * @member {number} lastDay
             * @memberof pb.SevenDayInfoRes
             * @instance
             */
            SevenDayInfoRes.prototype.lastDay = 0;
    
            /**
             * Creates a new SevenDayInfoRes instance using the specified properties.
             * @function create
             * @memberof pb.SevenDayInfoRes
             * @static
             * @param {pb.ISevenDayInfoRes=} [properties] Properties to set
             * @returns {pb.SevenDayInfoRes} SevenDayInfoRes instance
             */
            SevenDayInfoRes.create = function create(properties) {
                return new SevenDayInfoRes(properties);
            };
    
            /**
             * Encodes the specified SevenDayInfoRes message. Does not implicitly {@link pb.SevenDayInfoRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SevenDayInfoRes
             * @static
             * @param {pb.ISevenDayInfoRes} message SevenDayInfoRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SevenDayInfoRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.info != null && message.info.length)
                    for (var i = 0; i < message.info.length; ++i)
                        $root.pb.SevenDayInfo.encode(message.info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.freshTime != null && Object.hasOwnProperty.call(message, "freshTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.freshTime);
                if (message.lastDay != null && Object.hasOwnProperty.call(message, "lastDay"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.lastDay);
                return writer;
            };
    
            /**
             * Decodes a SevenDayInfoRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SevenDayInfoRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SevenDayInfoRes} SevenDayInfoRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SevenDayInfoRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SevenDayInfoRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.info && message.info.length))
                            message.info = [];
                        message.info.push($root.pb.SevenDayInfo.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.freshTime = reader.int64();
                        break;
                    case 5:
                        message.lastDay = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SevenDayInfoRes;
        })();
    
        pb.SelectRewardReq = (function() {
    
            /**
             * Properties of a SelectRewardReq.
             * @memberof pb
             * @interface ISelectRewardReq
             * @property {number|null} [id] SelectRewardReq id
             */
    
            /**
             * Constructs a new SelectRewardReq.
             * @memberof pb
             * @classdesc Represents a SelectRewardReq.
             * @implements ISelectRewardReq
             * @constructor
             * @param {pb.ISelectRewardReq=} [properties] Properties to set
             */
            function SelectRewardReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SelectRewardReq id.
             * @member {number} id
             * @memberof pb.SelectRewardReq
             * @instance
             */
            SelectRewardReq.prototype.id = 0;
    
            /**
             * Creates a new SelectRewardReq instance using the specified properties.
             * @function create
             * @memberof pb.SelectRewardReq
             * @static
             * @param {pb.ISelectRewardReq=} [properties] Properties to set
             * @returns {pb.SelectRewardReq} SelectRewardReq instance
             */
            SelectRewardReq.create = function create(properties) {
                return new SelectRewardReq(properties);
            };
    
            /**
             * Encodes the specified SelectRewardReq message. Does not implicitly {@link pb.SelectRewardReq.verify|verify} messages.
             * @function encode
             * @memberof pb.SelectRewardReq
             * @static
             * @param {pb.ISelectRewardReq} message SelectRewardReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelectRewardReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                return writer;
            };
    
            /**
             * Decodes a SelectRewardReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SelectRewardReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SelectRewardReq} SelectRewardReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelectRewardReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SelectRewardReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SelectRewardReq;
        })();
    
        pb.SelectRewardRes = (function() {
    
            /**
             * Properties of a SelectRewardRes.
             * @memberof pb
             * @interface ISelectRewardRes
             * @property {number|null} [id] SelectRewardRes id
             * @property {number|null} [code] SelectRewardRes code
             * @property {pb.INewReward|null} [reward] SelectRewardRes reward
             * @property {boolean|null} [change] SelectRewardRes change
             */
    
            /**
             * Constructs a new SelectRewardRes.
             * @memberof pb
             * @classdesc Represents a SelectRewardRes.
             * @implements ISelectRewardRes
             * @constructor
             * @param {pb.ISelectRewardRes=} [properties] Properties to set
             */
            function SelectRewardRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SelectRewardRes id.
             * @member {number} id
             * @memberof pb.SelectRewardRes
             * @instance
             */
            SelectRewardRes.prototype.id = 0;
    
            /**
             * SelectRewardRes code.
             * @member {number} code
             * @memberof pb.SelectRewardRes
             * @instance
             */
            SelectRewardRes.prototype.code = 0;
    
            /**
             * SelectRewardRes reward.
             * @member {pb.INewReward|null|undefined} reward
             * @memberof pb.SelectRewardRes
             * @instance
             */
            SelectRewardRes.prototype.reward = null;
    
            /**
             * SelectRewardRes change.
             * @member {boolean} change
             * @memberof pb.SelectRewardRes
             * @instance
             */
            SelectRewardRes.prototype.change = false;
    
            /**
             * Creates a new SelectRewardRes instance using the specified properties.
             * @function create
             * @memberof pb.SelectRewardRes
             * @static
             * @param {pb.ISelectRewardRes=} [properties] Properties to set
             * @returns {pb.SelectRewardRes} SelectRewardRes instance
             */
            SelectRewardRes.create = function create(properties) {
                return new SelectRewardRes(properties);
            };
    
            /**
             * Encodes the specified SelectRewardRes message. Does not implicitly {@link pb.SelectRewardRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SelectRewardRes
             * @static
             * @param {pb.ISelectRewardRes} message SelectRewardRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelectRewardRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.id);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.code);
                if (message.reward != null && Object.hasOwnProperty.call(message, "reward"))
                    $root.pb.NewReward.encode(message.reward, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.change != null && Object.hasOwnProperty.call(message, "change"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.change);
                return writer;
            };
    
            /**
             * Decodes a SelectRewardRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SelectRewardRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SelectRewardRes} SelectRewardRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelectRewardRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SelectRewardRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.int32();
                        break;
                    case 2:
                        message.code = reader.int32();
                        break;
                    case 3:
                        message.reward = $root.pb.NewReward.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.change = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SelectRewardRes;
        })();
    
        pb.Match2v2Req = (function() {
    
            /**
             * Properties of a Match2v2Req.
             * @memberof pb
             * @interface IMatch2v2Req
             * @property {number|null} [grade] Match2v2Req grade
             */
    
            /**
             * Constructs a new Match2v2Req.
             * @memberof pb
             * @classdesc Represents a Match2v2Req.
             * @implements IMatch2v2Req
             * @constructor
             * @param {pb.IMatch2v2Req=} [properties] Properties to set
             */
            function Match2v2Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2Req grade.
             * @member {number} grade
             * @memberof pb.Match2v2Req
             * @instance
             */
            Match2v2Req.prototype.grade = 0;
    
            /**
             * Creates a new Match2v2Req instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2Req
             * @static
             * @param {pb.IMatch2v2Req=} [properties] Properties to set
             * @returns {pb.Match2v2Req} Match2v2Req instance
             */
            Match2v2Req.create = function create(properties) {
                return new Match2v2Req(properties);
            };
    
            /**
             * Encodes the specified Match2v2Req message. Does not implicitly {@link pb.Match2v2Req.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2Req
             * @static
             * @param {pb.IMatch2v2Req} message Match2v2Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grade);
                return writer;
            };
    
            /**
             * Decodes a Match2v2Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2Req} Match2v2Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grade = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2Req;
        })();
    
        pb.Match2v2Res = (function() {
    
            /**
             * Properties of a Match2v2Res.
             * @memberof pb
             * @interface IMatch2v2Res
             * @property {number|null} [grade] Match2v2Res grade
             * @property {number|null} [code] Match2v2Res code
             */
    
            /**
             * Constructs a new Match2v2Res.
             * @memberof pb
             * @classdesc Represents a Match2v2Res.
             * @implements IMatch2v2Res
             * @constructor
             * @param {pb.IMatch2v2Res=} [properties] Properties to set
             */
            function Match2v2Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2Res grade.
             * @member {number} grade
             * @memberof pb.Match2v2Res
             * @instance
             */
            Match2v2Res.prototype.grade = 0;
    
            /**
             * Match2v2Res code.
             * @member {number} code
             * @memberof pb.Match2v2Res
             * @instance
             */
            Match2v2Res.prototype.code = 0;
    
            /**
             * Creates a new Match2v2Res instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2Res
             * @static
             * @param {pb.IMatch2v2Res=} [properties] Properties to set
             * @returns {pb.Match2v2Res} Match2v2Res instance
             */
            Match2v2Res.create = function create(properties) {
                return new Match2v2Res(properties);
            };
    
            /**
             * Encodes the specified Match2v2Res message. Does not implicitly {@link pb.Match2v2Res.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2Res
             * @static
             * @param {pb.IMatch2v2Res} message Match2v2Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grade);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a Match2v2Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2Res} Match2v2Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grade = reader.int32();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2Res;
        })();
    
        pb.Match2v2SuccessRes = (function() {
    
            /**
             * Properties of a Match2v2SuccessRes.
             * @memberof pb
             * @interface IMatch2v2SuccessRes
             * @property {number|null} [code] Match2v2SuccessRes code
             * @property {string|null} [roomId] Match2v2SuccessRes roomId
             * @property {number|null} [timestamp] Match2v2SuccessRes timestamp
             * @property {string|null} [opt] Match2v2SuccessRes opt
             * @property {string|null} [sign] Match2v2SuccessRes sign
             * @property {number|null} [grade] Match2v2SuccessRes grade
             * @property {Array.<string>|null} [team1] Match2v2SuccessRes team1
             * @property {Array.<string>|null} [team2] Match2v2SuccessRes team2
             * @property {string|null} [sn] Match2v2SuccessRes sn
             */
    
            /**
             * Constructs a new Match2v2SuccessRes.
             * @memberof pb
             * @classdesc Represents a Match2v2SuccessRes.
             * @implements IMatch2v2SuccessRes
             * @constructor
             * @param {pb.IMatch2v2SuccessRes=} [properties] Properties to set
             */
            function Match2v2SuccessRes(properties) {
                this.team1 = [];
                this.team2 = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2SuccessRes code.
             * @member {number} code
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.code = 0;
    
            /**
             * Match2v2SuccessRes roomId.
             * @member {string} roomId
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.roomId = "";
    
            /**
             * Match2v2SuccessRes timestamp.
             * @member {number} timestamp
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Match2v2SuccessRes opt.
             * @member {string} opt
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.opt = "";
    
            /**
             * Match2v2SuccessRes sign.
             * @member {string} sign
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.sign = "";
    
            /**
             * Match2v2SuccessRes grade.
             * @member {number} grade
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.grade = 0;
    
            /**
             * Match2v2SuccessRes team1.
             * @member {Array.<string>} team1
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.team1 = $util.emptyArray;
    
            /**
             * Match2v2SuccessRes team2.
             * @member {Array.<string>} team2
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.team2 = $util.emptyArray;
    
            /**
             * Match2v2SuccessRes sn.
             * @member {string} sn
             * @memberof pb.Match2v2SuccessRes
             * @instance
             */
            Match2v2SuccessRes.prototype.sn = "";
    
            /**
             * Creates a new Match2v2SuccessRes instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2SuccessRes
             * @static
             * @param {pb.IMatch2v2SuccessRes=} [properties] Properties to set
             * @returns {pb.Match2v2SuccessRes} Match2v2SuccessRes instance
             */
            Match2v2SuccessRes.create = function create(properties) {
                return new Match2v2SuccessRes(properties);
            };
    
            /**
             * Encodes the specified Match2v2SuccessRes message. Does not implicitly {@link pb.Match2v2SuccessRes.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2SuccessRes
             * @static
             * @param {pb.IMatch2v2SuccessRes} message Match2v2SuccessRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2SuccessRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.grade);
                if (message.team1 != null && message.team1.length)
                    for (var i = 0; i < message.team1.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.team1[i]);
                if (message.team2 != null && message.team2.length)
                    for (var i = 0; i < message.team2.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.team2[i]);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a Match2v2SuccessRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2SuccessRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2SuccessRes} Match2v2SuccessRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2SuccessRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2SuccessRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.roomId = reader.string();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.opt = reader.string();
                        break;
                    case 5:
                        message.sign = reader.string();
                        break;
                    case 7:
                        message.grade = reader.int32();
                        break;
                    case 8:
                        if (!(message.team1 && message.team1.length))
                            message.team1 = [];
                        message.team1.push(reader.string());
                        break;
                    case 9:
                        if (!(message.team2 && message.team2.length))
                            message.team2 = [];
                        message.team2.push(reader.string());
                        break;
                    case 15:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2SuccessRes;
        })();
    
        pb.Match2v2EnterRoomReq = (function() {
    
            /**
             * Properties of a Match2v2EnterRoomReq.
             * @memberof pb
             * @interface IMatch2v2EnterRoomReq
             * @property {string|null} [roomId] Match2v2EnterRoomReq roomId
             */
    
            /**
             * Constructs a new Match2v2EnterRoomReq.
             * @memberof pb
             * @classdesc Represents a Match2v2EnterRoomReq.
             * @implements IMatch2v2EnterRoomReq
             * @constructor
             * @param {pb.IMatch2v2EnterRoomReq=} [properties] Properties to set
             */
            function Match2v2EnterRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2EnterRoomReq roomId.
             * @member {string} roomId
             * @memberof pb.Match2v2EnterRoomReq
             * @instance
             */
            Match2v2EnterRoomReq.prototype.roomId = "";
    
            /**
             * Creates a new Match2v2EnterRoomReq instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2EnterRoomReq
             * @static
             * @param {pb.IMatch2v2EnterRoomReq=} [properties] Properties to set
             * @returns {pb.Match2v2EnterRoomReq} Match2v2EnterRoomReq instance
             */
            Match2v2EnterRoomReq.create = function create(properties) {
                return new Match2v2EnterRoomReq(properties);
            };
    
            /**
             * Encodes the specified Match2v2EnterRoomReq message. Does not implicitly {@link pb.Match2v2EnterRoomReq.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2EnterRoomReq
             * @static
             * @param {pb.IMatch2v2EnterRoomReq} message Match2v2EnterRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2EnterRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                return writer;
            };
    
            /**
             * Decodes a Match2v2EnterRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2EnterRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2EnterRoomReq} Match2v2EnterRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2EnterRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2EnterRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2EnterRoomReq;
        })();
    
        pb.Match2v2EnterRoomRes = (function() {
    
            /**
             * Properties of a Match2v2EnterRoomRes.
             * @memberof pb
             * @interface IMatch2v2EnterRoomRes
             * @property {string|null} [roomId] Match2v2EnterRoomRes roomId
             * @property {number|null} [timestamp] Match2v2EnterRoomRes timestamp
             * @property {string|null} [opt] Match2v2EnterRoomRes opt
             * @property {string|null} [sign] Match2v2EnterRoomRes sign
             * @property {number|null} [code] Match2v2EnterRoomRes code
             */
    
            /**
             * Constructs a new Match2v2EnterRoomRes.
             * @memberof pb
             * @classdesc Represents a Match2v2EnterRoomRes.
             * @implements IMatch2v2EnterRoomRes
             * @constructor
             * @param {pb.IMatch2v2EnterRoomRes=} [properties] Properties to set
             */
            function Match2v2EnterRoomRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2EnterRoomRes roomId.
             * @member {string} roomId
             * @memberof pb.Match2v2EnterRoomRes
             * @instance
             */
            Match2v2EnterRoomRes.prototype.roomId = "";
    
            /**
             * Match2v2EnterRoomRes timestamp.
             * @member {number} timestamp
             * @memberof pb.Match2v2EnterRoomRes
             * @instance
             */
            Match2v2EnterRoomRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Match2v2EnterRoomRes opt.
             * @member {string} opt
             * @memberof pb.Match2v2EnterRoomRes
             * @instance
             */
            Match2v2EnterRoomRes.prototype.opt = "";
    
            /**
             * Match2v2EnterRoomRes sign.
             * @member {string} sign
             * @memberof pb.Match2v2EnterRoomRes
             * @instance
             */
            Match2v2EnterRoomRes.prototype.sign = "";
    
            /**
             * Match2v2EnterRoomRes code.
             * @member {number} code
             * @memberof pb.Match2v2EnterRoomRes
             * @instance
             */
            Match2v2EnterRoomRes.prototype.code = 0;
    
            /**
             * Creates a new Match2v2EnterRoomRes instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2EnterRoomRes
             * @static
             * @param {pb.IMatch2v2EnterRoomRes=} [properties] Properties to set
             * @returns {pb.Match2v2EnterRoomRes} Match2v2EnterRoomRes instance
             */
            Match2v2EnterRoomRes.create = function create(properties) {
                return new Match2v2EnterRoomRes(properties);
            };
    
            /**
             * Encodes the specified Match2v2EnterRoomRes message. Does not implicitly {@link pb.Match2v2EnterRoomRes.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2EnterRoomRes
             * @static
             * @param {pb.IMatch2v2EnterRoomRes} message Match2v2EnterRoomRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2EnterRoomRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a Match2v2EnterRoomRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2EnterRoomRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2EnterRoomRes} Match2v2EnterRoomRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2EnterRoomRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2EnterRoomRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.opt = reader.string();
                        break;
                    case 4:
                        message.sign = reader.string();
                        break;
                    case 5:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2EnterRoomRes;
        })();
    
        pb.Match2v2StageChangeReq = (function() {
    
            /**
             * Properties of a Match2v2StageChangeReq.
             * @memberof pb
             * @interface IMatch2v2StageChangeReq
             * @property {number|null} [state] Match2v2StageChangeReq state
             */
    
            /**
             * Constructs a new Match2v2StageChangeReq.
             * @memberof pb
             * @classdesc Represents a Match2v2StageChangeReq.
             * @implements IMatch2v2StageChangeReq
             * @constructor
             * @param {pb.IMatch2v2StageChangeReq=} [properties] Properties to set
             */
            function Match2v2StageChangeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2StageChangeReq state.
             * @member {number} state
             * @memberof pb.Match2v2StageChangeReq
             * @instance
             */
            Match2v2StageChangeReq.prototype.state = 0;
    
            /**
             * Creates a new Match2v2StageChangeReq instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2StageChangeReq
             * @static
             * @param {pb.IMatch2v2StageChangeReq=} [properties] Properties to set
             * @returns {pb.Match2v2StageChangeReq} Match2v2StageChangeReq instance
             */
            Match2v2StageChangeReq.create = function create(properties) {
                return new Match2v2StageChangeReq(properties);
            };
    
            /**
             * Encodes the specified Match2v2StageChangeReq message. Does not implicitly {@link pb.Match2v2StageChangeReq.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2StageChangeReq
             * @static
             * @param {pb.IMatch2v2StageChangeReq} message Match2v2StageChangeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2StageChangeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                return writer;
            };
    
            /**
             * Decodes a Match2v2StageChangeReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2StageChangeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2StageChangeReq} Match2v2StageChangeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2StageChangeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2StageChangeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2StageChangeReq;
        })();
    
        pb.Match2v2UserState = (function() {
    
            /**
             * Properties of a Match2v2UserState.
             * @memberof pb
             * @interface IMatch2v2UserState
             * @property {string|null} [uid] Match2v2UserState uid
             * @property {number|null} [state] Match2v2UserState state
             * @property {number|null} [coin] Match2v2UserState coin
             */
    
            /**
             * Constructs a new Match2v2UserState.
             * @memberof pb
             * @classdesc Represents a Match2v2UserState.
             * @implements IMatch2v2UserState
             * @constructor
             * @param {pb.IMatch2v2UserState=} [properties] Properties to set
             */
            function Match2v2UserState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2UserState uid.
             * @member {string} uid
             * @memberof pb.Match2v2UserState
             * @instance
             */
            Match2v2UserState.prototype.uid = "";
    
            /**
             * Match2v2UserState state.
             * @member {number} state
             * @memberof pb.Match2v2UserState
             * @instance
             */
            Match2v2UserState.prototype.state = 0;
    
            /**
             * Match2v2UserState coin.
             * @member {number} coin
             * @memberof pb.Match2v2UserState
             * @instance
             */
            Match2v2UserState.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new Match2v2UserState instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2UserState
             * @static
             * @param {pb.IMatch2v2UserState=} [properties] Properties to set
             * @returns {pb.Match2v2UserState} Match2v2UserState instance
             */
            Match2v2UserState.create = function create(properties) {
                return new Match2v2UserState(properties);
            };
    
            /**
             * Encodes the specified Match2v2UserState message. Does not implicitly {@link pb.Match2v2UserState.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2UserState
             * @static
             * @param {pb.IMatch2v2UserState} message Match2v2UserState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2UserState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.coin);
                return writer;
            };
    
            /**
             * Decodes a Match2v2UserState message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2UserState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2UserState} Match2v2UserState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2UserState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2UserState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    case 3:
                        message.coin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2UserState;
        })();
    
        pb.Match2v2StageChangeRes = (function() {
    
            /**
             * Properties of a Match2v2StageChangeRes.
             * @memberof pb
             * @interface IMatch2v2StageChangeRes
             * @property {Array.<pb.IMatch2v2UserState>|null} [users] Match2v2StageChangeRes users
             * @property {number|null} [code] Match2v2StageChangeRes code
             */
    
            /**
             * Constructs a new Match2v2StageChangeRes.
             * @memberof pb
             * @classdesc Represents a Match2v2StageChangeRes.
             * @implements IMatch2v2StageChangeRes
             * @constructor
             * @param {pb.IMatch2v2StageChangeRes=} [properties] Properties to set
             */
            function Match2v2StageChangeRes(properties) {
                this.users = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2StageChangeRes users.
             * @member {Array.<pb.IMatch2v2UserState>} users
             * @memberof pb.Match2v2StageChangeRes
             * @instance
             */
            Match2v2StageChangeRes.prototype.users = $util.emptyArray;
    
            /**
             * Match2v2StageChangeRes code.
             * @member {number} code
             * @memberof pb.Match2v2StageChangeRes
             * @instance
             */
            Match2v2StageChangeRes.prototype.code = 0;
    
            /**
             * Creates a new Match2v2StageChangeRes instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2StageChangeRes
             * @static
             * @param {pb.IMatch2v2StageChangeRes=} [properties] Properties to set
             * @returns {pb.Match2v2StageChangeRes} Match2v2StageChangeRes instance
             */
            Match2v2StageChangeRes.create = function create(properties) {
                return new Match2v2StageChangeRes(properties);
            };
    
            /**
             * Encodes the specified Match2v2StageChangeRes message. Does not implicitly {@link pb.Match2v2StageChangeRes.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2StageChangeRes
             * @static
             * @param {pb.IMatch2v2StageChangeRes} message Match2v2StageChangeRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2StageChangeRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.users != null && message.users.length)
                    for (var i = 0; i < message.users.length; ++i)
                        $root.pb.Match2v2UserState.encode(message.users[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a Match2v2StageChangeRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2StageChangeRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2StageChangeRes} Match2v2StageChangeRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2StageChangeRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2StageChangeRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.users && message.users.length))
                            message.users = [];
                        message.users.push($root.pb.Match2v2UserState.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2StageChangeRes;
        })();
    
        pb.Match2v2ExitRoomReq = (function() {
    
            /**
             * Properties of a Match2v2ExitRoomReq.
             * @memberof pb
             * @interface IMatch2v2ExitRoomReq
             */
    
            /**
             * Constructs a new Match2v2ExitRoomReq.
             * @memberof pb
             * @classdesc Represents a Match2v2ExitRoomReq.
             * @implements IMatch2v2ExitRoomReq
             * @constructor
             * @param {pb.IMatch2v2ExitRoomReq=} [properties] Properties to set
             */
            function Match2v2ExitRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new Match2v2ExitRoomReq instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2ExitRoomReq
             * @static
             * @param {pb.IMatch2v2ExitRoomReq=} [properties] Properties to set
             * @returns {pb.Match2v2ExitRoomReq} Match2v2ExitRoomReq instance
             */
            Match2v2ExitRoomReq.create = function create(properties) {
                return new Match2v2ExitRoomReq(properties);
            };
    
            /**
             * Encodes the specified Match2v2ExitRoomReq message. Does not implicitly {@link pb.Match2v2ExitRoomReq.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2ExitRoomReq
             * @static
             * @param {pb.IMatch2v2ExitRoomReq} message Match2v2ExitRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2ExitRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a Match2v2ExitRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2ExitRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2ExitRoomReq} Match2v2ExitRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2ExitRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2ExitRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2ExitRoomReq;
        })();
    
        pb.Match2v2ExitRoomRes = (function() {
    
            /**
             * Properties of a Match2v2ExitRoomRes.
             * @memberof pb
             * @interface IMatch2v2ExitRoomRes
             * @property {string|null} [roomId] Match2v2ExitRoomRes roomId
             * @property {number|null} [timestamp] Match2v2ExitRoomRes timestamp
             * @property {string|null} [opt] Match2v2ExitRoomRes opt
             * @property {string|null} [sign] Match2v2ExitRoomRes sign
             * @property {number|null} [code] Match2v2ExitRoomRes code
             */
    
            /**
             * Constructs a new Match2v2ExitRoomRes.
             * @memberof pb
             * @classdesc Represents a Match2v2ExitRoomRes.
             * @implements IMatch2v2ExitRoomRes
             * @constructor
             * @param {pb.IMatch2v2ExitRoomRes=} [properties] Properties to set
             */
            function Match2v2ExitRoomRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Match2v2ExitRoomRes roomId.
             * @member {string} roomId
             * @memberof pb.Match2v2ExitRoomRes
             * @instance
             */
            Match2v2ExitRoomRes.prototype.roomId = "";
    
            /**
             * Match2v2ExitRoomRes timestamp.
             * @member {number} timestamp
             * @memberof pb.Match2v2ExitRoomRes
             * @instance
             */
            Match2v2ExitRoomRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Match2v2ExitRoomRes opt.
             * @member {string} opt
             * @memberof pb.Match2v2ExitRoomRes
             * @instance
             */
            Match2v2ExitRoomRes.prototype.opt = "";
    
            /**
             * Match2v2ExitRoomRes sign.
             * @member {string} sign
             * @memberof pb.Match2v2ExitRoomRes
             * @instance
             */
            Match2v2ExitRoomRes.prototype.sign = "";
    
            /**
             * Match2v2ExitRoomRes code.
             * @member {number} code
             * @memberof pb.Match2v2ExitRoomRes
             * @instance
             */
            Match2v2ExitRoomRes.prototype.code = 0;
    
            /**
             * Creates a new Match2v2ExitRoomRes instance using the specified properties.
             * @function create
             * @memberof pb.Match2v2ExitRoomRes
             * @static
             * @param {pb.IMatch2v2ExitRoomRes=} [properties] Properties to set
             * @returns {pb.Match2v2ExitRoomRes} Match2v2ExitRoomRes instance
             */
            Match2v2ExitRoomRes.create = function create(properties) {
                return new Match2v2ExitRoomRes(properties);
            };
    
            /**
             * Encodes the specified Match2v2ExitRoomRes message. Does not implicitly {@link pb.Match2v2ExitRoomRes.verify|verify} messages.
             * @function encode
             * @memberof pb.Match2v2ExitRoomRes
             * @static
             * @param {pb.IMatch2v2ExitRoomRes} message Match2v2ExitRoomRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Match2v2ExitRoomRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a Match2v2ExitRoomRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.Match2v2ExitRoomRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.Match2v2ExitRoomRes} Match2v2ExitRoomRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Match2v2ExitRoomRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Match2v2ExitRoomRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.opt = reader.string();
                        break;
                    case 4:
                        message.sign = reader.string();
                        break;
                    case 5:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return Match2v2ExitRoomRes;
        })();
    
        pb.MatchGhostReq = (function() {
    
            /**
             * Properties of a MatchGhostReq.
             * @memberof pb
             * @interface IMatchGhostReq
             * @property {number|null} [grade] MatchGhostReq grade
             */
    
            /**
             * Constructs a new MatchGhostReq.
             * @memberof pb
             * @classdesc Represents a MatchGhostReq.
             * @implements IMatchGhostReq
             * @constructor
             * @param {pb.IMatchGhostReq=} [properties] Properties to set
             */
            function MatchGhostReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostReq grade.
             * @member {number} grade
             * @memberof pb.MatchGhostReq
             * @instance
             */
            MatchGhostReq.prototype.grade = 0;
    
            /**
             * Creates a new MatchGhostReq instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostReq
             * @static
             * @param {pb.IMatchGhostReq=} [properties] Properties to set
             * @returns {pb.MatchGhostReq} MatchGhostReq instance
             */
            MatchGhostReq.create = function create(properties) {
                return new MatchGhostReq(properties);
            };
    
            /**
             * Encodes the specified MatchGhostReq message. Does not implicitly {@link pb.MatchGhostReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostReq
             * @static
             * @param {pb.IMatchGhostReq} message MatchGhostReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grade);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostReq} MatchGhostReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grade = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostReq;
        })();
    
        pb.MatchGhostRes = (function() {
    
            /**
             * Properties of a MatchGhostRes.
             * @memberof pb
             * @interface IMatchGhostRes
             * @property {number|null} [grade] MatchGhostRes grade
             * @property {number|null} [code] MatchGhostRes code
             */
    
            /**
             * Constructs a new MatchGhostRes.
             * @memberof pb
             * @classdesc Represents a MatchGhostRes.
             * @implements IMatchGhostRes
             * @constructor
             * @param {pb.IMatchGhostRes=} [properties] Properties to set
             */
            function MatchGhostRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostRes grade.
             * @member {number} grade
             * @memberof pb.MatchGhostRes
             * @instance
             */
            MatchGhostRes.prototype.grade = 0;
    
            /**
             * MatchGhostRes code.
             * @member {number} code
             * @memberof pb.MatchGhostRes
             * @instance
             */
            MatchGhostRes.prototype.code = 0;
    
            /**
             * Creates a new MatchGhostRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostRes
             * @static
             * @param {pb.IMatchGhostRes=} [properties] Properties to set
             * @returns {pb.MatchGhostRes} MatchGhostRes instance
             */
            MatchGhostRes.create = function create(properties) {
                return new MatchGhostRes(properties);
            };
    
            /**
             * Encodes the specified MatchGhostRes message. Does not implicitly {@link pb.MatchGhostRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostRes
             * @static
             * @param {pb.IMatchGhostRes} message MatchGhostRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grade);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostRes} MatchGhostRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grade = reader.int32();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostRes;
        })();
    
        pb.MatchGhostSuccessRes = (function() {
    
            /**
             * Properties of a MatchGhostSuccessRes.
             * @memberof pb
             * @interface IMatchGhostSuccessRes
             * @property {number|null} [code] MatchGhostSuccessRes code
             * @property {string|null} [roomId] MatchGhostSuccessRes roomId
             * @property {number|null} [timestamp] MatchGhostSuccessRes timestamp
             * @property {string|null} [opt] MatchGhostSuccessRes opt
             * @property {string|null} [sign] MatchGhostSuccessRes sign
             * @property {number|null} [grade] MatchGhostSuccessRes grade
             * @property {Array.<string>|null} [team1] MatchGhostSuccessRes team1
             * @property {Array.<string>|null} [team2] MatchGhostSuccessRes team2
             * @property {string|null} [sn] MatchGhostSuccessRes sn
             */
    
            /**
             * Constructs a new MatchGhostSuccessRes.
             * @memberof pb
             * @classdesc Represents a MatchGhostSuccessRes.
             * @implements IMatchGhostSuccessRes
             * @constructor
             * @param {pb.IMatchGhostSuccessRes=} [properties] Properties to set
             */
            function MatchGhostSuccessRes(properties) {
                this.team1 = [];
                this.team2 = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostSuccessRes code.
             * @member {number} code
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.code = 0;
    
            /**
             * MatchGhostSuccessRes roomId.
             * @member {string} roomId
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.roomId = "";
    
            /**
             * MatchGhostSuccessRes timestamp.
             * @member {number} timestamp
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MatchGhostSuccessRes opt.
             * @member {string} opt
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.opt = "";
    
            /**
             * MatchGhostSuccessRes sign.
             * @member {string} sign
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.sign = "";
    
            /**
             * MatchGhostSuccessRes grade.
             * @member {number} grade
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.grade = 0;
    
            /**
             * MatchGhostSuccessRes team1.
             * @member {Array.<string>} team1
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.team1 = $util.emptyArray;
    
            /**
             * MatchGhostSuccessRes team2.
             * @member {Array.<string>} team2
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.team2 = $util.emptyArray;
    
            /**
             * MatchGhostSuccessRes sn.
             * @member {string} sn
             * @memberof pb.MatchGhostSuccessRes
             * @instance
             */
            MatchGhostSuccessRes.prototype.sn = "";
    
            /**
             * Creates a new MatchGhostSuccessRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostSuccessRes
             * @static
             * @param {pb.IMatchGhostSuccessRes=} [properties] Properties to set
             * @returns {pb.MatchGhostSuccessRes} MatchGhostSuccessRes instance
             */
            MatchGhostSuccessRes.create = function create(properties) {
                return new MatchGhostSuccessRes(properties);
            };
    
            /**
             * Encodes the specified MatchGhostSuccessRes message. Does not implicitly {@link pb.MatchGhostSuccessRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostSuccessRes
             * @static
             * @param {pb.IMatchGhostSuccessRes} message MatchGhostSuccessRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostSuccessRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.grade);
                if (message.team1 != null && message.team1.length)
                    for (var i = 0; i < message.team1.length; ++i)
                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.team1[i]);
                if (message.team2 != null && message.team2.length)
                    for (var i = 0; i < message.team2.length; ++i)
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.team2[i]);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostSuccessRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostSuccessRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostSuccessRes} MatchGhostSuccessRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostSuccessRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostSuccessRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.roomId = reader.string();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.opt = reader.string();
                        break;
                    case 5:
                        message.sign = reader.string();
                        break;
                    case 7:
                        message.grade = reader.int32();
                        break;
                    case 8:
                        if (!(message.team1 && message.team1.length))
                            message.team1 = [];
                        message.team1.push(reader.string());
                        break;
                    case 9:
                        if (!(message.team2 && message.team2.length))
                            message.team2 = [];
                        message.team2.push(reader.string());
                        break;
                    case 15:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostSuccessRes;
        })();
    
        pb.MatchGhostEnterRoomReq = (function() {
    
            /**
             * Properties of a MatchGhostEnterRoomReq.
             * @memberof pb
             * @interface IMatchGhostEnterRoomReq
             * @property {string|null} [roomId] MatchGhostEnterRoomReq roomId
             */
    
            /**
             * Constructs a new MatchGhostEnterRoomReq.
             * @memberof pb
             * @classdesc Represents a MatchGhostEnterRoomReq.
             * @implements IMatchGhostEnterRoomReq
             * @constructor
             * @param {pb.IMatchGhostEnterRoomReq=} [properties] Properties to set
             */
            function MatchGhostEnterRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostEnterRoomReq roomId.
             * @member {string} roomId
             * @memberof pb.MatchGhostEnterRoomReq
             * @instance
             */
            MatchGhostEnterRoomReq.prototype.roomId = "";
    
            /**
             * Creates a new MatchGhostEnterRoomReq instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostEnterRoomReq
             * @static
             * @param {pb.IMatchGhostEnterRoomReq=} [properties] Properties to set
             * @returns {pb.MatchGhostEnterRoomReq} MatchGhostEnterRoomReq instance
             */
            MatchGhostEnterRoomReq.create = function create(properties) {
                return new MatchGhostEnterRoomReq(properties);
            };
    
            /**
             * Encodes the specified MatchGhostEnterRoomReq message. Does not implicitly {@link pb.MatchGhostEnterRoomReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostEnterRoomReq
             * @static
             * @param {pb.IMatchGhostEnterRoomReq} message MatchGhostEnterRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostEnterRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostEnterRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostEnterRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostEnterRoomReq} MatchGhostEnterRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostEnterRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostEnterRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostEnterRoomReq;
        })();
    
        pb.MatchGhostEnterRoomRes = (function() {
    
            /**
             * Properties of a MatchGhostEnterRoomRes.
             * @memberof pb
             * @interface IMatchGhostEnterRoomRes
             * @property {string|null} [roomId] MatchGhostEnterRoomRes roomId
             * @property {number|null} [timestamp] MatchGhostEnterRoomRes timestamp
             * @property {string|null} [opt] MatchGhostEnterRoomRes opt
             * @property {string|null} [sign] MatchGhostEnterRoomRes sign
             * @property {number|null} [code] MatchGhostEnterRoomRes code
             */
    
            /**
             * Constructs a new MatchGhostEnterRoomRes.
             * @memberof pb
             * @classdesc Represents a MatchGhostEnterRoomRes.
             * @implements IMatchGhostEnterRoomRes
             * @constructor
             * @param {pb.IMatchGhostEnterRoomRes=} [properties] Properties to set
             */
            function MatchGhostEnterRoomRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostEnterRoomRes roomId.
             * @member {string} roomId
             * @memberof pb.MatchGhostEnterRoomRes
             * @instance
             */
            MatchGhostEnterRoomRes.prototype.roomId = "";
    
            /**
             * MatchGhostEnterRoomRes timestamp.
             * @member {number} timestamp
             * @memberof pb.MatchGhostEnterRoomRes
             * @instance
             */
            MatchGhostEnterRoomRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MatchGhostEnterRoomRes opt.
             * @member {string} opt
             * @memberof pb.MatchGhostEnterRoomRes
             * @instance
             */
            MatchGhostEnterRoomRes.prototype.opt = "";
    
            /**
             * MatchGhostEnterRoomRes sign.
             * @member {string} sign
             * @memberof pb.MatchGhostEnterRoomRes
             * @instance
             */
            MatchGhostEnterRoomRes.prototype.sign = "";
    
            /**
             * MatchGhostEnterRoomRes code.
             * @member {number} code
             * @memberof pb.MatchGhostEnterRoomRes
             * @instance
             */
            MatchGhostEnterRoomRes.prototype.code = 0;
    
            /**
             * Creates a new MatchGhostEnterRoomRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostEnterRoomRes
             * @static
             * @param {pb.IMatchGhostEnterRoomRes=} [properties] Properties to set
             * @returns {pb.MatchGhostEnterRoomRes} MatchGhostEnterRoomRes instance
             */
            MatchGhostEnterRoomRes.create = function create(properties) {
                return new MatchGhostEnterRoomRes(properties);
            };
    
            /**
             * Encodes the specified MatchGhostEnterRoomRes message. Does not implicitly {@link pb.MatchGhostEnterRoomRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostEnterRoomRes
             * @static
             * @param {pb.IMatchGhostEnterRoomRes} message MatchGhostEnterRoomRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostEnterRoomRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostEnterRoomRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostEnterRoomRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostEnterRoomRes} MatchGhostEnterRoomRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostEnterRoomRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostEnterRoomRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.opt = reader.string();
                        break;
                    case 4:
                        message.sign = reader.string();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostEnterRoomRes;
        })();
    
        pb.MatchGhostStageChangeReq = (function() {
    
            /**
             * Properties of a MatchGhostStageChangeReq.
             * @memberof pb
             * @interface IMatchGhostStageChangeReq
             * @property {number|null} [state] MatchGhostStageChangeReq state
             */
    
            /**
             * Constructs a new MatchGhostStageChangeReq.
             * @memberof pb
             * @classdesc Represents a MatchGhostStageChangeReq.
             * @implements IMatchGhostStageChangeReq
             * @constructor
             * @param {pb.IMatchGhostStageChangeReq=} [properties] Properties to set
             */
            function MatchGhostStageChangeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostStageChangeReq state.
             * @member {number} state
             * @memberof pb.MatchGhostStageChangeReq
             * @instance
             */
            MatchGhostStageChangeReq.prototype.state = 0;
    
            /**
             * Creates a new MatchGhostStageChangeReq instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostStageChangeReq
             * @static
             * @param {pb.IMatchGhostStageChangeReq=} [properties] Properties to set
             * @returns {pb.MatchGhostStageChangeReq} MatchGhostStageChangeReq instance
             */
            MatchGhostStageChangeReq.create = function create(properties) {
                return new MatchGhostStageChangeReq(properties);
            };
    
            /**
             * Encodes the specified MatchGhostStageChangeReq message. Does not implicitly {@link pb.MatchGhostStageChangeReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostStageChangeReq
             * @static
             * @param {pb.IMatchGhostStageChangeReq} message MatchGhostStageChangeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostStageChangeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostStageChangeReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostStageChangeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostStageChangeReq} MatchGhostStageChangeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostStageChangeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostStageChangeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.state = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostStageChangeReq;
        })();
    
        pb.MatchGhostUserState = (function() {
    
            /**
             * Properties of a MatchGhostUserState.
             * @memberof pb
             * @interface IMatchGhostUserState
             * @property {string|null} [uid] MatchGhostUserState uid
             * @property {number|null} [state] MatchGhostUserState state
             * @property {number|null} [coin] MatchGhostUserState coin
             * @property {number|null} [ticket] MatchGhostUserState ticket
             * @property {number|null} [freeTicket] MatchGhostUserState freeTicket
             */
    
            /**
             * Constructs a new MatchGhostUserState.
             * @memberof pb
             * @classdesc Represents a MatchGhostUserState.
             * @implements IMatchGhostUserState
             * @constructor
             * @param {pb.IMatchGhostUserState=} [properties] Properties to set
             */
            function MatchGhostUserState(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostUserState uid.
             * @member {string} uid
             * @memberof pb.MatchGhostUserState
             * @instance
             */
            MatchGhostUserState.prototype.uid = "";
    
            /**
             * MatchGhostUserState state.
             * @member {number} state
             * @memberof pb.MatchGhostUserState
             * @instance
             */
            MatchGhostUserState.prototype.state = 0;
    
            /**
             * MatchGhostUserState coin.
             * @member {number} coin
             * @memberof pb.MatchGhostUserState
             * @instance
             */
            MatchGhostUserState.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MatchGhostUserState ticket.
             * @member {number} ticket
             * @memberof pb.MatchGhostUserState
             * @instance
             */
            MatchGhostUserState.prototype.ticket = 0;
    
            /**
             * MatchGhostUserState freeTicket.
             * @member {number} freeTicket
             * @memberof pb.MatchGhostUserState
             * @instance
             */
            MatchGhostUserState.prototype.freeTicket = 0;
    
            /**
             * Creates a new MatchGhostUserState instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostUserState
             * @static
             * @param {pb.IMatchGhostUserState=} [properties] Properties to set
             * @returns {pb.MatchGhostUserState} MatchGhostUserState instance
             */
            MatchGhostUserState.create = function create(properties) {
                return new MatchGhostUserState(properties);
            };
    
            /**
             * Encodes the specified MatchGhostUserState message. Does not implicitly {@link pb.MatchGhostUserState.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostUserState
             * @static
             * @param {pb.IMatchGhostUserState} message MatchGhostUserState message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostUserState.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.coin);
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ticket);
                if (message.freeTicket != null && Object.hasOwnProperty.call(message, "freeTicket"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.freeTicket);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostUserState message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostUserState
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostUserState} MatchGhostUserState
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostUserState.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostUserState();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.state = reader.int32();
                        break;
                    case 3:
                        message.coin = reader.int64();
                        break;
                    case 4:
                        message.ticket = reader.int32();
                        break;
                    case 5:
                        message.freeTicket = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostUserState;
        })();
    
        pb.MatchGhostStageChangeRes = (function() {
    
            /**
             * Properties of a MatchGhostStageChangeRes.
             * @memberof pb
             * @interface IMatchGhostStageChangeRes
             * @property {Array.<pb.IMatchGhostUserState>|null} [users] MatchGhostStageChangeRes users
             * @property {number|null} [code] MatchGhostStageChangeRes code
             */
    
            /**
             * Constructs a new MatchGhostStageChangeRes.
             * @memberof pb
             * @classdesc Represents a MatchGhostStageChangeRes.
             * @implements IMatchGhostStageChangeRes
             * @constructor
             * @param {pb.IMatchGhostStageChangeRes=} [properties] Properties to set
             */
            function MatchGhostStageChangeRes(properties) {
                this.users = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostStageChangeRes users.
             * @member {Array.<pb.IMatchGhostUserState>} users
             * @memberof pb.MatchGhostStageChangeRes
             * @instance
             */
            MatchGhostStageChangeRes.prototype.users = $util.emptyArray;
    
            /**
             * MatchGhostStageChangeRes code.
             * @member {number} code
             * @memberof pb.MatchGhostStageChangeRes
             * @instance
             */
            MatchGhostStageChangeRes.prototype.code = 0;
    
            /**
             * Creates a new MatchGhostStageChangeRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostStageChangeRes
             * @static
             * @param {pb.IMatchGhostStageChangeRes=} [properties] Properties to set
             * @returns {pb.MatchGhostStageChangeRes} MatchGhostStageChangeRes instance
             */
            MatchGhostStageChangeRes.create = function create(properties) {
                return new MatchGhostStageChangeRes(properties);
            };
    
            /**
             * Encodes the specified MatchGhostStageChangeRes message. Does not implicitly {@link pb.MatchGhostStageChangeRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostStageChangeRes
             * @static
             * @param {pb.IMatchGhostStageChangeRes} message MatchGhostStageChangeRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostStageChangeRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.users != null && message.users.length)
                    for (var i = 0; i < message.users.length; ++i)
                        $root.pb.MatchGhostUserState.encode(message.users[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostStageChangeRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostStageChangeRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostStageChangeRes} MatchGhostStageChangeRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostStageChangeRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostStageChangeRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.users && message.users.length))
                            message.users = [];
                        message.users.push($root.pb.MatchGhostUserState.decode(reader, reader.uint32()));
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostStageChangeRes;
        })();
    
        pb.MatchGhostExitRoomReq = (function() {
    
            /**
             * Properties of a MatchGhostExitRoomReq.
             * @memberof pb
             * @interface IMatchGhostExitRoomReq
             */
    
            /**
             * Constructs a new MatchGhostExitRoomReq.
             * @memberof pb
             * @classdesc Represents a MatchGhostExitRoomReq.
             * @implements IMatchGhostExitRoomReq
             * @constructor
             * @param {pb.IMatchGhostExitRoomReq=} [properties] Properties to set
             */
            function MatchGhostExitRoomReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new MatchGhostExitRoomReq instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostExitRoomReq
             * @static
             * @param {pb.IMatchGhostExitRoomReq=} [properties] Properties to set
             * @returns {pb.MatchGhostExitRoomReq} MatchGhostExitRoomReq instance
             */
            MatchGhostExitRoomReq.create = function create(properties) {
                return new MatchGhostExitRoomReq(properties);
            };
    
            /**
             * Encodes the specified MatchGhostExitRoomReq message. Does not implicitly {@link pb.MatchGhostExitRoomReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostExitRoomReq
             * @static
             * @param {pb.IMatchGhostExitRoomReq} message MatchGhostExitRoomReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostExitRoomReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a MatchGhostExitRoomReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostExitRoomReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostExitRoomReq} MatchGhostExitRoomReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostExitRoomReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostExitRoomReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostExitRoomReq;
        })();
    
        pb.MatchGhostExitRoomRes = (function() {
    
            /**
             * Properties of a MatchGhostExitRoomRes.
             * @memberof pb
             * @interface IMatchGhostExitRoomRes
             * @property {string|null} [roomId] MatchGhostExitRoomRes roomId
             * @property {number|null} [timestamp] MatchGhostExitRoomRes timestamp
             * @property {string|null} [opt] MatchGhostExitRoomRes opt
             * @property {string|null} [sign] MatchGhostExitRoomRes sign
             * @property {number|null} [code] MatchGhostExitRoomRes code
             */
    
            /**
             * Constructs a new MatchGhostExitRoomRes.
             * @memberof pb
             * @classdesc Represents a MatchGhostExitRoomRes.
             * @implements IMatchGhostExitRoomRes
             * @constructor
             * @param {pb.IMatchGhostExitRoomRes=} [properties] Properties to set
             */
            function MatchGhostExitRoomRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchGhostExitRoomRes roomId.
             * @member {string} roomId
             * @memberof pb.MatchGhostExitRoomRes
             * @instance
             */
            MatchGhostExitRoomRes.prototype.roomId = "";
    
            /**
             * MatchGhostExitRoomRes timestamp.
             * @member {number} timestamp
             * @memberof pb.MatchGhostExitRoomRes
             * @instance
             */
            MatchGhostExitRoomRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MatchGhostExitRoomRes opt.
             * @member {string} opt
             * @memberof pb.MatchGhostExitRoomRes
             * @instance
             */
            MatchGhostExitRoomRes.prototype.opt = "";
    
            /**
             * MatchGhostExitRoomRes sign.
             * @member {string} sign
             * @memberof pb.MatchGhostExitRoomRes
             * @instance
             */
            MatchGhostExitRoomRes.prototype.sign = "";
    
            /**
             * MatchGhostExitRoomRes code.
             * @member {number} code
             * @memberof pb.MatchGhostExitRoomRes
             * @instance
             */
            MatchGhostExitRoomRes.prototype.code = 0;
    
            /**
             * Creates a new MatchGhostExitRoomRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchGhostExitRoomRes
             * @static
             * @param {pb.IMatchGhostExitRoomRes=} [properties] Properties to set
             * @returns {pb.MatchGhostExitRoomRes} MatchGhostExitRoomRes instance
             */
            MatchGhostExitRoomRes.create = function create(properties) {
                return new MatchGhostExitRoomRes(properties);
            };
    
            /**
             * Encodes the specified MatchGhostExitRoomRes message. Does not implicitly {@link pb.MatchGhostExitRoomRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchGhostExitRoomRes
             * @static
             * @param {pb.IMatchGhostExitRoomRes} message MatchGhostExitRoomRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchGhostExitRoomRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.sign);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a MatchGhostExitRoomRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchGhostExitRoomRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchGhostExitRoomRes} MatchGhostExitRoomRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchGhostExitRoomRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchGhostExitRoomRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.roomId = reader.string();
                        break;
                    case 2:
                        message.timestamp = reader.int64();
                        break;
                    case 3:
                        message.opt = reader.string();
                        break;
                    case 4:
                        message.sign = reader.string();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchGhostExitRoomRes;
        })();
    
        pb.GhostReadyGoRes = (function() {
    
            /**
             * Properties of a GhostReadyGoRes.
             * @memberof pb
             * @interface IGhostReadyGoRes
             * @property {number|null} [code] GhostReadyGoRes code
             * @property {string|null} [msg] GhostReadyGoRes msg
             * @property {pb.IGhostReadyGoResData|null} [data] GhostReadyGoRes data
             */
    
            /**
             * Constructs a new GhostReadyGoRes.
             * @memberof pb
             * @classdesc Represents a GhostReadyGoRes.
             * @implements IGhostReadyGoRes
             * @constructor
             * @param {pb.IGhostReadyGoRes=} [properties] Properties to set
             */
            function GhostReadyGoRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostReadyGoRes code.
             * @member {number} code
             * @memberof pb.GhostReadyGoRes
             * @instance
             */
            GhostReadyGoRes.prototype.code = 0;
    
            /**
             * GhostReadyGoRes msg.
             * @member {string} msg
             * @memberof pb.GhostReadyGoRes
             * @instance
             */
            GhostReadyGoRes.prototype.msg = "";
    
            /**
             * GhostReadyGoRes data.
             * @member {pb.IGhostReadyGoResData|null|undefined} data
             * @memberof pb.GhostReadyGoRes
             * @instance
             */
            GhostReadyGoRes.prototype.data = null;
    
            /**
             * Creates a new GhostReadyGoRes instance using the specified properties.
             * @function create
             * @memberof pb.GhostReadyGoRes
             * @static
             * @param {pb.IGhostReadyGoRes=} [properties] Properties to set
             * @returns {pb.GhostReadyGoRes} GhostReadyGoRes instance
             */
            GhostReadyGoRes.create = function create(properties) {
                return new GhostReadyGoRes(properties);
            };
    
            /**
             * Encodes the specified GhostReadyGoRes message. Does not implicitly {@link pb.GhostReadyGoRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostReadyGoRes
             * @static
             * @param {pb.IGhostReadyGoRes} message GhostReadyGoRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostReadyGoRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.GhostReadyGoResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostReadyGoRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostReadyGoRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostReadyGoRes} GhostReadyGoRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostReadyGoRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostReadyGoRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.GhostReadyGoResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostReadyGoRes;
        })();
    
        pb.GhostReadyGoResData = (function() {
    
            /**
             * Properties of a GhostReadyGoResData.
             * @memberof pb
             * @interface IGhostReadyGoResData
             * @property {string|null} [first_uid] GhostReadyGoResData first_uid
             * @property {pb.IGhostChessBoard|null} [chessboard] GhostReadyGoResData chessboard
             * @property {number|null} [start_time] GhostReadyGoResData start_time
             * @property {number|null} [roundEndTime] GhostReadyGoResData roundEndTime
             * @property {Array.<pb.IUserData>|null} [userDatas] GhostReadyGoResData userDatas
             * @property {number|null} [loseCoin] GhostReadyGoResData loseCoin
             * @property {number|null} [winCoin] GhostReadyGoResData winCoin
             * @property {number|null} [gameMode] GhostReadyGoResData gameMode
             * @property {number|null} [aiMode] GhostReadyGoResData aiMode
             * @property {number|null} [point] GhostReadyGoResData point
             * @property {number|null} [deadPoint] GhostReadyGoResData deadPoint
             * @property {number|null} [deadCount] GhostReadyGoResData deadCount
             * @property {number|null} [deadModeLeftRound] GhostReadyGoResData deadModeLeftRound
             * @property {number|null} [deadModeMaxRound] GhostReadyGoResData deadModeMaxRound
             * @property {pb.IGhostGameInfo|null} [info] GhostReadyGoResData info
             */
    
            /**
             * Constructs a new GhostReadyGoResData.
             * @memberof pb
             * @classdesc Represents a GhostReadyGoResData.
             * @implements IGhostReadyGoResData
             * @constructor
             * @param {pb.IGhostReadyGoResData=} [properties] Properties to set
             */
            function GhostReadyGoResData(properties) {
                this.userDatas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostReadyGoResData first_uid.
             * @member {string} first_uid
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.first_uid = "";
    
            /**
             * GhostReadyGoResData chessboard.
             * @member {pb.IGhostChessBoard|null|undefined} chessboard
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.chessboard = null;
    
            /**
             * GhostReadyGoResData start_time.
             * @member {number} start_time
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.start_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReadyGoResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReadyGoResData userDatas.
             * @member {Array.<pb.IUserData>} userDatas
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.userDatas = $util.emptyArray;
    
            /**
             * GhostReadyGoResData loseCoin.
             * @member {number} loseCoin
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.loseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReadyGoResData winCoin.
             * @member {number} winCoin
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.winCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReadyGoResData gameMode.
             * @member {number} gameMode
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.gameMode = 0;
    
            /**
             * GhostReadyGoResData aiMode.
             * @member {number} aiMode
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.aiMode = 0;
    
            /**
             * GhostReadyGoResData point.
             * @member {number} point
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.point = 0;
    
            /**
             * GhostReadyGoResData deadPoint.
             * @member {number} deadPoint
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.deadPoint = 0;
    
            /**
             * GhostReadyGoResData deadCount.
             * @member {number} deadCount
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.deadCount = 0;
    
            /**
             * GhostReadyGoResData deadModeLeftRound.
             * @member {number} deadModeLeftRound
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.deadModeLeftRound = 0;
    
            /**
             * GhostReadyGoResData deadModeMaxRound.
             * @member {number} deadModeMaxRound
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.deadModeMaxRound = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReadyGoResData info.
             * @member {pb.IGhostGameInfo|null|undefined} info
             * @memberof pb.GhostReadyGoResData
             * @instance
             */
            GhostReadyGoResData.prototype.info = null;
    
            /**
             * Creates a new GhostReadyGoResData instance using the specified properties.
             * @function create
             * @memberof pb.GhostReadyGoResData
             * @static
             * @param {pb.IGhostReadyGoResData=} [properties] Properties to set
             * @returns {pb.GhostReadyGoResData} GhostReadyGoResData instance
             */
            GhostReadyGoResData.create = function create(properties) {
                return new GhostReadyGoResData(properties);
            };
    
            /**
             * Encodes the specified GhostReadyGoResData message. Does not implicitly {@link pb.GhostReadyGoResData.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostReadyGoResData
             * @static
             * @param {pb.IGhostReadyGoResData} message GhostReadyGoResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostReadyGoResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.first_uid != null && Object.hasOwnProperty.call(message, "first_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.first_uid);
                if (message.chessboard != null && Object.hasOwnProperty.call(message, "chessboard"))
                    $root.pb.GhostChessBoard.encode(message.chessboard, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.start_time != null && Object.hasOwnProperty.call(message, "start_time"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.start_time);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.roundEndTime);
                if (message.userDatas != null && message.userDatas.length)
                    for (var i = 0; i < message.userDatas.length; ++i)
                        $root.pb.UserData.encode(message.userDatas[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.loseCoin != null && Object.hasOwnProperty.call(message, "loseCoin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.loseCoin);
                if (message.winCoin != null && Object.hasOwnProperty.call(message, "winCoin"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.winCoin);
                if (message.aiMode != null && Object.hasOwnProperty.call(message, "aiMode"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.aiMode);
                if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                    writer.uint32(/* id 9, wireType 1 =*/73).double(message.point);
                if (message.deadPoint != null && Object.hasOwnProperty.call(message, "deadPoint"))
                    writer.uint32(/* id 10, wireType 1 =*/81).double(message.deadPoint);
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gameMode);
                if (message.deadCount != null && Object.hasOwnProperty.call(message, "deadCount"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.deadCount);
                if (message.deadModeLeftRound != null && Object.hasOwnProperty.call(message, "deadModeLeftRound"))
                    writer.uint32(/* id 13, wireType 0 =*/104).int32(message.deadModeLeftRound);
                if (message.deadModeMaxRound != null && Object.hasOwnProperty.call(message, "deadModeMaxRound"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.deadModeMaxRound);
                if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                    $root.pb.GhostGameInfo.encode(message.info, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostReadyGoResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostReadyGoResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostReadyGoResData} GhostReadyGoResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostReadyGoResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostReadyGoResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.first_uid = reader.string();
                        break;
                    case 2:
                        message.chessboard = $root.pb.GhostChessBoard.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.start_time = reader.int64();
                        break;
                    case 4:
                        message.roundEndTime = reader.int64();
                        break;
                    case 5:
                        if (!(message.userDatas && message.userDatas.length))
                            message.userDatas = [];
                        message.userDatas.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.loseCoin = reader.int64();
                        break;
                    case 7:
                        message.winCoin = reader.int64();
                        break;
                    case 11:
                        message.gameMode = reader.int32();
                        break;
                    case 8:
                        message.aiMode = reader.int32();
                        break;
                    case 9:
                        message.point = reader.double();
                        break;
                    case 10:
                        message.deadPoint = reader.double();
                        break;
                    case 12:
                        message.deadCount = reader.int32();
                        break;
                    case 13:
                        message.deadModeLeftRound = reader.int32();
                        break;
                    case 14:
                        message.deadModeMaxRound = reader.int64();
                        break;
                    case 18:
                        message.info = $root.pb.GhostGameInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostReadyGoResData;
        })();
    
        pb.GhostReLoginRes = (function() {
    
            /**
             * Properties of a GhostReLoginRes.
             * @memberof pb
             * @interface IGhostReLoginRes
             * @property {number|null} [code] GhostReLoginRes code
             * @property {string|null} [msg] GhostReLoginRes msg
             * @property {pb.IGhostReLoginResData|null} [data] GhostReLoginRes data
             */
    
            /**
             * Constructs a new GhostReLoginRes.
             * @memberof pb
             * @classdesc Represents a GhostReLoginRes.
             * @implements IGhostReLoginRes
             * @constructor
             * @param {pb.IGhostReLoginRes=} [properties] Properties to set
             */
            function GhostReLoginRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostReLoginRes code.
             * @member {number} code
             * @memberof pb.GhostReLoginRes
             * @instance
             */
            GhostReLoginRes.prototype.code = 0;
    
            /**
             * GhostReLoginRes msg.
             * @member {string} msg
             * @memberof pb.GhostReLoginRes
             * @instance
             */
            GhostReLoginRes.prototype.msg = "";
    
            /**
             * GhostReLoginRes data.
             * @member {pb.IGhostReLoginResData|null|undefined} data
             * @memberof pb.GhostReLoginRes
             * @instance
             */
            GhostReLoginRes.prototype.data = null;
    
            /**
             * Creates a new GhostReLoginRes instance using the specified properties.
             * @function create
             * @memberof pb.GhostReLoginRes
             * @static
             * @param {pb.IGhostReLoginRes=} [properties] Properties to set
             * @returns {pb.GhostReLoginRes} GhostReLoginRes instance
             */
            GhostReLoginRes.create = function create(properties) {
                return new GhostReLoginRes(properties);
            };
    
            /**
             * Encodes the specified GhostReLoginRes message. Does not implicitly {@link pb.GhostReLoginRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostReLoginRes
             * @static
             * @param {pb.IGhostReLoginRes} message GhostReLoginRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostReLoginRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.GhostReLoginResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostReLoginRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostReLoginRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostReLoginRes} GhostReLoginRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostReLoginRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostReLoginRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.GhostReLoginResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostReLoginRes;
        })();
    
        pb.GhostReLoginResData = (function() {
    
            /**
             * Properties of a GhostReLoginResData.
             * @memberof pb
             * @interface IGhostReLoginResData
             * @property {string|null} [stage] GhostReLoginResData stage
             * @property {string|null} [curuid] GhostReLoginResData curuid
             * @property {number|null} [dicenum] GhostReLoginResData dicenum
             * @property {number|null} [gameMode] GhostReLoginResData gameMode
             * @property {number|null} [coin] GhostReLoginResData coin
             * @property {pb.IGhostChessBoard|null} [chessboard] GhostReLoginResData chessboard
             * @property {number|null} [roundEndTime] GhostReLoginResData roundEndTime
             * @property {pb.DiceNumResType|null} [dicetype] GhostReLoginResData dicetype
             * @property {Array.<pb.IUserData>|null} [userDatas] GhostReLoginResData userDatas
             * @property {number|null} [loseCoin] GhostReLoginResData loseCoin
             * @property {number|null} [winCoin] GhostReLoginResData winCoin
             * @property {number|null} [aiMode] GhostReLoginResData aiMode
             * @property {number|null} [point] GhostReLoginResData point
             * @property {number|null} [deadPoint] GhostReLoginResData deadPoint
             * @property {number|null} [deadCount] GhostReLoginResData deadCount
             * @property {number|null} [deadModeLeftRound] GhostReLoginResData deadModeLeftRound
             * @property {number|null} [deadModeMaxRound] GhostReLoginResData deadModeMaxRound
             * @property {pb.IGhostGameInfo|null} [info] GhostReLoginResData info
             */
    
            /**
             * Constructs a new GhostReLoginResData.
             * @memberof pb
             * @classdesc Represents a GhostReLoginResData.
             * @implements IGhostReLoginResData
             * @constructor
             * @param {pb.IGhostReLoginResData=} [properties] Properties to set
             */
            function GhostReLoginResData(properties) {
                this.userDatas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostReLoginResData stage.
             * @member {string} stage
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.stage = "";
    
            /**
             * GhostReLoginResData curuid.
             * @member {string} curuid
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.curuid = "";
    
            /**
             * GhostReLoginResData dicenum.
             * @member {number} dicenum
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.dicenum = 0;
    
            /**
             * GhostReLoginResData gameMode.
             * @member {number} gameMode
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.gameMode = 0;
    
            /**
             * GhostReLoginResData coin.
             * @member {number} coin
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReLoginResData chessboard.
             * @member {pb.IGhostChessBoard|null|undefined} chessboard
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.chessboard = null;
    
            /**
             * GhostReLoginResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReLoginResData dicetype.
             * @member {pb.DiceNumResType} dicetype
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.dicetype = 0;
    
            /**
             * GhostReLoginResData userDatas.
             * @member {Array.<pb.IUserData>} userDatas
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.userDatas = $util.emptyArray;
    
            /**
             * GhostReLoginResData loseCoin.
             * @member {number} loseCoin
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.loseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReLoginResData winCoin.
             * @member {number} winCoin
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.winCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReLoginResData aiMode.
             * @member {number} aiMode
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.aiMode = 0;
    
            /**
             * GhostReLoginResData point.
             * @member {number} point
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.point = 0;
    
            /**
             * GhostReLoginResData deadPoint.
             * @member {number} deadPoint
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.deadPoint = 0;
    
            /**
             * GhostReLoginResData deadCount.
             * @member {number} deadCount
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.deadCount = 0;
    
            /**
             * GhostReLoginResData deadModeLeftRound.
             * @member {number} deadModeLeftRound
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.deadModeLeftRound = 0;
    
            /**
             * GhostReLoginResData deadModeMaxRound.
             * @member {number} deadModeMaxRound
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.deadModeMaxRound = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostReLoginResData info.
             * @member {pb.IGhostGameInfo|null|undefined} info
             * @memberof pb.GhostReLoginResData
             * @instance
             */
            GhostReLoginResData.prototype.info = null;
    
            /**
             * Creates a new GhostReLoginResData instance using the specified properties.
             * @function create
             * @memberof pb.GhostReLoginResData
             * @static
             * @param {pb.IGhostReLoginResData=} [properties] Properties to set
             * @returns {pb.GhostReLoginResData} GhostReLoginResData instance
             */
            GhostReLoginResData.create = function create(properties) {
                return new GhostReLoginResData(properties);
            };
    
            /**
             * Encodes the specified GhostReLoginResData message. Does not implicitly {@link pb.GhostReLoginResData.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostReLoginResData
             * @static
             * @param {pb.IGhostReLoginResData} message GhostReLoginResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostReLoginResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stage);
                if (message.curuid != null && Object.hasOwnProperty.call(message, "curuid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.curuid);
                if (message.dicenum != null && Object.hasOwnProperty.call(message, "dicenum"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.dicenum);
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.gameMode);
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.coin);
                if (message.chessboard != null && Object.hasOwnProperty.call(message, "chessboard"))
                    $root.pb.GhostChessBoard.encode(message.chessboard, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.roundEndTime);
                if (message.dicetype != null && Object.hasOwnProperty.call(message, "dicetype"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.dicetype);
                if (message.userDatas != null && message.userDatas.length)
                    for (var i = 0; i < message.userDatas.length; ++i)
                        $root.pb.UserData.encode(message.userDatas[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.loseCoin != null && Object.hasOwnProperty.call(message, "loseCoin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.loseCoin);
                if (message.winCoin != null && Object.hasOwnProperty.call(message, "winCoin"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int64(message.winCoin);
                if (message.aiMode != null && Object.hasOwnProperty.call(message, "aiMode"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.aiMode);
                if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                    writer.uint32(/* id 13, wireType 1 =*/105).double(message.point);
                if (message.deadPoint != null && Object.hasOwnProperty.call(message, "deadPoint"))
                    writer.uint32(/* id 14, wireType 1 =*/113).double(message.deadPoint);
                if (message.deadCount != null && Object.hasOwnProperty.call(message, "deadCount"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.deadCount);
                if (message.deadModeLeftRound != null && Object.hasOwnProperty.call(message, "deadModeLeftRound"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int32(message.deadModeLeftRound);
                if (message.deadModeMaxRound != null && Object.hasOwnProperty.call(message, "deadModeMaxRound"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int64(message.deadModeMaxRound);
                if (message.info != null && Object.hasOwnProperty.call(message, "info"))
                    $root.pb.GhostGameInfo.encode(message.info, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostReLoginResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostReLoginResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostReLoginResData} GhostReLoginResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostReLoginResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostReLoginResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stage = reader.string();
                        break;
                    case 2:
                        message.curuid = reader.string();
                        break;
                    case 3:
                        message.dicenum = reader.int32();
                        break;
                    case 4:
                        message.gameMode = reader.int32();
                        break;
                    case 5:
                        message.coin = reader.int64();
                        break;
                    case 6:
                        message.chessboard = $root.pb.GhostChessBoard.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.roundEndTime = reader.int64();
                        break;
                    case 8:
                        message.dicetype = reader.int32();
                        break;
                    case 9:
                        if (!(message.userDatas && message.userDatas.length))
                            message.userDatas = [];
                        message.userDatas.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        message.loseCoin = reader.int64();
                        break;
                    case 11:
                        message.winCoin = reader.int64();
                        break;
                    case 12:
                        message.aiMode = reader.int32();
                        break;
                    case 13:
                        message.point = reader.double();
                        break;
                    case 14:
                        message.deadPoint = reader.double();
                        break;
                    case 15:
                        message.deadCount = reader.int32();
                        break;
                    case 16:
                        message.deadModeLeftRound = reader.int32();
                        break;
                    case 17:
                        message.deadModeMaxRound = reader.int64();
                        break;
                    case 18:
                        message.info = $root.pb.GhostGameInfo.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostReLoginResData;
        })();
    
        pb.GhostChessBoard = (function() {
    
            /**
             * Properties of a GhostChessBoard.
             * @memberof pb
             * @interface IGhostChessBoard
             * @property {Array.<pb.IGhostAirPortPlane>|null} [airport_planes] GhostChessBoard airport_planes
             * @property {Array.<pb.IGhostPlane>|null} [plane] GhostChessBoard plane
             */
    
            /**
             * Constructs a new GhostChessBoard.
             * @memberof pb
             * @classdesc Represents a GhostChessBoard.
             * @implements IGhostChessBoard
             * @constructor
             * @param {pb.IGhostChessBoard=} [properties] Properties to set
             */
            function GhostChessBoard(properties) {
                this.airport_planes = [];
                this.plane = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostChessBoard airport_planes.
             * @member {Array.<pb.IGhostAirPortPlane>} airport_planes
             * @memberof pb.GhostChessBoard
             * @instance
             */
            GhostChessBoard.prototype.airport_planes = $util.emptyArray;
    
            /**
             * GhostChessBoard plane.
             * @member {Array.<pb.IGhostPlane>} plane
             * @memberof pb.GhostChessBoard
             * @instance
             */
            GhostChessBoard.prototype.plane = $util.emptyArray;
    
            /**
             * Creates a new GhostChessBoard instance using the specified properties.
             * @function create
             * @memberof pb.GhostChessBoard
             * @static
             * @param {pb.IGhostChessBoard=} [properties] Properties to set
             * @returns {pb.GhostChessBoard} GhostChessBoard instance
             */
            GhostChessBoard.create = function create(properties) {
                return new GhostChessBoard(properties);
            };
    
            /**
             * Encodes the specified GhostChessBoard message. Does not implicitly {@link pb.GhostChessBoard.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostChessBoard
             * @static
             * @param {pb.IGhostChessBoard} message GhostChessBoard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostChessBoard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.airport_planes != null && message.airport_planes.length)
                    for (var i = 0; i < message.airport_planes.length; ++i)
                        $root.pb.GhostAirPortPlane.encode(message.airport_planes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.plane != null && message.plane.length)
                    for (var i = 0; i < message.plane.length; ++i)
                        $root.pb.GhostPlane.encode(message.plane[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostChessBoard message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostChessBoard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostChessBoard} GhostChessBoard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostChessBoard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostChessBoard();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.airport_planes && message.airport_planes.length))
                            message.airport_planes = [];
                        message.airport_planes.push($root.pb.GhostAirPortPlane.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.plane && message.plane.length))
                            message.plane = [];
                        message.plane.push($root.pb.GhostPlane.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostChessBoard;
        })();
    
        pb.GhostAirPortPlane = (function() {
    
            /**
             * Properties of a GhostAirPortPlane.
             * @memberof pb
             * @interface IGhostAirPortPlane
             * @property {number|null} [color] GhostAirPortPlane color
             * @property {number|null} [plane] GhostAirPortPlane plane
             * @property {number|null} [rebornLeftRound] GhostAirPortPlane rebornLeftRound
             */
    
            /**
             * Constructs a new GhostAirPortPlane.
             * @memberof pb
             * @classdesc Represents a GhostAirPortPlane.
             * @implements IGhostAirPortPlane
             * @constructor
             * @param {pb.IGhostAirPortPlane=} [properties] Properties to set
             */
            function GhostAirPortPlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostAirPortPlane color.
             * @member {number} color
             * @memberof pb.GhostAirPortPlane
             * @instance
             */
            GhostAirPortPlane.prototype.color = 0;
    
            /**
             * GhostAirPortPlane plane.
             * @member {number} plane
             * @memberof pb.GhostAirPortPlane
             * @instance
             */
            GhostAirPortPlane.prototype.plane = 0;
    
            /**
             * GhostAirPortPlane rebornLeftRound.
             * @member {number} rebornLeftRound
             * @memberof pb.GhostAirPortPlane
             * @instance
             */
            GhostAirPortPlane.prototype.rebornLeftRound = 0;
    
            /**
             * Creates a new GhostAirPortPlane instance using the specified properties.
             * @function create
             * @memberof pb.GhostAirPortPlane
             * @static
             * @param {pb.IGhostAirPortPlane=} [properties] Properties to set
             * @returns {pb.GhostAirPortPlane} GhostAirPortPlane instance
             */
            GhostAirPortPlane.create = function create(properties) {
                return new GhostAirPortPlane(properties);
            };
    
            /**
             * Encodes the specified GhostAirPortPlane message. Does not implicitly {@link pb.GhostAirPortPlane.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostAirPortPlane
             * @static
             * @param {pb.IGhostAirPortPlane} message GhostAirPortPlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostAirPortPlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.rebornLeftRound != null && Object.hasOwnProperty.call(message, "rebornLeftRound"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.rebornLeftRound);
                return writer;
            };
    
            /**
             * Decodes a GhostAirPortPlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostAirPortPlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostAirPortPlane} GhostAirPortPlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostAirPortPlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostAirPortPlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.rebornLeftRound = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostAirPortPlane;
        })();
    
        pb.GhostPlane = (function() {
    
            /**
             * Properties of a GhostPlane.
             * @memberof pb
             * @interface IGhostPlane
             * @property {number|null} [x] GhostPlane x
             * @property {number|null} [y] GhostPlane y
             * @property {number|null} [color] GhostPlane color
             * @property {number|null} [plane] GhostPlane plane
             * @property {number|null} [life] GhostPlane life
             */
    
            /**
             * Constructs a new GhostPlane.
             * @memberof pb
             * @classdesc Represents a GhostPlane.
             * @implements IGhostPlane
             * @constructor
             * @param {pb.IGhostPlane=} [properties] Properties to set
             */
            function GhostPlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostPlane x.
             * @member {number} x
             * @memberof pb.GhostPlane
             * @instance
             */
            GhostPlane.prototype.x = 0;
    
            /**
             * GhostPlane y.
             * @member {number} y
             * @memberof pb.GhostPlane
             * @instance
             */
            GhostPlane.prototype.y = 0;
    
            /**
             * GhostPlane color.
             * @member {number} color
             * @memberof pb.GhostPlane
             * @instance
             */
            GhostPlane.prototype.color = 0;
    
            /**
             * GhostPlane plane.
             * @member {number} plane
             * @memberof pb.GhostPlane
             * @instance
             */
            GhostPlane.prototype.plane = 0;
    
            /**
             * GhostPlane life.
             * @member {number} life
             * @memberof pb.GhostPlane
             * @instance
             */
            GhostPlane.prototype.life = 0;
    
            /**
             * Creates a new GhostPlane instance using the specified properties.
             * @function create
             * @memberof pb.GhostPlane
             * @static
             * @param {pb.IGhostPlane=} [properties] Properties to set
             * @returns {pb.GhostPlane} GhostPlane instance
             */
            GhostPlane.create = function create(properties) {
                return new GhostPlane(properties);
            };
    
            /**
             * Encodes the specified GhostPlane message. Does not implicitly {@link pb.GhostPlane.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostPlane
             * @static
             * @param {pb.IGhostPlane} message GhostPlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostPlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.y);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.plane);
                if (message.life != null && Object.hasOwnProperty.call(message, "life"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.life);
                return writer;
            };
    
            /**
             * Decodes a GhostPlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostPlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostPlane} GhostPlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostPlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostPlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.x = reader.int32();
                        break;
                    case 2:
                        message.y = reader.int32();
                        break;
                    case 3:
                        message.color = reader.int32();
                        break;
                    case 4:
                        message.plane = reader.int32();
                        break;
                    case 5:
                        message.life = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostPlane;
        })();
    
        pb.GhostDiceNumReq = (function() {
    
            /**
             * Properties of a GhostDiceNumReq.
             * @memberof pb
             * @interface IGhostDiceNumReq
             * @property {number|null} [num] GhostDiceNumReq num
             */
    
            /**
             * Constructs a new GhostDiceNumReq.
             * @memberof pb
             * @classdesc Represents a GhostDiceNumReq.
             * @implements IGhostDiceNumReq
             * @constructor
             * @param {pb.IGhostDiceNumReq=} [properties] Properties to set
             */
            function GhostDiceNumReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostDiceNumReq num.
             * @member {number} num
             * @memberof pb.GhostDiceNumReq
             * @instance
             */
            GhostDiceNumReq.prototype.num = 0;
    
            /**
             * Creates a new GhostDiceNumReq instance using the specified properties.
             * @function create
             * @memberof pb.GhostDiceNumReq
             * @static
             * @param {pb.IGhostDiceNumReq=} [properties] Properties to set
             * @returns {pb.GhostDiceNumReq} GhostDiceNumReq instance
             */
            GhostDiceNumReq.create = function create(properties) {
                return new GhostDiceNumReq(properties);
            };
    
            /**
             * Encodes the specified GhostDiceNumReq message. Does not implicitly {@link pb.GhostDiceNumReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostDiceNumReq
             * @static
             * @param {pb.IGhostDiceNumReq} message GhostDiceNumReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostDiceNumReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                return writer;
            };
    
            /**
             * Decodes a GhostDiceNumReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostDiceNumReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostDiceNumReq} GhostDiceNumReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostDiceNumReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostDiceNumReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostDiceNumReq;
        })();
    
        pb.GhostDiceNumRes = (function() {
    
            /**
             * Properties of a GhostDiceNumRes.
             * @memberof pb
             * @interface IGhostDiceNumRes
             * @property {number|null} [code] GhostDiceNumRes code
             * @property {string|null} [msg] GhostDiceNumRes msg
             * @property {pb.IGhostDiceNumData|null} [data] GhostDiceNumRes data
             */
    
            /**
             * Constructs a new GhostDiceNumRes.
             * @memberof pb
             * @classdesc Represents a GhostDiceNumRes.
             * @implements IGhostDiceNumRes
             * @constructor
             * @param {pb.IGhostDiceNumRes=} [properties] Properties to set
             */
            function GhostDiceNumRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostDiceNumRes code.
             * @member {number} code
             * @memberof pb.GhostDiceNumRes
             * @instance
             */
            GhostDiceNumRes.prototype.code = 0;
    
            /**
             * GhostDiceNumRes msg.
             * @member {string} msg
             * @memberof pb.GhostDiceNumRes
             * @instance
             */
            GhostDiceNumRes.prototype.msg = "";
    
            /**
             * GhostDiceNumRes data.
             * @member {pb.IGhostDiceNumData|null|undefined} data
             * @memberof pb.GhostDiceNumRes
             * @instance
             */
            GhostDiceNumRes.prototype.data = null;
    
            /**
             * Creates a new GhostDiceNumRes instance using the specified properties.
             * @function create
             * @memberof pb.GhostDiceNumRes
             * @static
             * @param {pb.IGhostDiceNumRes=} [properties] Properties to set
             * @returns {pb.GhostDiceNumRes} GhostDiceNumRes instance
             */
            GhostDiceNumRes.create = function create(properties) {
                return new GhostDiceNumRes(properties);
            };
    
            /**
             * Encodes the specified GhostDiceNumRes message. Does not implicitly {@link pb.GhostDiceNumRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostDiceNumRes
             * @static
             * @param {pb.IGhostDiceNumRes} message GhostDiceNumRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostDiceNumRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.GhostDiceNumData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostDiceNumRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostDiceNumRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostDiceNumRes} GhostDiceNumRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostDiceNumRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostDiceNumRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.GhostDiceNumData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostDiceNumRes;
        })();
    
        pb.GhostDiceNumData = (function() {
    
            /**
             * Properties of a GhostDiceNumData.
             * @memberof pb
             * @interface IGhostDiceNumData
             * @property {number|null} [num] GhostDiceNumData num
             * @property {number|null} [roundEndTime] GhostDiceNumData roundEndTime
             * @property {pb.DiceNumResType|null} [type] GhostDiceNumData type
             * @property {string|null} [uid] GhostDiceNumData uid
             */
    
            /**
             * Constructs a new GhostDiceNumData.
             * @memberof pb
             * @classdesc Represents a GhostDiceNumData.
             * @implements IGhostDiceNumData
             * @constructor
             * @param {pb.IGhostDiceNumData=} [properties] Properties to set
             */
            function GhostDiceNumData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostDiceNumData num.
             * @member {number} num
             * @memberof pb.GhostDiceNumData
             * @instance
             */
            GhostDiceNumData.prototype.num = 0;
    
            /**
             * GhostDiceNumData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.GhostDiceNumData
             * @instance
             */
            GhostDiceNumData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostDiceNumData type.
             * @member {pb.DiceNumResType} type
             * @memberof pb.GhostDiceNumData
             * @instance
             */
            GhostDiceNumData.prototype.type = 0;
    
            /**
             * GhostDiceNumData uid.
             * @member {string} uid
             * @memberof pb.GhostDiceNumData
             * @instance
             */
            GhostDiceNumData.prototype.uid = "";
    
            /**
             * Creates a new GhostDiceNumData instance using the specified properties.
             * @function create
             * @memberof pb.GhostDiceNumData
             * @static
             * @param {pb.IGhostDiceNumData=} [properties] Properties to set
             * @returns {pb.GhostDiceNumData} GhostDiceNumData instance
             */
            GhostDiceNumData.create = function create(properties) {
                return new GhostDiceNumData(properties);
            };
    
            /**
             * Encodes the specified GhostDiceNumData message. Does not implicitly {@link pb.GhostDiceNumData.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostDiceNumData
             * @static
             * @param {pb.IGhostDiceNumData} message GhostDiceNumData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostDiceNumData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roundEndTime);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.uid);
                return writer;
            };
    
            /**
             * Decodes a GhostDiceNumData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostDiceNumData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostDiceNumData} GhostDiceNumData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostDiceNumData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostDiceNumData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.roundEndTime = reader.int64();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.uid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostDiceNumData;
        })();
    
        pb.GhostMoveReq = (function() {
    
            /**
             * Properties of a GhostMoveReq.
             * @memberof pb
             * @interface IGhostMoveReq
             * @property {number|null} [color] GhostMoveReq color
             * @property {number|null} [plane] GhostMoveReq plane
             * @property {pb.MoveType|null} [type] GhostMoveReq type
             * @property {number|null} [diceNum] GhostMoveReq diceNum
             */
    
            /**
             * Constructs a new GhostMoveReq.
             * @memberof pb
             * @classdesc Represents a GhostMoveReq.
             * @implements IGhostMoveReq
             * @constructor
             * @param {pb.IGhostMoveReq=} [properties] Properties to set
             */
            function GhostMoveReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostMoveReq color.
             * @member {number} color
             * @memberof pb.GhostMoveReq
             * @instance
             */
            GhostMoveReq.prototype.color = 0;
    
            /**
             * GhostMoveReq plane.
             * @member {number} plane
             * @memberof pb.GhostMoveReq
             * @instance
             */
            GhostMoveReq.prototype.plane = 0;
    
            /**
             * GhostMoveReq type.
             * @member {pb.MoveType} type
             * @memberof pb.GhostMoveReq
             * @instance
             */
            GhostMoveReq.prototype.type = 0;
    
            /**
             * GhostMoveReq diceNum.
             * @member {number} diceNum
             * @memberof pb.GhostMoveReq
             * @instance
             */
            GhostMoveReq.prototype.diceNum = 0;
    
            /**
             * Creates a new GhostMoveReq instance using the specified properties.
             * @function create
             * @memberof pb.GhostMoveReq
             * @static
             * @param {pb.IGhostMoveReq=} [properties] Properties to set
             * @returns {pb.GhostMoveReq} GhostMoveReq instance
             */
            GhostMoveReq.create = function create(properties) {
                return new GhostMoveReq(properties);
            };
    
            /**
             * Encodes the specified GhostMoveReq message. Does not implicitly {@link pb.GhostMoveReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostMoveReq
             * @static
             * @param {pb.IGhostMoveReq} message GhostMoveReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostMoveReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.diceNum != null && Object.hasOwnProperty.call(message, "diceNum"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.diceNum);
                return writer;
            };
    
            /**
             * Decodes a GhostMoveReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostMoveReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostMoveReq} GhostMoveReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostMoveReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostMoveReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.diceNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostMoveReq;
        })();
    
        pb.GhostCrashPlane = (function() {
    
            /**
             * Properties of a GhostCrashPlane.
             * @memberof pb
             * @interface IGhostCrashPlane
             * @property {number|null} [color] GhostCrashPlane color
             * @property {number|null} [plane] GhostCrashPlane plane
             * @property {number|null} [x] GhostCrashPlane x
             * @property {number|null} [y] GhostCrashPlane y
             * @property {number|null} [life] GhostCrashPlane life
             */
    
            /**
             * Constructs a new GhostCrashPlane.
             * @memberof pb
             * @classdesc Represents a GhostCrashPlane.
             * @implements IGhostCrashPlane
             * @constructor
             * @param {pb.IGhostCrashPlane=} [properties] Properties to set
             */
            function GhostCrashPlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostCrashPlane color.
             * @member {number} color
             * @memberof pb.GhostCrashPlane
             * @instance
             */
            GhostCrashPlane.prototype.color = 0;
    
            /**
             * GhostCrashPlane plane.
             * @member {number} plane
             * @memberof pb.GhostCrashPlane
             * @instance
             */
            GhostCrashPlane.prototype.plane = 0;
    
            /**
             * GhostCrashPlane x.
             * @member {number} x
             * @memberof pb.GhostCrashPlane
             * @instance
             */
            GhostCrashPlane.prototype.x = 0;
    
            /**
             * GhostCrashPlane y.
             * @member {number} y
             * @memberof pb.GhostCrashPlane
             * @instance
             */
            GhostCrashPlane.prototype.y = 0;
    
            /**
             * GhostCrashPlane life.
             * @member {number} life
             * @memberof pb.GhostCrashPlane
             * @instance
             */
            GhostCrashPlane.prototype.life = 0;
    
            /**
             * Creates a new GhostCrashPlane instance using the specified properties.
             * @function create
             * @memberof pb.GhostCrashPlane
             * @static
             * @param {pb.IGhostCrashPlane=} [properties] Properties to set
             * @returns {pb.GhostCrashPlane} GhostCrashPlane instance
             */
            GhostCrashPlane.create = function create(properties) {
                return new GhostCrashPlane(properties);
            };
    
            /**
             * Encodes the specified GhostCrashPlane message. Does not implicitly {@link pb.GhostCrashPlane.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostCrashPlane
             * @static
             * @param {pb.IGhostCrashPlane} message GhostCrashPlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostCrashPlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.y);
                if (message.life != null && Object.hasOwnProperty.call(message, "life"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.life);
                return writer;
            };
    
            /**
             * Decodes a GhostCrashPlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostCrashPlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostCrashPlane} GhostCrashPlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostCrashPlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostCrashPlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.x = reader.int32();
                        break;
                    case 4:
                        message.y = reader.int32();
                        break;
                    case 5:
                        message.life = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostCrashPlane;
        })();
    
        pb.GhostMoveRes = (function() {
    
            /**
             * Properties of a GhostMoveRes.
             * @memberof pb
             * @interface IGhostMoveRes
             * @property {number|null} [code] GhostMoveRes code
             * @property {string|null} [msg] GhostMoveRes msg
             * @property {pb.IGhostMoveResData|null} [data] GhostMoveRes data
             */
    
            /**
             * Constructs a new GhostMoveRes.
             * @memberof pb
             * @classdesc Represents a GhostMoveRes.
             * @implements IGhostMoveRes
             * @constructor
             * @param {pb.IGhostMoveRes=} [properties] Properties to set
             */
            function GhostMoveRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostMoveRes code.
             * @member {number} code
             * @memberof pb.GhostMoveRes
             * @instance
             */
            GhostMoveRes.prototype.code = 0;
    
            /**
             * GhostMoveRes msg.
             * @member {string} msg
             * @memberof pb.GhostMoveRes
             * @instance
             */
            GhostMoveRes.prototype.msg = "";
    
            /**
             * GhostMoveRes data.
             * @member {pb.IGhostMoveResData|null|undefined} data
             * @memberof pb.GhostMoveRes
             * @instance
             */
            GhostMoveRes.prototype.data = null;
    
            /**
             * Creates a new GhostMoveRes instance using the specified properties.
             * @function create
             * @memberof pb.GhostMoveRes
             * @static
             * @param {pb.IGhostMoveRes=} [properties] Properties to set
             * @returns {pb.GhostMoveRes} GhostMoveRes instance
             */
            GhostMoveRes.create = function create(properties) {
                return new GhostMoveRes(properties);
            };
    
            /**
             * Encodes the specified GhostMoveRes message. Does not implicitly {@link pb.GhostMoveRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostMoveRes
             * @static
             * @param {pb.IGhostMoveRes} message GhostMoveRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostMoveRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.GhostMoveResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostMoveRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostMoveRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostMoveRes} GhostMoveRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostMoveRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostMoveRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.GhostMoveResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostMoveRes;
        })();
    
        pb.GhostMoveResData = (function() {
    
            /**
             * Properties of a GhostMoveResData.
             * @memberof pb
             * @interface IGhostMoveResData
             * @property {string|null} [uid] GhostMoveResData uid
             * @property {pb.IGhostPlane|null} [plane] GhostMoveResData plane
             * @property {pb.IGhostAirPortPlane|null} [airport_plane] GhostMoveResData airport_plane
             * @property {pb.MoveType|null} [type] GhostMoveResData type
             * @property {Array.<pb.IGhostCrashPlane>|null} [crashPlanes] GhostMoveResData crashPlanes
             * @property {string|null} [next_uid] GhostMoveResData next_uid
             * @property {number|null} [roundEndTime] GhostMoveResData roundEndTime
             * @property {number|null} [diceNum] GhostMoveResData diceNum
             * @property {number|null} [aiMode] GhostMoveResData aiMode
             * @property {number|null} [point] GhostMoveResData point
             * @property {number|null} [deadPoint] GhostMoveResData deadPoint
             * @property {number|null} [deadCount] GhostMoveResData deadCount
             * @property {number|null} [deadModeLeftRound] GhostMoveResData deadModeLeftRound
             * @property {number|null} [deadModeMaxRound] GhostMoveResData deadModeMaxRound
             * @property {Array.<pb.IGhostPlane>|null} [rebornPlanes] GhostMoveResData rebornPlanes
             * @property {pb.IGhostPlane|null} [planeNew] GhostMoveResData planeNew
             */
    
            /**
             * Constructs a new GhostMoveResData.
             * @memberof pb
             * @classdesc Represents a GhostMoveResData.
             * @implements IGhostMoveResData
             * @constructor
             * @param {pb.IGhostMoveResData=} [properties] Properties to set
             */
            function GhostMoveResData(properties) {
                this.crashPlanes = [];
                this.rebornPlanes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostMoveResData uid.
             * @member {string} uid
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.uid = "";
    
            /**
             * GhostMoveResData plane.
             * @member {pb.IGhostPlane|null|undefined} plane
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.plane = null;
    
            /**
             * GhostMoveResData airport_plane.
             * @member {pb.IGhostAirPortPlane|null|undefined} airport_plane
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.airport_plane = null;
    
            /**
             * GhostMoveResData type.
             * @member {pb.MoveType} type
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.type = 0;
    
            /**
             * GhostMoveResData crashPlanes.
             * @member {Array.<pb.IGhostCrashPlane>} crashPlanes
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.crashPlanes = $util.emptyArray;
    
            /**
             * GhostMoveResData next_uid.
             * @member {string} next_uid
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.next_uid = "";
    
            /**
             * GhostMoveResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostMoveResData diceNum.
             * @member {number} diceNum
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.diceNum = 0;
    
            /**
             * GhostMoveResData aiMode.
             * @member {number} aiMode
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.aiMode = 0;
    
            /**
             * GhostMoveResData point.
             * @member {number} point
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.point = 0;
    
            /**
             * GhostMoveResData deadPoint.
             * @member {number} deadPoint
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.deadPoint = 0;
    
            /**
             * GhostMoveResData deadCount.
             * @member {number} deadCount
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.deadCount = 0;
    
            /**
             * GhostMoveResData deadModeLeftRound.
             * @member {number} deadModeLeftRound
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.deadModeLeftRound = 0;
    
            /**
             * GhostMoveResData deadModeMaxRound.
             * @member {number} deadModeMaxRound
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.deadModeMaxRound = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostMoveResData rebornPlanes.
             * @member {Array.<pb.IGhostPlane>} rebornPlanes
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.rebornPlanes = $util.emptyArray;
    
            /**
             * GhostMoveResData planeNew.
             * @member {pb.IGhostPlane|null|undefined} planeNew
             * @memberof pb.GhostMoveResData
             * @instance
             */
            GhostMoveResData.prototype.planeNew = null;
    
            /**
             * Creates a new GhostMoveResData instance using the specified properties.
             * @function create
             * @memberof pb.GhostMoveResData
             * @static
             * @param {pb.IGhostMoveResData=} [properties] Properties to set
             * @returns {pb.GhostMoveResData} GhostMoveResData instance
             */
            GhostMoveResData.create = function create(properties) {
                return new GhostMoveResData(properties);
            };
    
            /**
             * Encodes the specified GhostMoveResData message. Does not implicitly {@link pb.GhostMoveResData.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostMoveResData
             * @static
             * @param {pb.IGhostMoveResData} message GhostMoveResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostMoveResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    $root.pb.GhostPlane.encode(message.plane, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.airport_plane != null && Object.hasOwnProperty.call(message, "airport_plane"))
                    $root.pb.GhostAirPortPlane.encode(message.airport_plane, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                if (message.crashPlanes != null && message.crashPlanes.length)
                    for (var i = 0; i < message.crashPlanes.length; ++i)
                        $root.pb.GhostCrashPlane.encode(message.crashPlanes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.next_uid != null && Object.hasOwnProperty.call(message, "next_uid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.next_uid);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.roundEndTime);
                if (message.diceNum != null && Object.hasOwnProperty.call(message, "diceNum"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.diceNum);
                if (message.rebornPlanes != null && message.rebornPlanes.length)
                    for (var i = 0; i < message.rebornPlanes.length; ++i)
                        $root.pb.GhostPlane.encode(message.rebornPlanes[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.aiMode != null && Object.hasOwnProperty.call(message, "aiMode"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.aiMode);
                if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                    writer.uint32(/* id 13, wireType 1 =*/105).double(message.point);
                if (message.deadPoint != null && Object.hasOwnProperty.call(message, "deadPoint"))
                    writer.uint32(/* id 14, wireType 1 =*/113).double(message.deadPoint);
                if (message.deadCount != null && Object.hasOwnProperty.call(message, "deadCount"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.deadCount);
                if (message.deadModeLeftRound != null && Object.hasOwnProperty.call(message, "deadModeLeftRound"))
                    writer.uint32(/* id 16, wireType 0 =*/128).int32(message.deadModeLeftRound);
                if (message.deadModeMaxRound != null && Object.hasOwnProperty.call(message, "deadModeMaxRound"))
                    writer.uint32(/* id 17, wireType 0 =*/136).int64(message.deadModeMaxRound);
                if (message.planeNew != null && Object.hasOwnProperty.call(message, "planeNew"))
                    $root.pb.GhostPlane.encode(message.planeNew, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostMoveResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostMoveResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostMoveResData} GhostMoveResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostMoveResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostMoveResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.plane = $root.pb.GhostPlane.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.airport_plane = $root.pb.GhostAirPortPlane.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    case 5:
                        if (!(message.crashPlanes && message.crashPlanes.length))
                            message.crashPlanes = [];
                        message.crashPlanes.push($root.pb.GhostCrashPlane.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.next_uid = reader.string();
                        break;
                    case 7:
                        message.roundEndTime = reader.int64();
                        break;
                    case 8:
                        message.diceNum = reader.int32();
                        break;
                    case 12:
                        message.aiMode = reader.int32();
                        break;
                    case 13:
                        message.point = reader.double();
                        break;
                    case 14:
                        message.deadPoint = reader.double();
                        break;
                    case 15:
                        message.deadCount = reader.int32();
                        break;
                    case 16:
                        message.deadModeLeftRound = reader.int32();
                        break;
                    case 17:
                        message.deadModeMaxRound = reader.int64();
                        break;
                    case 9:
                        if (!(message.rebornPlanes && message.rebornPlanes.length))
                            message.rebornPlanes = [];
                        message.rebornPlanes.push($root.pb.GhostPlane.decode(reader, reader.uint32()));
                        break;
                    case 18:
                        message.planeNew = $root.pb.GhostPlane.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostMoveResData;
        })();
    
        pb.GhostSettingReq = (function() {
    
            /**
             * Properties of a GhostSettingReq.
             * @memberof pb
             * @interface IGhostSettingReq
             */
    
            /**
             * Constructs a new GhostSettingReq.
             * @memberof pb
             * @classdesc Represents a GhostSettingReq.
             * @implements IGhostSettingReq
             * @constructor
             * @param {pb.IGhostSettingReq=} [properties] Properties to set
             */
            function GhostSettingReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GhostSettingReq instance using the specified properties.
             * @function create
             * @memberof pb.GhostSettingReq
             * @static
             * @param {pb.IGhostSettingReq=} [properties] Properties to set
             * @returns {pb.GhostSettingReq} GhostSettingReq instance
             */
            GhostSettingReq.create = function create(properties) {
                return new GhostSettingReq(properties);
            };
    
            /**
             * Encodes the specified GhostSettingReq message. Does not implicitly {@link pb.GhostSettingReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostSettingReq
             * @static
             * @param {pb.IGhostSettingReq} message GhostSettingReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostSettingReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GhostSettingReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostSettingReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostSettingReq} GhostSettingReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostSettingReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostSettingReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostSettingReq;
        })();
    
        pb.GhostSettingRes = (function() {
    
            /**
             * Properties of a GhostSettingRes.
             * @memberof pb
             * @interface IGhostSettingRes
             * @property {number|null} [ticket] GhostSettingRes ticket
             * @property {number|null} [nextTimeToRefreshTicket] GhostSettingRes nextTimeToRefreshTicket
             * @property {number|null} [freeTicketNum] GhostSettingRes freeTicketNum
             * @property {Array.<pb.IGhostInfo>|null} [sets] GhostSettingRes sets
             */
    
            /**
             * Constructs a new GhostSettingRes.
             * @memberof pb
             * @classdesc Represents a GhostSettingRes.
             * @implements IGhostSettingRes
             * @constructor
             * @param {pb.IGhostSettingRes=} [properties] Properties to set
             */
            function GhostSettingRes(properties) {
                this.sets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostSettingRes ticket.
             * @member {number} ticket
             * @memberof pb.GhostSettingRes
             * @instance
             */
            GhostSettingRes.prototype.ticket = 0;
    
            /**
             * GhostSettingRes nextTimeToRefreshTicket.
             * @member {number} nextTimeToRefreshTicket
             * @memberof pb.GhostSettingRes
             * @instance
             */
            GhostSettingRes.prototype.nextTimeToRefreshTicket = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * GhostSettingRes freeTicketNum.
             * @member {number} freeTicketNum
             * @memberof pb.GhostSettingRes
             * @instance
             */
            GhostSettingRes.prototype.freeTicketNum = 0;
    
            /**
             * GhostSettingRes sets.
             * @member {Array.<pb.IGhostInfo>} sets
             * @memberof pb.GhostSettingRes
             * @instance
             */
            GhostSettingRes.prototype.sets = $util.emptyArray;
    
            /**
             * Creates a new GhostSettingRes instance using the specified properties.
             * @function create
             * @memberof pb.GhostSettingRes
             * @static
             * @param {pb.IGhostSettingRes=} [properties] Properties to set
             * @returns {pb.GhostSettingRes} GhostSettingRes instance
             */
            GhostSettingRes.create = function create(properties) {
                return new GhostSettingRes(properties);
            };
    
            /**
             * Encodes the specified GhostSettingRes message. Does not implicitly {@link pb.GhostSettingRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostSettingRes
             * @static
             * @param {pb.IGhostSettingRes} message GhostSettingRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostSettingRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ticket);
                if (message.nextTimeToRefreshTicket != null && Object.hasOwnProperty.call(message, "nextTimeToRefreshTicket"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.nextTimeToRefreshTicket);
                if (message.freeTicketNum != null && Object.hasOwnProperty.call(message, "freeTicketNum"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.freeTicketNum);
                if (message.sets != null && message.sets.length)
                    for (var i = 0; i < message.sets.length; ++i)
                        $root.pb.GhostInfo.encode(message.sets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostSettingRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostSettingRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostSettingRes} GhostSettingRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostSettingRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostSettingRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ticket = reader.int32();
                        break;
                    case 2:
                        message.nextTimeToRefreshTicket = reader.int64();
                        break;
                    case 3:
                        message.freeTicketNum = reader.int32();
                        break;
                    case 5:
                        if (!(message.sets && message.sets.length))
                            message.sets = [];
                        message.sets.push($root.pb.GhostInfo.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostSettingRes;
        })();
    
        pb.GhostInfo = (function() {
    
            /**
             * Properties of a GhostInfo.
             * @memberof pb
             * @interface IGhostInfo
             * @property {number|null} [coinChange] GhostInfo coinChange
             * @property {number|null} [hard] GhostInfo hard
             * @property {Array.<pb.IRewardItem>|null} [awards] GhostInfo awards
             */
    
            /**
             * Constructs a new GhostInfo.
             * @memberof pb
             * @classdesc Represents a GhostInfo.
             * @implements IGhostInfo
             * @constructor
             * @param {pb.IGhostInfo=} [properties] Properties to set
             */
            function GhostInfo(properties) {
                this.awards = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostInfo coinChange.
             * @member {number} coinChange
             * @memberof pb.GhostInfo
             * @instance
             */
            GhostInfo.prototype.coinChange = 0;
    
            /**
             * GhostInfo hard.
             * @member {number} hard
             * @memberof pb.GhostInfo
             * @instance
             */
            GhostInfo.prototype.hard = 0;
    
            /**
             * GhostInfo awards.
             * @member {Array.<pb.IRewardItem>} awards
             * @memberof pb.GhostInfo
             * @instance
             */
            GhostInfo.prototype.awards = $util.emptyArray;
    
            /**
             * Creates a new GhostInfo instance using the specified properties.
             * @function create
             * @memberof pb.GhostInfo
             * @static
             * @param {pb.IGhostInfo=} [properties] Properties to set
             * @returns {pb.GhostInfo} GhostInfo instance
             */
            GhostInfo.create = function create(properties) {
                return new GhostInfo(properties);
            };
    
            /**
             * Encodes the specified GhostInfo message. Does not implicitly {@link pb.GhostInfo.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostInfo
             * @static
             * @param {pb.IGhostInfo} message GhostInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.coinChange != null && Object.hasOwnProperty.call(message, "coinChange"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.coinChange);
                if (message.hard != null && Object.hasOwnProperty.call(message, "hard"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.hard);
                if (message.awards != null && message.awards.length)
                    for (var i = 0; i < message.awards.length; ++i)
                        $root.pb.RewardItem.encode(message.awards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GhostInfo message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostInfo} GhostInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.coinChange = reader.int32();
                        break;
                    case 2:
                        message.hard = reader.int32();
                        break;
                    case 3:
                        if (!(message.awards && message.awards.length))
                            message.awards = [];
                        message.awards.push($root.pb.RewardItem.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostInfo;
        })();
    
        pb.GhostGameInfo = (function() {
    
            /**
             * Properties of a GhostGameInfo.
             * @memberof pb
             * @interface IGhostGameInfo
             * @property {number|null} [ghostWinScore] GhostGameInfo ghostWinScore
             * @property {number|null} [userWinScore] GhostGameInfo userWinScore
             * @property {number|null} [ghostLife] GhostGameInfo ghostLife
             * @property {number|null} [infoFinalPosScore] GhostGameInfo infoFinalPosScore
             */
    
            /**
             * Constructs a new GhostGameInfo.
             * @memberof pb
             * @classdesc Represents a GhostGameInfo.
             * @implements IGhostGameInfo
             * @constructor
             * @param {pb.IGhostGameInfo=} [properties] Properties to set
             */
            function GhostGameInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GhostGameInfo ghostWinScore.
             * @member {number} ghostWinScore
             * @memberof pb.GhostGameInfo
             * @instance
             */
            GhostGameInfo.prototype.ghostWinScore = 0;
    
            /**
             * GhostGameInfo userWinScore.
             * @member {number} userWinScore
             * @memberof pb.GhostGameInfo
             * @instance
             */
            GhostGameInfo.prototype.userWinScore = 0;
    
            /**
             * GhostGameInfo ghostLife.
             * @member {number} ghostLife
             * @memberof pb.GhostGameInfo
             * @instance
             */
            GhostGameInfo.prototype.ghostLife = 0;
    
            /**
             * GhostGameInfo infoFinalPosScore.
             * @member {number} infoFinalPosScore
             * @memberof pb.GhostGameInfo
             * @instance
             */
            GhostGameInfo.prototype.infoFinalPosScore = 0;
    
            /**
             * Creates a new GhostGameInfo instance using the specified properties.
             * @function create
             * @memberof pb.GhostGameInfo
             * @static
             * @param {pb.IGhostGameInfo=} [properties] Properties to set
             * @returns {pb.GhostGameInfo} GhostGameInfo instance
             */
            GhostGameInfo.create = function create(properties) {
                return new GhostGameInfo(properties);
            };
    
            /**
             * Encodes the specified GhostGameInfo message. Does not implicitly {@link pb.GhostGameInfo.verify|verify} messages.
             * @function encode
             * @memberof pb.GhostGameInfo
             * @static
             * @param {pb.IGhostGameInfo} message GhostGameInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GhostGameInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ghostWinScore != null && Object.hasOwnProperty.call(message, "ghostWinScore"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ghostWinScore);
                if (message.userWinScore != null && Object.hasOwnProperty.call(message, "userWinScore"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.userWinScore);
                if (message.ghostLife != null && Object.hasOwnProperty.call(message, "ghostLife"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ghostLife);
                if (message.infoFinalPosScore != null && Object.hasOwnProperty.call(message, "infoFinalPosScore"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.infoFinalPosScore);
                return writer;
            };
    
            /**
             * Decodes a GhostGameInfo message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GhostGameInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GhostGameInfo} GhostGameInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GhostGameInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GhostGameInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ghostWinScore = reader.int32();
                        break;
                    case 2:
                        message.userWinScore = reader.int32();
                        break;
                    case 3:
                        message.ghostLife = reader.int32();
                        break;
                    case 4:
                        message.infoFinalPosScore = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GhostGameInfo;
        })();
    
        pb.MatchSixModeReq = (function() {
    
            /**
             * Properties of a MatchSixModeReq.
             * @memberof pb
             * @interface IMatchSixModeReq
             * @property {number|null} [grade] MatchSixModeReq grade
             */
    
            /**
             * Constructs a new MatchSixModeReq.
             * @memberof pb
             * @classdesc Represents a MatchSixModeReq.
             * @implements IMatchSixModeReq
             * @constructor
             * @param {pb.IMatchSixModeReq=} [properties] Properties to set
             */
            function MatchSixModeReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchSixModeReq grade.
             * @member {number} grade
             * @memberof pb.MatchSixModeReq
             * @instance
             */
            MatchSixModeReq.prototype.grade = 0;
    
            /**
             * Creates a new MatchSixModeReq instance using the specified properties.
             * @function create
             * @memberof pb.MatchSixModeReq
             * @static
             * @param {pb.IMatchSixModeReq=} [properties] Properties to set
             * @returns {pb.MatchSixModeReq} MatchSixModeReq instance
             */
            MatchSixModeReq.create = function create(properties) {
                return new MatchSixModeReq(properties);
            };
    
            /**
             * Encodes the specified MatchSixModeReq message. Does not implicitly {@link pb.MatchSixModeReq.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchSixModeReq
             * @static
             * @param {pb.IMatchSixModeReq} message MatchSixModeReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchSixModeReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grade);
                return writer;
            };
    
            /**
             * Decodes a MatchSixModeReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchSixModeReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchSixModeReq} MatchSixModeReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchSixModeReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchSixModeReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grade = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchSixModeReq;
        })();
    
        pb.MatchSixModeRes = (function() {
    
            /**
             * Properties of a MatchSixModeRes.
             * @memberof pb
             * @interface IMatchSixModeRes
             * @property {number|null} [grade] MatchSixModeRes grade
             * @property {number|null} [code] MatchSixModeRes code
             */
    
            /**
             * Constructs a new MatchSixModeRes.
             * @memberof pb
             * @classdesc Represents a MatchSixModeRes.
             * @implements IMatchSixModeRes
             * @constructor
             * @param {pb.IMatchSixModeRes=} [properties] Properties to set
             */
            function MatchSixModeRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchSixModeRes grade.
             * @member {number} grade
             * @memberof pb.MatchSixModeRes
             * @instance
             */
            MatchSixModeRes.prototype.grade = 0;
    
            /**
             * MatchSixModeRes code.
             * @member {number} code
             * @memberof pb.MatchSixModeRes
             * @instance
             */
            MatchSixModeRes.prototype.code = 0;
    
            /**
             * Creates a new MatchSixModeRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchSixModeRes
             * @static
             * @param {pb.IMatchSixModeRes=} [properties] Properties to set
             * @returns {pb.MatchSixModeRes} MatchSixModeRes instance
             */
            MatchSixModeRes.create = function create(properties) {
                return new MatchSixModeRes(properties);
            };
    
            /**
             * Encodes the specified MatchSixModeRes message. Does not implicitly {@link pb.MatchSixModeRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchSixModeRes
             * @static
             * @param {pb.IMatchSixModeRes} message MatchSixModeRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchSixModeRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.grade);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a MatchSixModeRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchSixModeRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchSixModeRes} MatchSixModeRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchSixModeRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchSixModeRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.grade = reader.int32();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchSixModeRes;
        })();
    
        pb.MatchSixModeSuccessRes = (function() {
    
            /**
             * Properties of a MatchSixModeSuccessRes.
             * @memberof pb
             * @interface IMatchSixModeSuccessRes
             * @property {number|null} [code] MatchSixModeSuccessRes code
             * @property {string|null} [roomId] MatchSixModeSuccessRes roomId
             * @property {number|null} [timestamp] MatchSixModeSuccessRes timestamp
             * @property {string|null} [opt] MatchSixModeSuccessRes opt
             * @property {string|null} [sign] MatchSixModeSuccessRes sign
             * @property {number|null} [grade] MatchSixModeSuccessRes grade
             * @property {string|null} [sn] MatchSixModeSuccessRes sn
             */
    
            /**
             * Constructs a new MatchSixModeSuccessRes.
             * @memberof pb
             * @classdesc Represents a MatchSixModeSuccessRes.
             * @implements IMatchSixModeSuccessRes
             * @constructor
             * @param {pb.IMatchSixModeSuccessRes=} [properties] Properties to set
             */
            function MatchSixModeSuccessRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * MatchSixModeSuccessRes code.
             * @member {number} code
             * @memberof pb.MatchSixModeSuccessRes
             * @instance
             */
            MatchSixModeSuccessRes.prototype.code = 0;
    
            /**
             * MatchSixModeSuccessRes roomId.
             * @member {string} roomId
             * @memberof pb.MatchSixModeSuccessRes
             * @instance
             */
            MatchSixModeSuccessRes.prototype.roomId = "";
    
            /**
             * MatchSixModeSuccessRes timestamp.
             * @member {number} timestamp
             * @memberof pb.MatchSixModeSuccessRes
             * @instance
             */
            MatchSixModeSuccessRes.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * MatchSixModeSuccessRes opt.
             * @member {string} opt
             * @memberof pb.MatchSixModeSuccessRes
             * @instance
             */
            MatchSixModeSuccessRes.prototype.opt = "";
    
            /**
             * MatchSixModeSuccessRes sign.
             * @member {string} sign
             * @memberof pb.MatchSixModeSuccessRes
             * @instance
             */
            MatchSixModeSuccessRes.prototype.sign = "";
    
            /**
             * MatchSixModeSuccessRes grade.
             * @member {number} grade
             * @memberof pb.MatchSixModeSuccessRes
             * @instance
             */
            MatchSixModeSuccessRes.prototype.grade = 0;
    
            /**
             * MatchSixModeSuccessRes sn.
             * @member {string} sn
             * @memberof pb.MatchSixModeSuccessRes
             * @instance
             */
            MatchSixModeSuccessRes.prototype.sn = "";
    
            /**
             * Creates a new MatchSixModeSuccessRes instance using the specified properties.
             * @function create
             * @memberof pb.MatchSixModeSuccessRes
             * @static
             * @param {pb.IMatchSixModeSuccessRes=} [properties] Properties to set
             * @returns {pb.MatchSixModeSuccessRes} MatchSixModeSuccessRes instance
             */
            MatchSixModeSuccessRes.create = function create(properties) {
                return new MatchSixModeSuccessRes(properties);
            };
    
            /**
             * Encodes the specified MatchSixModeSuccessRes message. Does not implicitly {@link pb.MatchSixModeSuccessRes.verify|verify} messages.
             * @function encode
             * @memberof pb.MatchSixModeSuccessRes
             * @static
             * @param {pb.IMatchSixModeSuccessRes} message MatchSixModeSuccessRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MatchSixModeSuccessRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.roomId != null && Object.hasOwnProperty.call(message, "roomId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roomId);
                if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.timestamp);
                if (message.opt != null && Object.hasOwnProperty.call(message, "opt"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.opt);
                if (message.sign != null && Object.hasOwnProperty.call(message, "sign"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.sign);
                if (message.grade != null && Object.hasOwnProperty.call(message, "grade"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.grade);
                if (message.sn != null && Object.hasOwnProperty.call(message, "sn"))
                    writer.uint32(/* id 15, wireType 2 =*/122).string(message.sn);
                return writer;
            };
    
            /**
             * Decodes a MatchSixModeSuccessRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.MatchSixModeSuccessRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.MatchSixModeSuccessRes} MatchSixModeSuccessRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MatchSixModeSuccessRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchSixModeSuccessRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.roomId = reader.string();
                        break;
                    case 3:
                        message.timestamp = reader.int64();
                        break;
                    case 4:
                        message.opt = reader.string();
                        break;
                    case 5:
                        message.sign = reader.string();
                        break;
                    case 7:
                        message.grade = reader.int32();
                        break;
                    case 15:
                        message.sn = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return MatchSixModeSuccessRes;
        })();
    
        pb.SixModeReadyGoRes = (function() {
    
            /**
             * Properties of a SixModeReadyGoRes.
             * @memberof pb
             * @interface ISixModeReadyGoRes
             * @property {number|null} [code] SixModeReadyGoRes code
             * @property {string|null} [msg] SixModeReadyGoRes msg
             * @property {pb.ISixModeReadyGoResData|null} [data] SixModeReadyGoRes data
             */
    
            /**
             * Constructs a new SixModeReadyGoRes.
             * @memberof pb
             * @classdesc Represents a SixModeReadyGoRes.
             * @implements ISixModeReadyGoRes
             * @constructor
             * @param {pb.ISixModeReadyGoRes=} [properties] Properties to set
             */
            function SixModeReadyGoRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeReadyGoRes code.
             * @member {number} code
             * @memberof pb.SixModeReadyGoRes
             * @instance
             */
            SixModeReadyGoRes.prototype.code = 0;
    
            /**
             * SixModeReadyGoRes msg.
             * @member {string} msg
             * @memberof pb.SixModeReadyGoRes
             * @instance
             */
            SixModeReadyGoRes.prototype.msg = "";
    
            /**
             * SixModeReadyGoRes data.
             * @member {pb.ISixModeReadyGoResData|null|undefined} data
             * @memberof pb.SixModeReadyGoRes
             * @instance
             */
            SixModeReadyGoRes.prototype.data = null;
    
            /**
             * Creates a new SixModeReadyGoRes instance using the specified properties.
             * @function create
             * @memberof pb.SixModeReadyGoRes
             * @static
             * @param {pb.ISixModeReadyGoRes=} [properties] Properties to set
             * @returns {pb.SixModeReadyGoRes} SixModeReadyGoRes instance
             */
            SixModeReadyGoRes.create = function create(properties) {
                return new SixModeReadyGoRes(properties);
            };
    
            /**
             * Encodes the specified SixModeReadyGoRes message. Does not implicitly {@link pb.SixModeReadyGoRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeReadyGoRes
             * @static
             * @param {pb.ISixModeReadyGoRes} message SixModeReadyGoRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeReadyGoRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.SixModeReadyGoResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a SixModeReadyGoRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeReadyGoRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeReadyGoRes} SixModeReadyGoRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeReadyGoRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeReadyGoRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.SixModeReadyGoResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeReadyGoRes;
        })();
    
        pb.SixModeReadyGoResData = (function() {
    
            /**
             * Properties of a SixModeReadyGoResData.
             * @memberof pb
             * @interface ISixModeReadyGoResData
             * @property {string|null} [first_uid] SixModeReadyGoResData first_uid
             * @property {pb.ISixModeChessBoard|null} [chessboard] SixModeReadyGoResData chessboard
             * @property {number|null} [start_time] SixModeReadyGoResData start_time
             * @property {number|null} [roundEndTime] SixModeReadyGoResData roundEndTime
             * @property {Array.<pb.IUserData>|null} [userDatas] SixModeReadyGoResData userDatas
             * @property {number|null} [loseCoin] SixModeReadyGoResData loseCoin
             * @property {number|null} [winCoin] SixModeReadyGoResData winCoin
             * @property {number|null} [gameMode] SixModeReadyGoResData gameMode
             */
    
            /**
             * Constructs a new SixModeReadyGoResData.
             * @memberof pb
             * @classdesc Represents a SixModeReadyGoResData.
             * @implements ISixModeReadyGoResData
             * @constructor
             * @param {pb.ISixModeReadyGoResData=} [properties] Properties to set
             */
            function SixModeReadyGoResData(properties) {
                this.userDatas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeReadyGoResData first_uid.
             * @member {string} first_uid
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.first_uid = "";
    
            /**
             * SixModeReadyGoResData chessboard.
             * @member {pb.ISixModeChessBoard|null|undefined} chessboard
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.chessboard = null;
    
            /**
             * SixModeReadyGoResData start_time.
             * @member {number} start_time
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.start_time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeReadyGoResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeReadyGoResData userDatas.
             * @member {Array.<pb.IUserData>} userDatas
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.userDatas = $util.emptyArray;
    
            /**
             * SixModeReadyGoResData loseCoin.
             * @member {number} loseCoin
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.loseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeReadyGoResData winCoin.
             * @member {number} winCoin
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.winCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeReadyGoResData gameMode.
             * @member {number} gameMode
             * @memberof pb.SixModeReadyGoResData
             * @instance
             */
            SixModeReadyGoResData.prototype.gameMode = 0;
    
            /**
             * Creates a new SixModeReadyGoResData instance using the specified properties.
             * @function create
             * @memberof pb.SixModeReadyGoResData
             * @static
             * @param {pb.ISixModeReadyGoResData=} [properties] Properties to set
             * @returns {pb.SixModeReadyGoResData} SixModeReadyGoResData instance
             */
            SixModeReadyGoResData.create = function create(properties) {
                return new SixModeReadyGoResData(properties);
            };
    
            /**
             * Encodes the specified SixModeReadyGoResData message. Does not implicitly {@link pb.SixModeReadyGoResData.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeReadyGoResData
             * @static
             * @param {pb.ISixModeReadyGoResData} message SixModeReadyGoResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeReadyGoResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.first_uid != null && Object.hasOwnProperty.call(message, "first_uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.first_uid);
                if (message.chessboard != null && Object.hasOwnProperty.call(message, "chessboard"))
                    $root.pb.SixModeChessBoard.encode(message.chessboard, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.start_time != null && Object.hasOwnProperty.call(message, "start_time"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.start_time);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.roundEndTime);
                if (message.userDatas != null && message.userDatas.length)
                    for (var i = 0; i < message.userDatas.length; ++i)
                        $root.pb.UserData.encode(message.userDatas[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.loseCoin != null && Object.hasOwnProperty.call(message, "loseCoin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.loseCoin);
                if (message.winCoin != null && Object.hasOwnProperty.call(message, "winCoin"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.winCoin);
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gameMode);
                return writer;
            };
    
            /**
             * Decodes a SixModeReadyGoResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeReadyGoResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeReadyGoResData} SixModeReadyGoResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeReadyGoResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeReadyGoResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.first_uid = reader.string();
                        break;
                    case 2:
                        message.chessboard = $root.pb.SixModeChessBoard.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.start_time = reader.int64();
                        break;
                    case 4:
                        message.roundEndTime = reader.int64();
                        break;
                    case 5:
                        if (!(message.userDatas && message.userDatas.length))
                            message.userDatas = [];
                        message.userDatas.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.loseCoin = reader.int64();
                        break;
                    case 7:
                        message.winCoin = reader.int64();
                        break;
                    case 11:
                        message.gameMode = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeReadyGoResData;
        })();
    
        pb.SixModeReLoginRes = (function() {
    
            /**
             * Properties of a SixModeReLoginRes.
             * @memberof pb
             * @interface ISixModeReLoginRes
             * @property {number|null} [code] SixModeReLoginRes code
             * @property {string|null} [msg] SixModeReLoginRes msg
             * @property {pb.ISixModeReLoginResData|null} [data] SixModeReLoginRes data
             */
    
            /**
             * Constructs a new SixModeReLoginRes.
             * @memberof pb
             * @classdesc Represents a SixModeReLoginRes.
             * @implements ISixModeReLoginRes
             * @constructor
             * @param {pb.ISixModeReLoginRes=} [properties] Properties to set
             */
            function SixModeReLoginRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeReLoginRes code.
             * @member {number} code
             * @memberof pb.SixModeReLoginRes
             * @instance
             */
            SixModeReLoginRes.prototype.code = 0;
    
            /**
             * SixModeReLoginRes msg.
             * @member {string} msg
             * @memberof pb.SixModeReLoginRes
             * @instance
             */
            SixModeReLoginRes.prototype.msg = "";
    
            /**
             * SixModeReLoginRes data.
             * @member {pb.ISixModeReLoginResData|null|undefined} data
             * @memberof pb.SixModeReLoginRes
             * @instance
             */
            SixModeReLoginRes.prototype.data = null;
    
            /**
             * Creates a new SixModeReLoginRes instance using the specified properties.
             * @function create
             * @memberof pb.SixModeReLoginRes
             * @static
             * @param {pb.ISixModeReLoginRes=} [properties] Properties to set
             * @returns {pb.SixModeReLoginRes} SixModeReLoginRes instance
             */
            SixModeReLoginRes.create = function create(properties) {
                return new SixModeReLoginRes(properties);
            };
    
            /**
             * Encodes the specified SixModeReLoginRes message. Does not implicitly {@link pb.SixModeReLoginRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeReLoginRes
             * @static
             * @param {pb.ISixModeReLoginRes} message SixModeReLoginRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeReLoginRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.SixModeReLoginResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a SixModeReLoginRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeReLoginRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeReLoginRes} SixModeReLoginRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeReLoginRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeReLoginRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.SixModeReLoginResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeReLoginRes;
        })();
    
        pb.SixModeReLoginResData = (function() {
    
            /**
             * Properties of a SixModeReLoginResData.
             * @memberof pb
             * @interface ISixModeReLoginResData
             * @property {string|null} [stage] SixModeReLoginResData stage
             * @property {string|null} [curuid] SixModeReLoginResData curuid
             * @property {number|null} [dicenum] SixModeReLoginResData dicenum
             * @property {number|null} [gameMode] SixModeReLoginResData gameMode
             * @property {pb.ISixModeChessBoard|null} [chessboard] SixModeReLoginResData chessboard
             * @property {number|null} [roundEndTime] SixModeReLoginResData roundEndTime
             * @property {pb.DiceNumResType|null} [dicetype] SixModeReLoginResData dicetype
             * @property {number|null} [coin] SixModeReLoginResData coin
             * @property {Array.<pb.IUserData>|null} [userDatas] SixModeReLoginResData userDatas
             * @property {number|null} [loseCoin] SixModeReLoginResData loseCoin
             * @property {number|null} [winCoin] SixModeReLoginResData winCoin
             */
    
            /**
             * Constructs a new SixModeReLoginResData.
             * @memberof pb
             * @classdesc Represents a SixModeReLoginResData.
             * @implements ISixModeReLoginResData
             * @constructor
             * @param {pb.ISixModeReLoginResData=} [properties] Properties to set
             */
            function SixModeReLoginResData(properties) {
                this.userDatas = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeReLoginResData stage.
             * @member {string} stage
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.stage = "";
    
            /**
             * SixModeReLoginResData curuid.
             * @member {string} curuid
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.curuid = "";
    
            /**
             * SixModeReLoginResData dicenum.
             * @member {number} dicenum
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.dicenum = 0;
    
            /**
             * SixModeReLoginResData gameMode.
             * @member {number} gameMode
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.gameMode = 0;
    
            /**
             * SixModeReLoginResData chessboard.
             * @member {pb.ISixModeChessBoard|null|undefined} chessboard
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.chessboard = null;
    
            /**
             * SixModeReLoginResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeReLoginResData dicetype.
             * @member {pb.DiceNumResType} dicetype
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.dicetype = 0;
    
            /**
             * SixModeReLoginResData coin.
             * @member {number} coin
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.coin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeReLoginResData userDatas.
             * @member {Array.<pb.IUserData>} userDatas
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.userDatas = $util.emptyArray;
    
            /**
             * SixModeReLoginResData loseCoin.
             * @member {number} loseCoin
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.loseCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeReLoginResData winCoin.
             * @member {number} winCoin
             * @memberof pb.SixModeReLoginResData
             * @instance
             */
            SixModeReLoginResData.prototype.winCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new SixModeReLoginResData instance using the specified properties.
             * @function create
             * @memberof pb.SixModeReLoginResData
             * @static
             * @param {pb.ISixModeReLoginResData=} [properties] Properties to set
             * @returns {pb.SixModeReLoginResData} SixModeReLoginResData instance
             */
            SixModeReLoginResData.create = function create(properties) {
                return new SixModeReLoginResData(properties);
            };
    
            /**
             * Encodes the specified SixModeReLoginResData message. Does not implicitly {@link pb.SixModeReLoginResData.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeReLoginResData
             * @static
             * @param {pb.ISixModeReLoginResData} message SixModeReLoginResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeReLoginResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stage != null && Object.hasOwnProperty.call(message, "stage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stage);
                if (message.curuid != null && Object.hasOwnProperty.call(message, "curuid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.curuid);
                if (message.dicenum != null && Object.hasOwnProperty.call(message, "dicenum"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.dicenum);
                if (message.chessboard != null && Object.hasOwnProperty.call(message, "chessboard"))
                    $root.pb.SixModeChessBoard.encode(message.chessboard, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.roundEndTime);
                if (message.dicetype != null && Object.hasOwnProperty.call(message, "dicetype"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.dicetype);
                if (message.coin != null && Object.hasOwnProperty.call(message, "coin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.coin);
                if (message.gameMode != null && Object.hasOwnProperty.call(message, "gameMode"))
                    writer.uint32(/* id 11, wireType 0 =*/88).int32(message.gameMode);
                if (message.userDatas != null && message.userDatas.length)
                    for (var i = 0; i < message.userDatas.length; ++i)
                        $root.pb.UserData.encode(message.userDatas[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.loseCoin != null && Object.hasOwnProperty.call(message, "loseCoin"))
                    writer.uint32(/* id 14, wireType 0 =*/112).int64(message.loseCoin);
                if (message.winCoin != null && Object.hasOwnProperty.call(message, "winCoin"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int64(message.winCoin);
                return writer;
            };
    
            /**
             * Decodes a SixModeReLoginResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeReLoginResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeReLoginResData} SixModeReLoginResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeReLoginResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeReLoginResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stage = reader.string();
                        break;
                    case 2:
                        message.curuid = reader.string();
                        break;
                    case 3:
                        message.dicenum = reader.int32();
                        break;
                    case 11:
                        message.gameMode = reader.int32();
                        break;
                    case 6:
                        message.chessboard = $root.pb.SixModeChessBoard.decode(reader, reader.uint32());
                        break;
                    case 7:
                        message.roundEndTime = reader.int64();
                        break;
                    case 8:
                        message.dicetype = reader.int32();
                        break;
                    case 10:
                        message.coin = reader.int64();
                        break;
                    case 13:
                        if (!(message.userDatas && message.userDatas.length))
                            message.userDatas = [];
                        message.userDatas.push($root.pb.UserData.decode(reader, reader.uint32()));
                        break;
                    case 14:
                        message.loseCoin = reader.int64();
                        break;
                    case 15:
                        message.winCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeReLoginResData;
        })();
    
        pb.SixModeChessBoard = (function() {
    
            /**
             * Properties of a SixModeChessBoard.
             * @memberof pb
             * @interface ISixModeChessBoard
             * @property {Array.<pb.ISixModeAirPortPlane>|null} [airport_planes] SixModeChessBoard airport_planes
             * @property {Array.<pb.ISixModePlane>|null} [plane] SixModeChessBoard plane
             */
    
            /**
             * Constructs a new SixModeChessBoard.
             * @memberof pb
             * @classdesc Represents a SixModeChessBoard.
             * @implements ISixModeChessBoard
             * @constructor
             * @param {pb.ISixModeChessBoard=} [properties] Properties to set
             */
            function SixModeChessBoard(properties) {
                this.airport_planes = [];
                this.plane = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeChessBoard airport_planes.
             * @member {Array.<pb.ISixModeAirPortPlane>} airport_planes
             * @memberof pb.SixModeChessBoard
             * @instance
             */
            SixModeChessBoard.prototype.airport_planes = $util.emptyArray;
    
            /**
             * SixModeChessBoard plane.
             * @member {Array.<pb.ISixModePlane>} plane
             * @memberof pb.SixModeChessBoard
             * @instance
             */
            SixModeChessBoard.prototype.plane = $util.emptyArray;
    
            /**
             * Creates a new SixModeChessBoard instance using the specified properties.
             * @function create
             * @memberof pb.SixModeChessBoard
             * @static
             * @param {pb.ISixModeChessBoard=} [properties] Properties to set
             * @returns {pb.SixModeChessBoard} SixModeChessBoard instance
             */
            SixModeChessBoard.create = function create(properties) {
                return new SixModeChessBoard(properties);
            };
    
            /**
             * Encodes the specified SixModeChessBoard message. Does not implicitly {@link pb.SixModeChessBoard.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeChessBoard
             * @static
             * @param {pb.ISixModeChessBoard} message SixModeChessBoard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeChessBoard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.airport_planes != null && message.airport_planes.length)
                    for (var i = 0; i < message.airport_planes.length; ++i)
                        $root.pb.SixModeAirPortPlane.encode(message.airport_planes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.plane != null && message.plane.length)
                    for (var i = 0; i < message.plane.length; ++i)
                        $root.pb.SixModePlane.encode(message.plane[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a SixModeChessBoard message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeChessBoard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeChessBoard} SixModeChessBoard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeChessBoard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeChessBoard();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.airport_planes && message.airport_planes.length))
                            message.airport_planes = [];
                        message.airport_planes.push($root.pb.SixModeAirPortPlane.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        if (!(message.plane && message.plane.length))
                            message.plane = [];
                        message.plane.push($root.pb.SixModePlane.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeChessBoard;
        })();
    
        pb.SixModeAirPortPlane = (function() {
    
            /**
             * Properties of a SixModeAirPortPlane.
             * @memberof pb
             * @interface ISixModeAirPortPlane
             * @property {number|null} [color] SixModeAirPortPlane color
             * @property {number|null} [plane] SixModeAirPortPlane plane
             */
    
            /**
             * Constructs a new SixModeAirPortPlane.
             * @memberof pb
             * @classdesc Represents a SixModeAirPortPlane.
             * @implements ISixModeAirPortPlane
             * @constructor
             * @param {pb.ISixModeAirPortPlane=} [properties] Properties to set
             */
            function SixModeAirPortPlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeAirPortPlane color.
             * @member {number} color
             * @memberof pb.SixModeAirPortPlane
             * @instance
             */
            SixModeAirPortPlane.prototype.color = 0;
    
            /**
             * SixModeAirPortPlane plane.
             * @member {number} plane
             * @memberof pb.SixModeAirPortPlane
             * @instance
             */
            SixModeAirPortPlane.prototype.plane = 0;
    
            /**
             * Creates a new SixModeAirPortPlane instance using the specified properties.
             * @function create
             * @memberof pb.SixModeAirPortPlane
             * @static
             * @param {pb.ISixModeAirPortPlane=} [properties] Properties to set
             * @returns {pb.SixModeAirPortPlane} SixModeAirPortPlane instance
             */
            SixModeAirPortPlane.create = function create(properties) {
                return new SixModeAirPortPlane(properties);
            };
    
            /**
             * Encodes the specified SixModeAirPortPlane message. Does not implicitly {@link pb.SixModeAirPortPlane.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeAirPortPlane
             * @static
             * @param {pb.ISixModeAirPortPlane} message SixModeAirPortPlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeAirPortPlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                return writer;
            };
    
            /**
             * Decodes a SixModeAirPortPlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeAirPortPlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeAirPortPlane} SixModeAirPortPlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeAirPortPlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeAirPortPlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeAirPortPlane;
        })();
    
        pb.SixModePlane = (function() {
    
            /**
             * Properties of a SixModePlane.
             * @memberof pb
             * @interface ISixModePlane
             * @property {number|null} [x] SixModePlane x
             * @property {number|null} [color] SixModePlane color
             * @property {number|null} [plane] SixModePlane plane
             */
    
            /**
             * Constructs a new SixModePlane.
             * @memberof pb
             * @classdesc Represents a SixModePlane.
             * @implements ISixModePlane
             * @constructor
             * @param {pb.ISixModePlane=} [properties] Properties to set
             */
            function SixModePlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModePlane x.
             * @member {number} x
             * @memberof pb.SixModePlane
             * @instance
             */
            SixModePlane.prototype.x = 0;
    
            /**
             * SixModePlane color.
             * @member {number} color
             * @memberof pb.SixModePlane
             * @instance
             */
            SixModePlane.prototype.color = 0;
    
            /**
             * SixModePlane plane.
             * @member {number} plane
             * @memberof pb.SixModePlane
             * @instance
             */
            SixModePlane.prototype.plane = 0;
    
            /**
             * Creates a new SixModePlane instance using the specified properties.
             * @function create
             * @memberof pb.SixModePlane
             * @static
             * @param {pb.ISixModePlane=} [properties] Properties to set
             * @returns {pb.SixModePlane} SixModePlane instance
             */
            SixModePlane.create = function create(properties) {
                return new SixModePlane(properties);
            };
    
            /**
             * Encodes the specified SixModePlane message. Does not implicitly {@link pb.SixModePlane.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModePlane
             * @static
             * @param {pb.ISixModePlane} message SixModePlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModePlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.x);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.plane);
                return writer;
            };
    
            /**
             * Decodes a SixModePlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModePlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModePlane} SixModePlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModePlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModePlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.x = reader.int32();
                        break;
                    case 2:
                        message.color = reader.int32();
                        break;
                    case 3:
                        message.plane = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModePlane;
        })();
    
        pb.SixModeDiceNumReq = (function() {
    
            /**
             * Properties of a SixModeDiceNumReq.
             * @memberof pb
             * @interface ISixModeDiceNumReq
             * @property {number|null} [num] SixModeDiceNumReq num
             */
    
            /**
             * Constructs a new SixModeDiceNumReq.
             * @memberof pb
             * @classdesc Represents a SixModeDiceNumReq.
             * @implements ISixModeDiceNumReq
             * @constructor
             * @param {pb.ISixModeDiceNumReq=} [properties] Properties to set
             */
            function SixModeDiceNumReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeDiceNumReq num.
             * @member {number} num
             * @memberof pb.SixModeDiceNumReq
             * @instance
             */
            SixModeDiceNumReq.prototype.num = 0;
    
            /**
             * Creates a new SixModeDiceNumReq instance using the specified properties.
             * @function create
             * @memberof pb.SixModeDiceNumReq
             * @static
             * @param {pb.ISixModeDiceNumReq=} [properties] Properties to set
             * @returns {pb.SixModeDiceNumReq} SixModeDiceNumReq instance
             */
            SixModeDiceNumReq.create = function create(properties) {
                return new SixModeDiceNumReq(properties);
            };
    
            /**
             * Encodes the specified SixModeDiceNumReq message. Does not implicitly {@link pb.SixModeDiceNumReq.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeDiceNumReq
             * @static
             * @param {pb.ISixModeDiceNumReq} message SixModeDiceNumReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeDiceNumReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                return writer;
            };
    
            /**
             * Decodes a SixModeDiceNumReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeDiceNumReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeDiceNumReq} SixModeDiceNumReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeDiceNumReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeDiceNumReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeDiceNumReq;
        })();
    
        pb.SixModeDiceNumRes = (function() {
    
            /**
             * Properties of a SixModeDiceNumRes.
             * @memberof pb
             * @interface ISixModeDiceNumRes
             * @property {number|null} [code] SixModeDiceNumRes code
             * @property {string|null} [msg] SixModeDiceNumRes msg
             * @property {pb.ISixModeDiceNumData|null} [data] SixModeDiceNumRes data
             */
    
            /**
             * Constructs a new SixModeDiceNumRes.
             * @memberof pb
             * @classdesc Represents a SixModeDiceNumRes.
             * @implements ISixModeDiceNumRes
             * @constructor
             * @param {pb.ISixModeDiceNumRes=} [properties] Properties to set
             */
            function SixModeDiceNumRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeDiceNumRes code.
             * @member {number} code
             * @memberof pb.SixModeDiceNumRes
             * @instance
             */
            SixModeDiceNumRes.prototype.code = 0;
    
            /**
             * SixModeDiceNumRes msg.
             * @member {string} msg
             * @memberof pb.SixModeDiceNumRes
             * @instance
             */
            SixModeDiceNumRes.prototype.msg = "";
    
            /**
             * SixModeDiceNumRes data.
             * @member {pb.ISixModeDiceNumData|null|undefined} data
             * @memberof pb.SixModeDiceNumRes
             * @instance
             */
            SixModeDiceNumRes.prototype.data = null;
    
            /**
             * Creates a new SixModeDiceNumRes instance using the specified properties.
             * @function create
             * @memberof pb.SixModeDiceNumRes
             * @static
             * @param {pb.ISixModeDiceNumRes=} [properties] Properties to set
             * @returns {pb.SixModeDiceNumRes} SixModeDiceNumRes instance
             */
            SixModeDiceNumRes.create = function create(properties) {
                return new SixModeDiceNumRes(properties);
            };
    
            /**
             * Encodes the specified SixModeDiceNumRes message. Does not implicitly {@link pb.SixModeDiceNumRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeDiceNumRes
             * @static
             * @param {pb.ISixModeDiceNumRes} message SixModeDiceNumRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeDiceNumRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.SixModeDiceNumData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a SixModeDiceNumRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeDiceNumRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeDiceNumRes} SixModeDiceNumRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeDiceNumRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeDiceNumRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.SixModeDiceNumData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeDiceNumRes;
        })();
    
        pb.SixModeDiceNumData = (function() {
    
            /**
             * Properties of a SixModeDiceNumData.
             * @memberof pb
             * @interface ISixModeDiceNumData
             * @property {number|null} [num] SixModeDiceNumData num
             * @property {number|null} [roundEndTime] SixModeDiceNumData roundEndTime
             * @property {pb.DiceNumResType|null} [type] SixModeDiceNumData type
             * @property {string|null} [uid] SixModeDiceNumData uid
             */
    
            /**
             * Constructs a new SixModeDiceNumData.
             * @memberof pb
             * @classdesc Represents a SixModeDiceNumData.
             * @implements ISixModeDiceNumData
             * @constructor
             * @param {pb.ISixModeDiceNumData=} [properties] Properties to set
             */
            function SixModeDiceNumData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeDiceNumData num.
             * @member {number} num
             * @memberof pb.SixModeDiceNumData
             * @instance
             */
            SixModeDiceNumData.prototype.num = 0;
    
            /**
             * SixModeDiceNumData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.SixModeDiceNumData
             * @instance
             */
            SixModeDiceNumData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeDiceNumData type.
             * @member {pb.DiceNumResType} type
             * @memberof pb.SixModeDiceNumData
             * @instance
             */
            SixModeDiceNumData.prototype.type = 0;
    
            /**
             * SixModeDiceNumData uid.
             * @member {string} uid
             * @memberof pb.SixModeDiceNumData
             * @instance
             */
            SixModeDiceNumData.prototype.uid = "";
    
            /**
             * Creates a new SixModeDiceNumData instance using the specified properties.
             * @function create
             * @memberof pb.SixModeDiceNumData
             * @static
             * @param {pb.ISixModeDiceNumData=} [properties] Properties to set
             * @returns {pb.SixModeDiceNumData} SixModeDiceNumData instance
             */
            SixModeDiceNumData.create = function create(properties) {
                return new SixModeDiceNumData(properties);
            };
    
            /**
             * Encodes the specified SixModeDiceNumData message. Does not implicitly {@link pb.SixModeDiceNumData.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeDiceNumData
             * @static
             * @param {pb.ISixModeDiceNumData} message SixModeDiceNumData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeDiceNumData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.num != null && Object.hasOwnProperty.call(message, "num"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.num);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roundEndTime);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.uid);
                return writer;
            };
    
            /**
             * Decodes a SixModeDiceNumData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeDiceNumData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeDiceNumData} SixModeDiceNumData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeDiceNumData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeDiceNumData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.num = reader.int32();
                        break;
                    case 2:
                        message.roundEndTime = reader.int64();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.uid = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeDiceNumData;
        })();
    
        pb.SixModeMoveReq = (function() {
    
            /**
             * Properties of a SixModeMoveReq.
             * @memberof pb
             * @interface ISixModeMoveReq
             * @property {number|null} [color] SixModeMoveReq color
             * @property {number|null} [plane] SixModeMoveReq plane
             * @property {pb.MoveType|null} [type] SixModeMoveReq type
             * @property {number|null} [diceNum] SixModeMoveReq diceNum
             */
    
            /**
             * Constructs a new SixModeMoveReq.
             * @memberof pb
             * @classdesc Represents a SixModeMoveReq.
             * @implements ISixModeMoveReq
             * @constructor
             * @param {pb.ISixModeMoveReq=} [properties] Properties to set
             */
            function SixModeMoveReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeMoveReq color.
             * @member {number} color
             * @memberof pb.SixModeMoveReq
             * @instance
             */
            SixModeMoveReq.prototype.color = 0;
    
            /**
             * SixModeMoveReq plane.
             * @member {number} plane
             * @memberof pb.SixModeMoveReq
             * @instance
             */
            SixModeMoveReq.prototype.plane = 0;
    
            /**
             * SixModeMoveReq type.
             * @member {pb.MoveType} type
             * @memberof pb.SixModeMoveReq
             * @instance
             */
            SixModeMoveReq.prototype.type = 0;
    
            /**
             * SixModeMoveReq diceNum.
             * @member {number} diceNum
             * @memberof pb.SixModeMoveReq
             * @instance
             */
            SixModeMoveReq.prototype.diceNum = 0;
    
            /**
             * Creates a new SixModeMoveReq instance using the specified properties.
             * @function create
             * @memberof pb.SixModeMoveReq
             * @static
             * @param {pb.ISixModeMoveReq=} [properties] Properties to set
             * @returns {pb.SixModeMoveReq} SixModeMoveReq instance
             */
            SixModeMoveReq.create = function create(properties) {
                return new SixModeMoveReq(properties);
            };
    
            /**
             * Encodes the specified SixModeMoveReq message. Does not implicitly {@link pb.SixModeMoveReq.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeMoveReq
             * @static
             * @param {pb.ISixModeMoveReq} message SixModeMoveReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeMoveReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
                if (message.diceNum != null && Object.hasOwnProperty.call(message, "diceNum"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.diceNum);
                return writer;
            };
    
            /**
             * Decodes a SixModeMoveReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeMoveReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeMoveReq} SixModeMoveReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeMoveReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeMoveReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.type = reader.int32();
                        break;
                    case 4:
                        message.diceNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeMoveReq;
        })();
    
        pb.SixModeCrashPlane = (function() {
    
            /**
             * Properties of a SixModeCrashPlane.
             * @memberof pb
             * @interface ISixModeCrashPlane
             * @property {number|null} [color] SixModeCrashPlane color
             * @property {number|null} [plane] SixModeCrashPlane plane
             * @property {number|null} [x] SixModeCrashPlane x
             */
    
            /**
             * Constructs a new SixModeCrashPlane.
             * @memberof pb
             * @classdesc Represents a SixModeCrashPlane.
             * @implements ISixModeCrashPlane
             * @constructor
             * @param {pb.ISixModeCrashPlane=} [properties] Properties to set
             */
            function SixModeCrashPlane(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeCrashPlane color.
             * @member {number} color
             * @memberof pb.SixModeCrashPlane
             * @instance
             */
            SixModeCrashPlane.prototype.color = 0;
    
            /**
             * SixModeCrashPlane plane.
             * @member {number} plane
             * @memberof pb.SixModeCrashPlane
             * @instance
             */
            SixModeCrashPlane.prototype.plane = 0;
    
            /**
             * SixModeCrashPlane x.
             * @member {number} x
             * @memberof pb.SixModeCrashPlane
             * @instance
             */
            SixModeCrashPlane.prototype.x = 0;
    
            /**
             * Creates a new SixModeCrashPlane instance using the specified properties.
             * @function create
             * @memberof pb.SixModeCrashPlane
             * @static
             * @param {pb.ISixModeCrashPlane=} [properties] Properties to set
             * @returns {pb.SixModeCrashPlane} SixModeCrashPlane instance
             */
            SixModeCrashPlane.create = function create(properties) {
                return new SixModeCrashPlane(properties);
            };
    
            /**
             * Encodes the specified SixModeCrashPlane message. Does not implicitly {@link pb.SixModeCrashPlane.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeCrashPlane
             * @static
             * @param {pb.ISixModeCrashPlane} message SixModeCrashPlane message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeCrashPlane.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.color);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.plane);
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.x);
                return writer;
            };
    
            /**
             * Decodes a SixModeCrashPlane message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeCrashPlane
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeCrashPlane} SixModeCrashPlane
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeCrashPlane.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeCrashPlane();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.color = reader.int32();
                        break;
                    case 2:
                        message.plane = reader.int32();
                        break;
                    case 3:
                        message.x = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeCrashPlane;
        })();
    
        pb.SixModeMoveRes = (function() {
    
            /**
             * Properties of a SixModeMoveRes.
             * @memberof pb
             * @interface ISixModeMoveRes
             * @property {number|null} [code] SixModeMoveRes code
             * @property {string|null} [msg] SixModeMoveRes msg
             * @property {pb.ISixModeMoveResData|null} [data] SixModeMoveRes data
             */
    
            /**
             * Constructs a new SixModeMoveRes.
             * @memberof pb
             * @classdesc Represents a SixModeMoveRes.
             * @implements ISixModeMoveRes
             * @constructor
             * @param {pb.ISixModeMoveRes=} [properties] Properties to set
             */
            function SixModeMoveRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeMoveRes code.
             * @member {number} code
             * @memberof pb.SixModeMoveRes
             * @instance
             */
            SixModeMoveRes.prototype.code = 0;
    
            /**
             * SixModeMoveRes msg.
             * @member {string} msg
             * @memberof pb.SixModeMoveRes
             * @instance
             */
            SixModeMoveRes.prototype.msg = "";
    
            /**
             * SixModeMoveRes data.
             * @member {pb.ISixModeMoveResData|null|undefined} data
             * @memberof pb.SixModeMoveRes
             * @instance
             */
            SixModeMoveRes.prototype.data = null;
    
            /**
             * Creates a new SixModeMoveRes instance using the specified properties.
             * @function create
             * @memberof pb.SixModeMoveRes
             * @static
             * @param {pb.ISixModeMoveRes=} [properties] Properties to set
             * @returns {pb.SixModeMoveRes} SixModeMoveRes instance
             */
            SixModeMoveRes.create = function create(properties) {
                return new SixModeMoveRes(properties);
            };
    
            /**
             * Encodes the specified SixModeMoveRes message. Does not implicitly {@link pb.SixModeMoveRes.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeMoveRes
             * @static
             * @param {pb.ISixModeMoveRes} message SixModeMoveRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeMoveRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    $root.pb.SixModeMoveResData.encode(message.data, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a SixModeMoveRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeMoveRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeMoveRes} SixModeMoveRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeMoveRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeMoveRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.code = reader.int32();
                        break;
                    case 2:
                        message.msg = reader.string();
                        break;
                    case 3:
                        message.data = $root.pb.SixModeMoveResData.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeMoveRes;
        })();
    
        pb.SixModeMoveResData = (function() {
    
            /**
             * Properties of a SixModeMoveResData.
             * @memberof pb
             * @interface ISixModeMoveResData
             * @property {string|null} [uid] SixModeMoveResData uid
             * @property {pb.ISixModePlane|null} [plane] SixModeMoveResData plane
             * @property {pb.ISixModeAirPortPlane|null} [airport_plane] SixModeMoveResData airport_plane
             * @property {pb.MoveType|null} [type] SixModeMoveResData type
             * @property {Array.<pb.ISixModeCrashPlane>|null} [crashPlanes] SixModeMoveResData crashPlanes
             * @property {string|null} [next_uid] SixModeMoveResData next_uid
             * @property {number|null} [roundEndTime] SixModeMoveResData roundEndTime
             * @property {number|null} [diceNum] SixModeMoveResData diceNum
             */
    
            /**
             * Constructs a new SixModeMoveResData.
             * @memberof pb
             * @classdesc Represents a SixModeMoveResData.
             * @implements ISixModeMoveResData
             * @constructor
             * @param {pb.ISixModeMoveResData=} [properties] Properties to set
             */
            function SixModeMoveResData(properties) {
                this.crashPlanes = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SixModeMoveResData uid.
             * @member {string} uid
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.uid = "";
    
            /**
             * SixModeMoveResData plane.
             * @member {pb.ISixModePlane|null|undefined} plane
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.plane = null;
    
            /**
             * SixModeMoveResData airport_plane.
             * @member {pb.ISixModeAirPortPlane|null|undefined} airport_plane
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.airport_plane = null;
    
            /**
             * SixModeMoveResData type.
             * @member {pb.MoveType} type
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.type = 0;
    
            /**
             * SixModeMoveResData crashPlanes.
             * @member {Array.<pb.ISixModeCrashPlane>} crashPlanes
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.crashPlanes = $util.emptyArray;
    
            /**
             * SixModeMoveResData next_uid.
             * @member {string} next_uid
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.next_uid = "";
    
            /**
             * SixModeMoveResData roundEndTime.
             * @member {number} roundEndTime
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.roundEndTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SixModeMoveResData diceNum.
             * @member {number} diceNum
             * @memberof pb.SixModeMoveResData
             * @instance
             */
            SixModeMoveResData.prototype.diceNum = 0;
    
            /**
             * Creates a new SixModeMoveResData instance using the specified properties.
             * @function create
             * @memberof pb.SixModeMoveResData
             * @static
             * @param {pb.ISixModeMoveResData=} [properties] Properties to set
             * @returns {pb.SixModeMoveResData} SixModeMoveResData instance
             */
            SixModeMoveResData.create = function create(properties) {
                return new SixModeMoveResData(properties);
            };
    
            /**
             * Encodes the specified SixModeMoveResData message. Does not implicitly {@link pb.SixModeMoveResData.verify|verify} messages.
             * @function encode
             * @memberof pb.SixModeMoveResData
             * @static
             * @param {pb.ISixModeMoveResData} message SixModeMoveResData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SixModeMoveResData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.plane != null && Object.hasOwnProperty.call(message, "plane"))
                    $root.pb.SixModePlane.encode(message.plane, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.airport_plane != null && Object.hasOwnProperty.call(message, "airport_plane"))
                    $root.pb.SixModeAirPortPlane.encode(message.airport_plane, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.type);
                if (message.crashPlanes != null && message.crashPlanes.length)
                    for (var i = 0; i < message.crashPlanes.length; ++i)
                        $root.pb.SixModeCrashPlane.encode(message.crashPlanes[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.next_uid != null && Object.hasOwnProperty.call(message, "next_uid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.next_uid);
                if (message.roundEndTime != null && Object.hasOwnProperty.call(message, "roundEndTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int64(message.roundEndTime);
                if (message.diceNum != null && Object.hasOwnProperty.call(message, "diceNum"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.diceNum);
                return writer;
            };
    
            /**
             * Decodes a SixModeMoveResData message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SixModeMoveResData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SixModeMoveResData} SixModeMoveResData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SixModeMoveResData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SixModeMoveResData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.uid = reader.string();
                        break;
                    case 2:
                        message.plane = $root.pb.SixModePlane.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.airport_plane = $root.pb.SixModeAirPortPlane.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.type = reader.int32();
                        break;
                    case 5:
                        if (!(message.crashPlanes && message.crashPlanes.length))
                            message.crashPlanes = [];
                        message.crashPlanes.push($root.pb.SixModeCrashPlane.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.next_uid = reader.string();
                        break;
                    case 7:
                        message.roundEndTime = reader.int64();
                        break;
                    case 8:
                        message.diceNum = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SixModeMoveResData;
        })();
    
        pb.GetAllSkin2Req = (function() {
    
            /**
             * Properties of a GetAllSkin2Req.
             * @memberof pb
             * @interface IGetAllSkin2Req
             */
    
            /**
             * Constructs a new GetAllSkin2Req.
             * @memberof pb
             * @classdesc Represents a GetAllSkin2Req.
             * @implements IGetAllSkin2Req
             * @constructor
             * @param {pb.IGetAllSkin2Req=} [properties] Properties to set
             */
            function GetAllSkin2Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetAllSkin2Req instance using the specified properties.
             * @function create
             * @memberof pb.GetAllSkin2Req
             * @static
             * @param {pb.IGetAllSkin2Req=} [properties] Properties to set
             * @returns {pb.GetAllSkin2Req} GetAllSkin2Req instance
             */
            GetAllSkin2Req.create = function create(properties) {
                return new GetAllSkin2Req(properties);
            };
    
            /**
             * Encodes the specified GetAllSkin2Req message. Does not implicitly {@link pb.GetAllSkin2Req.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAllSkin2Req
             * @static
             * @param {pb.IGetAllSkin2Req} message GetAllSkin2Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllSkin2Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetAllSkin2Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAllSkin2Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAllSkin2Req} GetAllSkin2Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllSkin2Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAllSkin2Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAllSkin2Req;
        })();
    
        pb.UserSkin2Message = (function() {
    
            /**
             * Properties of a UserSkin2Message.
             * @memberof pb
             * @interface IUserSkin2Message
             * @property {number|null} [crystalCoin] UserSkin2Message crystalCoin
             * @property {Array.<pb.ISkins1Msg>|null} [decorated] UserSkin2Message decorated
             * @property {Array.<pb.ISkins1Msg>|null} [owners] UserSkin2Message owners
             * @property {number|null} [diamond] UserSkin2Message diamond
             */
    
            /**
             * Constructs a new UserSkin2Message.
             * @memberof pb
             * @classdesc Represents a UserSkin2Message.
             * @implements IUserSkin2Message
             * @constructor
             * @param {pb.IUserSkin2Message=} [properties] Properties to set
             */
            function UserSkin2Message(properties) {
                this.decorated = [];
                this.owners = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * UserSkin2Message crystalCoin.
             * @member {number} crystalCoin
             * @memberof pb.UserSkin2Message
             * @instance
             */
            UserSkin2Message.prototype.crystalCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * UserSkin2Message decorated.
             * @member {Array.<pb.ISkins1Msg>} decorated
             * @memberof pb.UserSkin2Message
             * @instance
             */
            UserSkin2Message.prototype.decorated = $util.emptyArray;
    
            /**
             * UserSkin2Message owners.
             * @member {Array.<pb.ISkins1Msg>} owners
             * @memberof pb.UserSkin2Message
             * @instance
             */
            UserSkin2Message.prototype.owners = $util.emptyArray;
    
            /**
             * UserSkin2Message diamond.
             * @member {number} diamond
             * @memberof pb.UserSkin2Message
             * @instance
             */
            UserSkin2Message.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new UserSkin2Message instance using the specified properties.
             * @function create
             * @memberof pb.UserSkin2Message
             * @static
             * @param {pb.IUserSkin2Message=} [properties] Properties to set
             * @returns {pb.UserSkin2Message} UserSkin2Message instance
             */
            UserSkin2Message.create = function create(properties) {
                return new UserSkin2Message(properties);
            };
    
            /**
             * Encodes the specified UserSkin2Message message. Does not implicitly {@link pb.UserSkin2Message.verify|verify} messages.
             * @function encode
             * @memberof pb.UserSkin2Message
             * @static
             * @param {pb.IUserSkin2Message} message UserSkin2Message message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UserSkin2Message.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.crystalCoin != null && Object.hasOwnProperty.call(message, "crystalCoin"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int64(message.crystalCoin);
                if (message.decorated != null && message.decorated.length)
                    for (var i = 0; i < message.decorated.length; ++i)
                        $root.pb.Skins1Msg.encode(message.decorated[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.owners != null && message.owners.length)
                    for (var i = 0; i < message.owners.length; ++i)
                        $root.pb.Skins1Msg.encode(message.owners[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.diamond != null && Object.hasOwnProperty.call(message, "diamond"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.diamond);
                return writer;
            };
    
            /**
             * Decodes a UserSkin2Message message from the specified reader or buffer.
             * @function decode
             * @memberof pb.UserSkin2Message
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.UserSkin2Message} UserSkin2Message
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UserSkin2Message.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UserSkin2Message();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.crystalCoin = reader.int64();
                        break;
                    case 2:
                        if (!(message.decorated && message.decorated.length))
                            message.decorated = [];
                        message.decorated.push($root.pb.Skins1Msg.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.owners && message.owners.length))
                            message.owners = [];
                        message.owners.push($root.pb.Skins1Msg.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        message.diamond = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return UserSkin2Message;
        })();
    
        pb.DiamondGetReq = (function() {
    
            /**
             * Properties of a DiamondGetReq.
             * @memberof pb
             * @interface IDiamondGetReq
             * @property {boolean|null} [forceQuery] DiamondGetReq forceQuery
             */
    
            /**
             * Constructs a new DiamondGetReq.
             * @memberof pb
             * @classdesc Represents a DiamondGetReq.
             * @implements IDiamondGetReq
             * @constructor
             * @param {pb.IDiamondGetReq=} [properties] Properties to set
             */
            function DiamondGetReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DiamondGetReq forceQuery.
             * @member {boolean} forceQuery
             * @memberof pb.DiamondGetReq
             * @instance
             */
            DiamondGetReq.prototype.forceQuery = false;
    
            /**
             * Creates a new DiamondGetReq instance using the specified properties.
             * @function create
             * @memberof pb.DiamondGetReq
             * @static
             * @param {pb.IDiamondGetReq=} [properties] Properties to set
             * @returns {pb.DiamondGetReq} DiamondGetReq instance
             */
            DiamondGetReq.create = function create(properties) {
                return new DiamondGetReq(properties);
            };
    
            /**
             * Encodes the specified DiamondGetReq message. Does not implicitly {@link pb.DiamondGetReq.verify|verify} messages.
             * @function encode
             * @memberof pb.DiamondGetReq
             * @static
             * @param {pb.IDiamondGetReq} message DiamondGetReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiamondGetReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.forceQuery != null && Object.hasOwnProperty.call(message, "forceQuery"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.forceQuery);
                return writer;
            };
    
            /**
             * Decodes a DiamondGetReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DiamondGetReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DiamondGetReq} DiamondGetReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiamondGetReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiamondGetReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.forceQuery = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DiamondGetReq;
        })();
    
        pb.DiamondGetRes = (function() {
    
            /**
             * Properties of a DiamondGetRes.
             * @memberof pb
             * @interface IDiamondGetRes
             * @property {boolean|null} [forceQuery] DiamondGetRes forceQuery
             * @property {number|null} [diamond] DiamondGetRes diamond
             * @property {number|null} [code] DiamondGetRes code
             */
    
            /**
             * Constructs a new DiamondGetRes.
             * @memberof pb
             * @classdesc Represents a DiamondGetRes.
             * @implements IDiamondGetRes
             * @constructor
             * @param {pb.IDiamondGetRes=} [properties] Properties to set
             */
            function DiamondGetRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DiamondGetRes forceQuery.
             * @member {boolean} forceQuery
             * @memberof pb.DiamondGetRes
             * @instance
             */
            DiamondGetRes.prototype.forceQuery = false;
    
            /**
             * DiamondGetRes diamond.
             * @member {number} diamond
             * @memberof pb.DiamondGetRes
             * @instance
             */
            DiamondGetRes.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * DiamondGetRes code.
             * @member {number} code
             * @memberof pb.DiamondGetRes
             * @instance
             */
            DiamondGetRes.prototype.code = 0;
    
            /**
             * Creates a new DiamondGetRes instance using the specified properties.
             * @function create
             * @memberof pb.DiamondGetRes
             * @static
             * @param {pb.IDiamondGetRes=} [properties] Properties to set
             * @returns {pb.DiamondGetRes} DiamondGetRes instance
             */
            DiamondGetRes.create = function create(properties) {
                return new DiamondGetRes(properties);
            };
    
            /**
             * Encodes the specified DiamondGetRes message. Does not implicitly {@link pb.DiamondGetRes.verify|verify} messages.
             * @function encode
             * @memberof pb.DiamondGetRes
             * @static
             * @param {pb.IDiamondGetRes} message DiamondGetRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiamondGetRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.forceQuery != null && Object.hasOwnProperty.call(message, "forceQuery"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.forceQuery);
                if (message.diamond != null && Object.hasOwnProperty.call(message, "diamond"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.diamond);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a DiamondGetRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DiamondGetRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DiamondGetRes} DiamondGetRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiamondGetRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiamondGetRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.forceQuery = reader.bool();
                        break;
                    case 4:
                        message.diamond = reader.int64();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DiamondGetRes;
        })();
    
        pb.GetAllSkin2Res = (function() {
    
            /**
             * Properties of a GetAllSkin2Res.
             * @memberof pb
             * @interface IGetAllSkin2Res
             * @property {pb.IUserSkin2Message|null} [skin] GetAllSkin2Res skin
             * @property {string|null} [uid] GetAllSkin2Res uid
             * @property {number|null} [code] GetAllSkin2Res code
             */
    
            /**
             * Constructs a new GetAllSkin2Res.
             * @memberof pb
             * @classdesc Represents a GetAllSkin2Res.
             * @implements IGetAllSkin2Res
             * @constructor
             * @param {pb.IGetAllSkin2Res=} [properties] Properties to set
             */
            function GetAllSkin2Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetAllSkin2Res skin.
             * @member {pb.IUserSkin2Message|null|undefined} skin
             * @memberof pb.GetAllSkin2Res
             * @instance
             */
            GetAllSkin2Res.prototype.skin = null;
    
            /**
             * GetAllSkin2Res uid.
             * @member {string} uid
             * @memberof pb.GetAllSkin2Res
             * @instance
             */
            GetAllSkin2Res.prototype.uid = "";
    
            /**
             * GetAllSkin2Res code.
             * @member {number} code
             * @memberof pb.GetAllSkin2Res
             * @instance
             */
            GetAllSkin2Res.prototype.code = 0;
    
            /**
             * Creates a new GetAllSkin2Res instance using the specified properties.
             * @function create
             * @memberof pb.GetAllSkin2Res
             * @static
             * @param {pb.IGetAllSkin2Res=} [properties] Properties to set
             * @returns {pb.GetAllSkin2Res} GetAllSkin2Res instance
             */
            GetAllSkin2Res.create = function create(properties) {
                return new GetAllSkin2Res(properties);
            };
    
            /**
             * Encodes the specified GetAllSkin2Res message. Does not implicitly {@link pb.GetAllSkin2Res.verify|verify} messages.
             * @function encode
             * @memberof pb.GetAllSkin2Res
             * @static
             * @param {pb.IGetAllSkin2Res} message GetAllSkin2Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAllSkin2Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.skin != null && Object.hasOwnProperty.call(message, "skin"))
                    $root.pb.UserSkin2Message.encode(message.skin, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uid);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetAllSkin2Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetAllSkin2Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetAllSkin2Res} GetAllSkin2Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAllSkin2Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetAllSkin2Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.skin = $root.pb.UserSkin2Message.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.uid = reader.string();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetAllSkin2Res;
        })();
    
        pb.SkinSetting2Msg = (function() {
    
            /**
             * Properties of a SkinSetting2Msg.
             * @memberof pb
             * @interface ISkinSetting2Msg
             * @property {number|null} [type] SkinSetting2Msg type
             * @property {number|null} [id] SkinSetting2Msg id
             * @property {number|null} [defSkin] SkinSetting2Msg defSkin
             * @property {number|null} [minLevel] SkinSetting2Msg minLevel
             * @property {number|null} [minScene] SkinSetting2Msg minScene
             * @property {number|null} [skinCoin] SkinSetting2Msg skinCoin
             * @property {number|null} [order] SkinSetting2Msg order
             * @property {number|null} [quality] SkinSetting2Msg quality
             * @property {number|null} [coinType] SkinSetting2Msg coinType
             * @property {number|null} [sourceCoin] SkinSetting2Msg sourceCoin
             */
    
            /**
             * Constructs a new SkinSetting2Msg.
             * @memberof pb
             * @classdesc Represents a SkinSetting2Msg.
             * @implements ISkinSetting2Msg
             * @constructor
             * @param {pb.ISkinSetting2Msg=} [properties] Properties to set
             */
            function SkinSetting2Msg(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * SkinSetting2Msg type.
             * @member {number} type
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.type = 0;
    
            /**
             * SkinSetting2Msg id.
             * @member {number} id
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.id = 0;
    
            /**
             * SkinSetting2Msg defSkin.
             * @member {number} defSkin
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.defSkin = 0;
    
            /**
             * SkinSetting2Msg minLevel.
             * @member {number} minLevel
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.minLevel = 0;
    
            /**
             * SkinSetting2Msg minScene.
             * @member {number} minScene
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.minScene = 0;
    
            /**
             * SkinSetting2Msg skinCoin.
             * @member {number} skinCoin
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.skinCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SkinSetting2Msg order.
             * @member {number} order
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.order = 0;
    
            /**
             * SkinSetting2Msg quality.
             * @member {number} quality
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.quality = 0;
    
            /**
             * SkinSetting2Msg coinType.
             * @member {number} coinType
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.coinType = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * SkinSetting2Msg sourceCoin.
             * @member {number} sourceCoin
             * @memberof pb.SkinSetting2Msg
             * @instance
             */
            SkinSetting2Msg.prototype.sourceCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * Creates a new SkinSetting2Msg instance using the specified properties.
             * @function create
             * @memberof pb.SkinSetting2Msg
             * @static
             * @param {pb.ISkinSetting2Msg=} [properties] Properties to set
             * @returns {pb.SkinSetting2Msg} SkinSetting2Msg instance
             */
            SkinSetting2Msg.create = function create(properties) {
                return new SkinSetting2Msg(properties);
            };
    
            /**
             * Encodes the specified SkinSetting2Msg message. Does not implicitly {@link pb.SkinSetting2Msg.verify|verify} messages.
             * @function encode
             * @memberof pb.SkinSetting2Msg
             * @static
             * @param {pb.ISkinSetting2Msg} message SkinSetting2Msg message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SkinSetting2Msg.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                if (message.defSkin != null && Object.hasOwnProperty.call(message, "defSkin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.defSkin);
                if (message.minLevel != null && Object.hasOwnProperty.call(message, "minLevel"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.minLevel);
                if (message.minScene != null && Object.hasOwnProperty.call(message, "minScene"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.minScene);
                if (message.skinCoin != null && Object.hasOwnProperty.call(message, "skinCoin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int64(message.skinCoin);
                if (message.order != null && Object.hasOwnProperty.call(message, "order"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.order);
                if (message.quality != null && Object.hasOwnProperty.call(message, "quality"))
                    writer.uint32(/* id 8, wireType 0 =*/64).int32(message.quality);
                if (message.coinType != null && Object.hasOwnProperty.call(message, "coinType"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int64(message.coinType);
                if (message.sourceCoin != null && Object.hasOwnProperty.call(message, "sourceCoin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int64(message.sourceCoin);
                return writer;
            };
    
            /**
             * Decodes a SkinSetting2Msg message from the specified reader or buffer.
             * @function decode
             * @memberof pb.SkinSetting2Msg
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.SkinSetting2Msg} SkinSetting2Msg
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SkinSetting2Msg.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SkinSetting2Msg();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.defSkin = reader.int32();
                        break;
                    case 4:
                        message.minLevel = reader.int32();
                        break;
                    case 5:
                        message.minScene = reader.int32();
                        break;
                    case 6:
                        message.skinCoin = reader.int64();
                        break;
                    case 7:
                        message.order = reader.int32();
                        break;
                    case 8:
                        message.quality = reader.int32();
                        break;
                    case 9:
                        message.coinType = reader.int64();
                        break;
                    case 10:
                        message.sourceCoin = reader.int64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return SkinSetting2Msg;
        })();
    
        pb.GetSkinSetting2Req = (function() {
    
            /**
             * Properties of a GetSkinSetting2Req.
             * @memberof pb
             * @interface IGetSkinSetting2Req
             */
    
            /**
             * Constructs a new GetSkinSetting2Req.
             * @memberof pb
             * @classdesc Represents a GetSkinSetting2Req.
             * @implements IGetSkinSetting2Req
             * @constructor
             * @param {pb.IGetSkinSetting2Req=} [properties] Properties to set
             */
            function GetSkinSetting2Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * Creates a new GetSkinSetting2Req instance using the specified properties.
             * @function create
             * @memberof pb.GetSkinSetting2Req
             * @static
             * @param {pb.IGetSkinSetting2Req=} [properties] Properties to set
             * @returns {pb.GetSkinSetting2Req} GetSkinSetting2Req instance
             */
            GetSkinSetting2Req.create = function create(properties) {
                return new GetSkinSetting2Req(properties);
            };
    
            /**
             * Encodes the specified GetSkinSetting2Req message. Does not implicitly {@link pb.GetSkinSetting2Req.verify|verify} messages.
             * @function encode
             * @memberof pb.GetSkinSetting2Req
             * @static
             * @param {pb.IGetSkinSetting2Req} message GetSkinSetting2Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSkinSetting2Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };
    
            /**
             * Decodes a GetSkinSetting2Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetSkinSetting2Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetSkinSetting2Req} GetSkinSetting2Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSkinSetting2Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetSkinSetting2Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetSkinSetting2Req;
        })();
    
        pb.GetSkinSetting2Res = (function() {
    
            /**
             * Properties of a GetSkinSetting2Res.
             * @memberof pb
             * @interface IGetSkinSetting2Res
             * @property {Array.<pb.ISkinSetting2Msg>|null} [skins] GetSkinSetting2Res skins
             */
    
            /**
             * Constructs a new GetSkinSetting2Res.
             * @memberof pb
             * @classdesc Represents a GetSkinSetting2Res.
             * @implements IGetSkinSetting2Res
             * @constructor
             * @param {pb.IGetSkinSetting2Res=} [properties] Properties to set
             */
            function GetSkinSetting2Res(properties) {
                this.skins = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetSkinSetting2Res skins.
             * @member {Array.<pb.ISkinSetting2Msg>} skins
             * @memberof pb.GetSkinSetting2Res
             * @instance
             */
            GetSkinSetting2Res.prototype.skins = $util.emptyArray;
    
            /**
             * Creates a new GetSkinSetting2Res instance using the specified properties.
             * @function create
             * @memberof pb.GetSkinSetting2Res
             * @static
             * @param {pb.IGetSkinSetting2Res=} [properties] Properties to set
             * @returns {pb.GetSkinSetting2Res} GetSkinSetting2Res instance
             */
            GetSkinSetting2Res.create = function create(properties) {
                return new GetSkinSetting2Res(properties);
            };
    
            /**
             * Encodes the specified GetSkinSetting2Res message. Does not implicitly {@link pb.GetSkinSetting2Res.verify|verify} messages.
             * @function encode
             * @memberof pb.GetSkinSetting2Res
             * @static
             * @param {pb.IGetSkinSetting2Res} message GetSkinSetting2Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetSkinSetting2Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.skins != null && message.skins.length)
                    for (var i = 0; i < message.skins.length; ++i)
                        $root.pb.SkinSetting2Msg.encode(message.skins[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };
    
            /**
             * Decodes a GetSkinSetting2Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetSkinSetting2Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetSkinSetting2Res} GetSkinSetting2Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetSkinSetting2Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetSkinSetting2Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.skins && message.skins.length))
                            message.skins = [];
                        message.skins.push($root.pb.SkinSetting2Msg.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetSkinSetting2Res;
        })();
    
        pb.BuySkin2Req = (function() {
    
            /**
             * Properties of a BuySkin2Req.
             * @memberof pb
             * @interface IBuySkin2Req
             * @property {number|null} [type] BuySkin2Req type
             * @property {number|null} [id] BuySkin2Req id
             */
    
            /**
             * Constructs a new BuySkin2Req.
             * @memberof pb
             * @classdesc Represents a BuySkin2Req.
             * @implements IBuySkin2Req
             * @constructor
             * @param {pb.IBuySkin2Req=} [properties] Properties to set
             */
            function BuySkin2Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BuySkin2Req type.
             * @member {number} type
             * @memberof pb.BuySkin2Req
             * @instance
             */
            BuySkin2Req.prototype.type = 0;
    
            /**
             * BuySkin2Req id.
             * @member {number} id
             * @memberof pb.BuySkin2Req
             * @instance
             */
            BuySkin2Req.prototype.id = 0;
    
            /**
             * Creates a new BuySkin2Req instance using the specified properties.
             * @function create
             * @memberof pb.BuySkin2Req
             * @static
             * @param {pb.IBuySkin2Req=} [properties] Properties to set
             * @returns {pb.BuySkin2Req} BuySkin2Req instance
             */
            BuySkin2Req.create = function create(properties) {
                return new BuySkin2Req(properties);
            };
    
            /**
             * Encodes the specified BuySkin2Req message. Does not implicitly {@link pb.BuySkin2Req.verify|verify} messages.
             * @function encode
             * @memberof pb.BuySkin2Req
             * @static
             * @param {pb.IBuySkin2Req} message BuySkin2Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuySkin2Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                return writer;
            };
    
            /**
             * Decodes a BuySkin2Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.BuySkin2Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.BuySkin2Req} BuySkin2Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuySkin2Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuySkin2Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return BuySkin2Req;
        })();
    
        pb.BuySkin2Res = (function() {
    
            /**
             * Properties of a BuySkin2Res.
             * @memberof pb
             * @interface IBuySkin2Res
             * @property {number|null} [type] BuySkin2Res type
             * @property {number|null} [id] BuySkin2Res id
             * @property {number|null} [crystalCoin] BuySkin2Res crystalCoin
             * @property {number|null} [diamond] BuySkin2Res diamond
             * @property {number|null} [code] BuySkin2Res code
             */
    
            /**
             * Constructs a new BuySkin2Res.
             * @memberof pb
             * @classdesc Represents a BuySkin2Res.
             * @implements IBuySkin2Res
             * @constructor
             * @param {pb.IBuySkin2Res=} [properties] Properties to set
             */
            function BuySkin2Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * BuySkin2Res type.
             * @member {number} type
             * @memberof pb.BuySkin2Res
             * @instance
             */
            BuySkin2Res.prototype.type = 0;
    
            /**
             * BuySkin2Res id.
             * @member {number} id
             * @memberof pb.BuySkin2Res
             * @instance
             */
            BuySkin2Res.prototype.id = 0;
    
            /**
             * BuySkin2Res crystalCoin.
             * @member {number} crystalCoin
             * @memberof pb.BuySkin2Res
             * @instance
             */
            BuySkin2Res.prototype.crystalCoin = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * BuySkin2Res diamond.
             * @member {number} diamond
             * @memberof pb.BuySkin2Res
             * @instance
             */
            BuySkin2Res.prototype.diamond = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
            /**
             * BuySkin2Res code.
             * @member {number} code
             * @memberof pb.BuySkin2Res
             * @instance
             */
            BuySkin2Res.prototype.code = 0;
    
            /**
             * Creates a new BuySkin2Res instance using the specified properties.
             * @function create
             * @memberof pb.BuySkin2Res
             * @static
             * @param {pb.IBuySkin2Res=} [properties] Properties to set
             * @returns {pb.BuySkin2Res} BuySkin2Res instance
             */
            BuySkin2Res.create = function create(properties) {
                return new BuySkin2Res(properties);
            };
    
            /**
             * Encodes the specified BuySkin2Res message. Does not implicitly {@link pb.BuySkin2Res.verify|verify} messages.
             * @function encode
             * @memberof pb.BuySkin2Res
             * @static
             * @param {pb.IBuySkin2Res} message BuySkin2Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BuySkin2Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                if (message.crystalCoin != null && Object.hasOwnProperty.call(message, "crystalCoin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.crystalCoin);
                if (message.diamond != null && Object.hasOwnProperty.call(message, "diamond"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.diamond);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a BuySkin2Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.BuySkin2Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.BuySkin2Res} BuySkin2Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BuySkin2Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuySkin2Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 3:
                        message.crystalCoin = reader.int64();
                        break;
                    case 4:
                        message.diamond = reader.int64();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return BuySkin2Res;
        })();
    
        pb.DecorateSkin2Req = (function() {
    
            /**
             * Properties of a DecorateSkin2Req.
             * @memberof pb
             * @interface IDecorateSkin2Req
             * @property {number|null} [type] DecorateSkin2Req type
             * @property {number|null} [id] DecorateSkin2Req id
             */
    
            /**
             * Constructs a new DecorateSkin2Req.
             * @memberof pb
             * @classdesc Represents a DecorateSkin2Req.
             * @implements IDecorateSkin2Req
             * @constructor
             * @param {pb.IDecorateSkin2Req=} [properties] Properties to set
             */
            function DecorateSkin2Req(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DecorateSkin2Req type.
             * @member {number} type
             * @memberof pb.DecorateSkin2Req
             * @instance
             */
            DecorateSkin2Req.prototype.type = 0;
    
            /**
             * DecorateSkin2Req id.
             * @member {number} id
             * @memberof pb.DecorateSkin2Req
             * @instance
             */
            DecorateSkin2Req.prototype.id = 0;
    
            /**
             * Creates a new DecorateSkin2Req instance using the specified properties.
             * @function create
             * @memberof pb.DecorateSkin2Req
             * @static
             * @param {pb.IDecorateSkin2Req=} [properties] Properties to set
             * @returns {pb.DecorateSkin2Req} DecorateSkin2Req instance
             */
            DecorateSkin2Req.create = function create(properties) {
                return new DecorateSkin2Req(properties);
            };
    
            /**
             * Encodes the specified DecorateSkin2Req message. Does not implicitly {@link pb.DecorateSkin2Req.verify|verify} messages.
             * @function encode
             * @memberof pb.DecorateSkin2Req
             * @static
             * @param {pb.IDecorateSkin2Req} message DecorateSkin2Req message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecorateSkin2Req.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                return writer;
            };
    
            /**
             * Decodes a DecorateSkin2Req message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DecorateSkin2Req
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DecorateSkin2Req} DecorateSkin2Req
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecorateSkin2Req.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DecorateSkin2Req();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DecorateSkin2Req;
        })();
    
        pb.DecorateSkin2Res = (function() {
    
            /**
             * Properties of a DecorateSkin2Res.
             * @memberof pb
             * @interface IDecorateSkin2Res
             * @property {number|null} [type] DecorateSkin2Res type
             * @property {number|null} [id] DecorateSkin2Res id
             * @property {number|null} [code] DecorateSkin2Res code
             */
    
            /**
             * Constructs a new DecorateSkin2Res.
             * @memberof pb
             * @classdesc Represents a DecorateSkin2Res.
             * @implements IDecorateSkin2Res
             * @constructor
             * @param {pb.IDecorateSkin2Res=} [properties] Properties to set
             */
            function DecorateSkin2Res(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * DecorateSkin2Res type.
             * @member {number} type
             * @memberof pb.DecorateSkin2Res
             * @instance
             */
            DecorateSkin2Res.prototype.type = 0;
    
            /**
             * DecorateSkin2Res id.
             * @member {number} id
             * @memberof pb.DecorateSkin2Res
             * @instance
             */
            DecorateSkin2Res.prototype.id = 0;
    
            /**
             * DecorateSkin2Res code.
             * @member {number} code
             * @memberof pb.DecorateSkin2Res
             * @instance
             */
            DecorateSkin2Res.prototype.code = 0;
    
            /**
             * Creates a new DecorateSkin2Res instance using the specified properties.
             * @function create
             * @memberof pb.DecorateSkin2Res
             * @static
             * @param {pb.IDecorateSkin2Res=} [properties] Properties to set
             * @returns {pb.DecorateSkin2Res} DecorateSkin2Res instance
             */
            DecorateSkin2Res.create = function create(properties) {
                return new DecorateSkin2Res(properties);
            };
    
            /**
             * Encodes the specified DecorateSkin2Res message. Does not implicitly {@link pb.DecorateSkin2Res.verify|verify} messages.
             * @function encode
             * @memberof pb.DecorateSkin2Res
             * @static
             * @param {pb.IDecorateSkin2Res} message DecorateSkin2Res message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DecorateSkin2Res.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 100, wireType 0 =*/800).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a DecorateSkin2Res message from the specified reader or buffer.
             * @function decode
             * @memberof pb.DecorateSkin2Res
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.DecorateSkin2Res} DecorateSkin2Res
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DecorateSkin2Res.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DecorateSkin2Res();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.id = reader.int32();
                        break;
                    case 100:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return DecorateSkin2Res;
        })();
    
        pb.GetChannelReq = (function() {
    
            /**
             * Properties of a GetChannelReq.
             * @memberof pb
             * @interface IGetChannelReq
             * @property {number|null} [type] GetChannelReq type
             */
    
            /**
             * Constructs a new GetChannelReq.
             * @memberof pb
             * @classdesc Represents a GetChannelReq.
             * @implements IGetChannelReq
             * @constructor
             * @param {pb.IGetChannelReq=} [properties] Properties to set
             */
            function GetChannelReq(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetChannelReq type.
             * @member {number} type
             * @memberof pb.GetChannelReq
             * @instance
             */
            GetChannelReq.prototype.type = 0;
    
            /**
             * Creates a new GetChannelReq instance using the specified properties.
             * @function create
             * @memberof pb.GetChannelReq
             * @static
             * @param {pb.IGetChannelReq=} [properties] Properties to set
             * @returns {pb.GetChannelReq} GetChannelReq instance
             */
            GetChannelReq.create = function create(properties) {
                return new GetChannelReq(properties);
            };
    
            /**
             * Encodes the specified GetChannelReq message. Does not implicitly {@link pb.GetChannelReq.verify|verify} messages.
             * @function encode
             * @memberof pb.GetChannelReq
             * @static
             * @param {pb.IGetChannelReq} message GetChannelReq message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelReq.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };
    
            /**
             * Decodes a GetChannelReq message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetChannelReq
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetChannelReq} GetChannelReq
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelReq.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetChannelReq();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetChannelReq;
        })();
    
        pb.GetChannelRes = (function() {
    
            /**
             * Properties of a GetChannelRes.
             * @memberof pb
             * @interface IGetChannelRes
             * @property {number|null} [type] GetChannelRes type
             * @property {string|null} [channelId] GetChannelRes channelId
             * @property {number|null} [code] GetChannelRes code
             */
    
            /**
             * Constructs a new GetChannelRes.
             * @memberof pb
             * @classdesc Represents a GetChannelRes.
             * @implements IGetChannelRes
             * @constructor
             * @param {pb.IGetChannelRes=} [properties] Properties to set
             */
            function GetChannelRes(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }
    
            /**
             * GetChannelRes type.
             * @member {number} type
             * @memberof pb.GetChannelRes
             * @instance
             */
            GetChannelRes.prototype.type = 0;
    
            /**
             * GetChannelRes channelId.
             * @member {string} channelId
             * @memberof pb.GetChannelRes
             * @instance
             */
            GetChannelRes.prototype.channelId = "";
    
            /**
             * GetChannelRes code.
             * @member {number} code
             * @memberof pb.GetChannelRes
             * @instance
             */
            GetChannelRes.prototype.code = 0;
    
            /**
             * Creates a new GetChannelRes instance using the specified properties.
             * @function create
             * @memberof pb.GetChannelRes
             * @static
             * @param {pb.IGetChannelRes=} [properties] Properties to set
             * @returns {pb.GetChannelRes} GetChannelRes instance
             */
            GetChannelRes.create = function create(properties) {
                return new GetChannelRes(properties);
            };
    
            /**
             * Encodes the specified GetChannelRes message. Does not implicitly {@link pb.GetChannelRes.verify|verify} messages.
             * @function encode
             * @memberof pb.GetChannelRes
             * @static
             * @param {pb.IGetChannelRes} message GetChannelRes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelRes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.channelId);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 15, wireType 0 =*/120).int32(message.code);
                return writer;
            };
    
            /**
             * Decodes a GetChannelRes message from the specified reader or buffer.
             * @function decode
             * @memberof pb.GetChannelRes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.GetChannelRes} GetChannelRes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelRes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetChannelRes();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type = reader.int32();
                        break;
                    case 2:
                        message.channelId = reader.string();
                        break;
                    case 15:
                        message.code = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };
    
            return GetChannelRes;
        })();
    
        return pb;
    })();

    return $root;
});
